
** Conflict (shift/reduce) in state 181.
** Tokens involved: SUB_OP SEMICOLON POW_OP PIP_OP MUL_OP MOD_OP LT_OP GT_OP EQ_OP DOT DOL_OP DIV_OP COL_OP CAR_OP AT_OP AND_OP ADD_OP
** The following explanations concentrate on token SUB_OP.
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP TFUN T_IDENT COL_OP typesig LAM_TO expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               expr2 
                                               expr3 
                                               expr4 
                                               expr5 
                                               (?)

** In state 181, looking ahead at SUB_OP, reducing production
** expr10 -> TFUN T_IDENT COL_OP typesig LAM_TO expr
** is permitted because of the following sub-derivation:

expr SUB_OP expr // lookahead token appears
expr1 // lookahead token is inherited
expr2 // lookahead token is inherited
expr3 // lookahead token is inherited
expr4 // lookahead token is inherited
expr5 // lookahead token is inherited
expr6 // lookahead token is inherited
expr7 // lookahead token is inherited
expr8 // lookahead token is inherited
expr9 // lookahead token is inherited
expr10 // lookahead token is inherited
TFUN T_IDENT COL_OP typesig LAM_TO expr . 

** In state 181, looking ahead at SUB_OP, shifting is permitted
** because of the following sub-derivation:

expr6 
expr7 
expr8 
expr9 
expr10 
TFUN T_IDENT COL_OP typesig LAM_TO expr 
                                   expr1 
                                   expr2 
                                   expr3 
                                   expr4 
                                   expr5 
                                   expr . SUB_OP expr 

** Conflict (shift/reduce) in state 177.
** Tokens involved: SUB_OP SEMICOLON POW_OP PIP_OP MUL_OP MOD_OP LT_OP GT_OP EQ_OP DOT DOL_OP DIV_OP COL_OP CAR_OP AT_OP AND_OP ADD_OP
** The following explanations concentrate on token SUB_OP.
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP TFUN T_IDENT LAM_TO expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               expr2 
                                               expr3 
                                               expr4 
                                               expr5 
                                               (?)

** In state 177, looking ahead at SUB_OP, reducing production
** expr10 -> TFUN T_IDENT LAM_TO expr
** is permitted because of the following sub-derivation:

expr SUB_OP expr // lookahead token appears
expr1 // lookahead token is inherited
expr2 // lookahead token is inherited
expr3 // lookahead token is inherited
expr4 // lookahead token is inherited
expr5 // lookahead token is inherited
expr6 // lookahead token is inherited
expr7 // lookahead token is inherited
expr8 // lookahead token is inherited
expr9 // lookahead token is inherited
expr10 // lookahead token is inherited
TFUN T_IDENT LAM_TO expr . 

** In state 177, looking ahead at SUB_OP, shifting is permitted
** because of the following sub-derivation:

expr6 
expr7 
expr8 
expr9 
expr10 
TFUN T_IDENT LAM_TO expr 
                    expr1 
                    expr2 
                    expr3 
                    expr4 
                    expr5 
                    expr . SUB_OP expr 

** Conflict (shift/reduce) in state 175.
** Token involved: RPAREN
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP LPAREN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               expr2 
                                               expr3 
                                               expr4 
                                               expr5 
                                               expr6 
                                               expr7 
                                               expr8 
                                               expr9 
                                               expr10 
                                               (?)

** In state 175, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

LPAREN expr . RPAREN 

** In state 175, looking ahead at RPAREN, reducing production
** separated_nonempty_list(COMMA,expr) -> expr
** is permitted because of the following sub-derivation:

expr11 
expr12 
base 
LPAREN separated_nonempty_list(COMMA,expr) RPAREN // lookahead token appears
       expr . 

** Conflict (shift/reduce) in state 171.
** Tokens involved: SUB_OP SEMICOLON POW_OP PIP_OP MUL_OP MOD_OP LT_OP GT_OP EQ_OP DOT DOL_OP DIV_OP COL_OP CAR_OP AT_OP AND_OP ADD_OP
** The following explanations concentrate on token SUB_OP.
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP LET letid list(T_IDENT) EQ_OP expr IN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               expr2 
                                               expr3 
                                               expr4 
                                               expr5 
                                               (?)

** In state 171, looking ahead at SUB_OP, reducing production
** expr10 -> LET letid list(T_IDENT) EQ_OP expr IN expr
** is permitted because of the following sub-derivation:

expr SUB_OP expr // lookahead token appears
expr1 // lookahead token is inherited
expr2 // lookahead token is inherited
expr3 // lookahead token is inherited
expr4 // lookahead token is inherited
expr5 // lookahead token is inherited
expr6 // lookahead token is inherited
expr7 // lookahead token is inherited
expr8 // lookahead token is inherited
expr9 // lookahead token is inherited
expr10 // lookahead token is inherited
LET letid list(T_IDENT) EQ_OP expr IN expr . 

** In state 171, looking ahead at SUB_OP, shifting is permitted
** because of the following sub-derivation:

expr6 
expr7 
expr8 
expr9 
expr10 
LET letid list(T_IDENT) EQ_OP expr IN expr 
                                      expr1 
                                      expr2 
                                      expr3 
                                      expr4 
                                      expr5 
                                      expr . SUB_OP expr 

** Conflict (shift/reduce) in state 165.
** Tokens involved: SUB_OP SEMICOLON POW_OP PIP_OP MUL_OP MOD_OP LT_OP GT_OP EQ_OP DOT DOL_OP DIV_OP COL_OP CAR_OP AT_OP AND_OP ADD_OP
** The following explanations concentrate on token SUB_OP.
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr IN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               expr2 
                                               expr3 
                                               expr4 
                                               expr5 
                                               (?)

** In state 165, looking ahead at SUB_OP, reducing production
** expr10 -> LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr IN expr
** is permitted because of the following sub-derivation:

expr SUB_OP expr // lookahead token appears
expr1 // lookahead token is inherited
expr2 // lookahead token is inherited
expr3 // lookahead token is inherited
expr4 // lookahead token is inherited
expr5 // lookahead token is inherited
expr6 // lookahead token is inherited
expr7 // lookahead token is inherited
expr8 // lookahead token is inherited
expr9 // lookahead token is inherited
expr10 // lookahead token is inherited
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr IN expr . 

** In state 165, looking ahead at SUB_OP, shifting is permitted
** because of the following sub-derivation:

expr6 
expr7 
expr8 
expr9 
expr10 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr IN expr 
                                                       expr1 
                                                       expr2 
                                                       expr3 
                                                       expr4 
                                                       expr5 
                                                       expr . SUB_OP expr 

** Conflict (shift/reduce) in state 162.
** Tokens involved: SUB_OP SEMICOLON POW_OP PIP_OP MUL_OP MOD_OP LT_OP GT_OP EQ_OP DOT DOL_OP DIV_OP COL_OP CAR_OP AT_OP AND_OP ADD_OP
** The following explanations concentrate on token SUB_OP.
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP IF expr THEN expr ELSE expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               expr2 
                                               expr3 
                                               expr4 
                                               expr5 
                                               (?)

** In state 162, looking ahead at SUB_OP, reducing production
** expr10 -> IF expr THEN expr ELSE expr
** is permitted because of the following sub-derivation:

expr SUB_OP expr // lookahead token appears
expr1 // lookahead token is inherited
expr2 // lookahead token is inherited
expr3 // lookahead token is inherited
expr4 // lookahead token is inherited
expr5 // lookahead token is inherited
expr6 // lookahead token is inherited
expr7 // lookahead token is inherited
expr8 // lookahead token is inherited
expr9 // lookahead token is inherited
expr10 // lookahead token is inherited
IF expr THEN expr ELSE expr . 

** In state 162, looking ahead at SUB_OP, shifting is permitted
** because of the following sub-derivation:

expr6 
expr7 
expr8 
expr9 
expr10 
IF expr THEN expr ELSE expr 
                       expr1 
                       expr2 
                       expr3 
                       expr4 
                       expr5 
                       expr . SUB_OP expr 

** Conflict (shift/reduce) in state 157.
** Tokens involved: SUB_OP SEMICOLON POW_OP PIP_OP MUL_OP MOD_OP LT_OP GT_OP EQ_OP DOT DOL_OP DIV_OP COL_OP CAR_OP AT_OP AND_OP ADD_OP
** The following explanations concentrate on token SUB_OP.
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP FUN T_IDENT COL_OP typesig LAM_TO expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               expr2 
                                               expr3 
                                               expr4 
                                               expr5 
                                               (?)

** In state 157, looking ahead at SUB_OP, reducing production
** expr10 -> FUN T_IDENT COL_OP typesig LAM_TO expr
** is permitted because of the following sub-derivation:

expr SUB_OP expr // lookahead token appears
expr1 // lookahead token is inherited
expr2 // lookahead token is inherited
expr3 // lookahead token is inherited
expr4 // lookahead token is inherited
expr5 // lookahead token is inherited
expr6 // lookahead token is inherited
expr7 // lookahead token is inherited
expr8 // lookahead token is inherited
expr9 // lookahead token is inherited
expr10 // lookahead token is inherited
FUN T_IDENT COL_OP typesig LAM_TO expr . 

** In state 157, looking ahead at SUB_OP, shifting is permitted
** because of the following sub-derivation:

expr6 
expr7 
expr8 
expr9 
expr10 
FUN T_IDENT COL_OP typesig LAM_TO expr 
                                  expr1 
                                  expr2 
                                  expr3 
                                  expr4 
                                  expr5 
                                  expr . SUB_OP expr 

** Conflict (shift/reduce) in state 116.
** Token involved: RPAREN
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP fexpr LPAREN expr

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               expr2 
                                               fexpr nonempty_list(parenexpr) 
                                                     parenexpr 
                                                     (?)

** In state 116, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

LPAREN expr . RPAREN 

** In state 116, looking ahead at RPAREN, reducing production
** separated_nonempty_list(COMMA,expr) -> expr
** is permitted because of the following sub-derivation:

base 
LPAREN separated_nonempty_list(COMMA,expr) RPAREN // lookahead token appears
       expr . 

** Conflict (shift/reduce) in state 65.
** Token involved: T_IDENT
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP mod_follow_h

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               module_acc 
                                               (?)

** In state 65, looking ahead at T_IDENT, shifting is permitted
** because of the following sub-derivation:

mod_follow letid 
nonempty_list(mod_follow_h) 
mod_follow_h nonempty_list(mod_follow_h) 
             mod_follow_h 
             . T_IDENT DOT 

** In state 65, looking ahead at T_IDENT, reducing production
** nonempty_list(mod_follow_h) -> mod_follow_h
** is permitted because of the following sub-derivation:

mod_follow letid // lookahead token appears because letid can begin with T_IDENT
nonempty_list(mod_follow_h) // lookahead token is inherited
mod_follow_h . 

** Conflict (shift/reduce) in state 50.
** Token involved: T_IDENT
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP LET T_IDENT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               expr2 
                                               expr3 
                                               expr4 
                                               expr5 
                                               expr6 
                                               expr7 
                                               expr8 
                                               expr9 
                                               expr10 
                                               (?)

** In state 50, looking ahead at T_IDENT, reducing production
** letid -> T_IDENT
** is permitted because of the following sub-derivation:

LET letid list(T_IDENT) EQ_OP expr IN expr // lookahead token appears because list(T_IDENT) can begin with T_IDENT
    T_IDENT . 

** In state 50, looking ahead at T_IDENT, shifting is permitted
** because of the following sub-derivation:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr IN expr 
            . T_IDENT list(T_IDENT) 

** Conflict (shift/reduce) in state 39.
** Token involved: DOT
** This state is reached from program after reading:

LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP T_IDENT

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
siglet 
LET T_IDENT list(T_IDENT) COL_OP typesig EQ_OP expr 
                                               expr1 
                                               (?)

** In state 39, looking ahead at DOT, reducing production
** base -> T_IDENT
** is permitted because of the following sub-derivation:

expr2 
expr3 
expr4 
expr5 
expr6 
expr7 
expr8 
expr9 
expr10 
expr DOT T_INT // lookahead token appears
expr1 // lookahead token is inherited
expr2 // lookahead token is inherited
expr3 // lookahead token is inherited
expr4 // lookahead token is inherited
expr5 // lookahead token is inherited
expr6 // lookahead token is inherited
expr7 // lookahead token is inherited
expr8 // lookahead token is inherited
expr9 // lookahead token is inherited
expr10 // lookahead token is inherited
expr11 // lookahead token is inherited
expr12 // lookahead token is inherited
base // lookahead token is inherited
T_IDENT . 

** In state 39, looking ahead at DOT, shifting is permitted
** because of the following sub-derivation:

module_acc 
mod_follow letid 
nonempty_list(mod_follow_h) 
mod_follow_h 
T_IDENT . DOT 

** Conflict (shift/reduce) in state 26.
** Token involved: RPAREN
** This state is reached from program after reading:

EXTERN T_IDENT COL_OP LPAREN typesig

** The derivations that appear below have the following common factor:
** (The question mark symbol (?) represents the spot where the derivations begin to differ.)

program 
nonempty_list(toplevel) EOF 
toplevel 
EXTERN T_IDENT COL_OP typesig 
                      typesig_i 
                      (?)

** In state 26, looking ahead at RPAREN, shifting is permitted
** because of the following sub-derivation:

ktype 
LPAREN typesig . RPAREN T_IDENT 

** In state 26, looking ahead at RPAREN, reducing production
** separated_nonempty_list(COMMA,typesig) -> typesig
** is permitted because of the following sub-derivation:

LPAREN separated_nonempty_list(COMMA,typesig) RPAREN // lookahead token appears
       typesig . 

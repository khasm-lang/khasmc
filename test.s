	.file	"a.out.c"
# GNU C17 (GCC) version 12.2.0 (x86_64-unknown-linux-gnu)
#	compiled by GNU C version 12.2.0, GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl-0.24-GMP

# GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
# options passed: -mtune=generic -march=x86-64 -O3
	.text
#APP
	  .text
  .globl kha_extern_96_s_95_eq
  .quad 2
kha_extern_96_s_95_eq:
  jmp kha_extern_96_s_95_eq_impl

	  .text
  .globl kha_extern_96_int_95_add
  .quad 2
kha_extern_96_int_95_add:
  jmp kha_extern_96_int_95_add_impl

	  .text
  .globl kha_extern_96_int_95_sub
  .quad 2
kha_extern_96_int_95_sub:
  jmp kha_extern_96_int_95_sub_impl

	  .text
  .globl kha_extern_96_int_95_mul
  .quad 2
kha_extern_96_int_95_mul:
  jmp kha_extern_96_int_95_mul_impl

	  .text
  .globl kha_extern_96_int_95_div
  .quad 2
kha_extern_96_int_95_div:
  jmp kha_extern_96_int_95_div_impl

	  .text
  .globl kha_extern_96_float_95_add
  .quad 2
kha_extern_96_float_95_add:
  jmp kha_extern_96_float_95_add_impl

	  .text
  .globl kha_extern_96_float_95_sub
  .quad 2
kha_extern_96_float_95_sub:
  jmp kha_extern_96_float_95_sub_impl

	  .text
  .globl kha_extern_96_float_95_mul
  .quad 2
kha_extern_96_float_95_mul:
  jmp kha_extern_96_float_95_mul_impl

	  .text
  .globl kha_extern_96_float_95_div
  .quad 2
kha_extern_96_float_95_div:
  jmp kha_extern_96_float_95_div_impl

	  .text
  .globl kha_extern_96_print_95_int
  .quad 1
kha_extern_96_print_95_int:
  jmp kha_extern_96_print_95_int_impl

	  .text
  .globl kha_extern_96_print_95_str
  .quad 1
kha_extern_96_print_95_str:
  jmp kha_extern_96_print_95_str_impl

	  .text
  .globl khasm_tuple_acc
  .quad 2
khasm_tuple_acc:
  jmp khasm_tuple_acc_impl

	  .text
  .globl khasm_46_Stdlib_46__61_
  .quad 0
khasm_46_Stdlib_46__61_:
  jmp khasm_46_Stdlib_46__61__impl

	  .text
  .globl khasm_46_Stdlib_46__43_
  .quad 0
khasm_46_Stdlib_46__43_:
  jmp khasm_46_Stdlib_46__43__impl

	  .text
  .globl khasm_46_Stdlib_46__45_
  .quad 0
khasm_46_Stdlib_46__45_:
  jmp khasm_46_Stdlib_46__45__impl

	  .text
  .globl khasm_46_Stdlib_46__47_
  .quad 0
khasm_46_Stdlib_46__47_:
  jmp khasm_46_Stdlib_46__47__impl

	  .text
  .globl khasm_46_Stdlib_46__42_
  .quad 0
khasm_46_Stdlib_46__42_:
  jmp khasm_46_Stdlib_46__42__impl

	  .text
  .globl khasm_46_Stdlib_46__43__46_
  .quad 0
khasm_46_Stdlib_46__43__46_:
  jmp khasm_46_Stdlib_46__43__46__impl

	  .text
  .globl khasm_46_Stdlib_46__45__46_
  .quad 0
khasm_46_Stdlib_46__45__46_:
  jmp khasm_46_Stdlib_46__45__46__impl

	  .text
  .globl khasm_46_Stdlib_46__42__46_
  .quad 0
khasm_46_Stdlib_46__42__46_:
  jmp khasm_46_Stdlib_46__42__46__impl

	  .text
  .globl khasm_46_Stdlib_46__47__46_
  .quad 0
khasm_46_Stdlib_46__47__46_:
  jmp khasm_46_Stdlib_46__47__46__impl

	  .text
  .globl khasm_46_Stdlib_46_pipe
  .quad 2
khasm_46_Stdlib_46_pipe:
  jmp khasm_46_Stdlib_46_pipe_impl

	  .text
  .globl khasm_46_Stdlib_46__124__62_
  .quad 0
khasm_46_Stdlib_46__124__62_:
  jmp khasm_46_Stdlib_46__124__62__impl

	  .text
  .globl khasm_46_Stdlib_46_apply
  .quad 2
khasm_46_Stdlib_46_apply:
  jmp khasm_46_Stdlib_46_apply_impl

	  .text
  .globl khasm_46_Stdlib_46__60__124_
  .quad 0
khasm_46_Stdlib_46__60__124_:
  jmp khasm_46_Stdlib_46__60__124__impl

	  .text
  .globl khasm_46_Stdlib_46_compose
  .quad 3
khasm_46_Stdlib_46_compose:
  jmp khasm_46_Stdlib_46_compose_impl

	  .text
  .globl khasm_46_Stdlib_46__62__62_
  .quad 0
khasm_46_Stdlib_46__62__62_:
  jmp khasm_46_Stdlib_46__62__62__impl

	  .text
  .globl khasm_46_Stdlib_46_rcompose
  .quad 3
khasm_46_Stdlib_46_rcompose:
  jmp khasm_46_Stdlib_46_rcompose_impl

	  .text
  .globl khasm_46_Stdlib_46__60__60_
  .quad 0
khasm_46_Stdlib_46__60__60_:
  jmp khasm_46_Stdlib_46__60__60__impl

	  .text
  .globl khasm_46_Fib_46_fib
  .quad 1
khasm_46_Fib_46_fib:
  jmp khasm_46_Fib_46_fib_impl

	  .text
  .globl main_____Khasm
  .quad 1
main_____Khasm:
  jmp main_____Khasm_impl

	.section	.rodata.str1.1,"aMS",@progbits,1
.LC0:
	.string	"can't ref null\n"
#NO_APP
	.text
	.p2align 4
	.type	ref.part.0, @function
ref.part.0:
.LFB71:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:197:     fprintf(stderr, "can't ref null\n");
	movl	$15, %edx	#,
	movl	$1, %esi	#,
	movq	stderr(%rip), %rcx	# stderr,
	leaq	.LC0(%rip), %rdi	#, tmp84
	call	fwrite@PLT	#
# a.out.c:198:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE71:
	.size	ref.part.0, .-ref.part.0
	.p2align 4
	.type	make_tuple.constprop.0, @function
make_tuple.constprop.0:
.LFB74:
	.cfi_startproc
	pushq	%rbx	#
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:334:   k->data.tuple = malloc(sizeof(struct kha_obj_tuple));
	movl	$16, %edi	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %rbx	# tmp88, tmp85
# a.out.c:334:   k->data.tuple = malloc(sizeof(struct kha_obj_tuple));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$263, (%rbx)	#, MEM[(union  *)a_11]
# a.out.c:334:   k->data.tuple = malloc(sizeof(struct kha_obj_tuple));
	movq	%rax, 8(%rbx)	# tmp86, a_11->data.tuple
# a.out.c:335:   k->data.tuple->len = num;
	movq	$0, (%rax)	#, MEM[(struct kha_obj_tuple *)_12].len
# a.out.c:336:   k->data.tuple->tups = arr;
	movq	$0, 8(%rax)	#, MEM[(struct kha_obj_tuple *)_12].tups
# a.out.c:339: }
	movq	%rbx, %rax	# tmp85,
	popq	%rbx	#
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE74:
	.size	make_tuple.constprop.0, .-make_tuple.constprop.0
	.p2align 4
	.globl	new_kha_obj
	.type	new_kha_obj, @function
new_kha_obj:
.LFB23:
	.cfi_startproc
	pushq	%rbx	#
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
# a.out.c:187: kha_obj * new_kha_obj(kha_obj_typ t) {
	movl	%edi, %ebx	# tmp101, t
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movb	%bl, (%rax)	# t, a_3->D.4393.D.4391.tag
# a.out.c:190:   a->gc = 0;
	movb	$0, 1(%rax)	#,
	movb	$0, 2(%rax)	#,
	movb	$0, 3(%rax)	#,
	movb	$0, 4(%rax)	#,
	movb	$0, 5(%rax)	#,
	movb	$0, 6(%rax)	#,
	movb	$0, 7(%rax)	#,
# a.out.c:192: }
	popq	%rbx	#
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE23:
	.size	new_kha_obj, .-new_kha_obj
	.p2align 4
	.globl	ref
	.type	ref, @function
ref:
.LFB24:
	.cfi_startproc
# a.out.c:196:   if (!a) {
	testq	%rdi, %rdi	# a
	je	.L13	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %rcx	#, tmp92
# a.out.c:200:   a->gc += 1;
	movq	(%rdi), %rdx	# *a_3(D), tmp88
	movq	%rdi, %rax	# tmp128, a
	shrq	$8, %rdx	#, tmp88
# a.out.c:200:   a->gc += 1;
	addq	$1, %rdx	#, tmp90
	andq	%rcx, %rdx	# tmp92, tmp91
	movq	%rdx, %rcx	# tmp91, tmp102
	movb	%dl, 1(%rdi)	# tmp91,
	shrq	$16, %rcx	#, tmp102
	movb	%dh, 2(%rdi)	# tmp91,
	movb	%cl, 3(%rdi)	# tmp102,
	movq	%rdx, %rcx	# tmp91, tmp107
	shrq	$24, %rcx	#, tmp107
	movb	%cl, 4(%rdi)	# tmp107,
	movq	%rdx, %rcx	# tmp91, tmp112
	shrq	$32, %rcx	#, tmp112
	movb	%cl, 5(%rdi)	# tmp112,
	movq	%rdx, %rcx	# tmp91, tmp117
	shrq	$48, %rdx	#, tmp123
	shrq	$40, %rcx	#, tmp117
	movb	%dl, 7(%rdi)	# tmp123,
	movb	%cl, 6(%rdi)	# tmp117,
# a.out.c:202: }
	ret	
.L13:
# a.out.c:195: inline kha_obj * ref(kha_obj * a) {
	pushq	%rax	#
	.cfi_def_cfa_offset 16
	call	ref.part.0	#
	.cfi_endproc
.LFE24:
	.size	ref, .-ref
	.section	.rodata.str1.1
.LC1:
	.string	"UNREACHABLE???\n"
	.text
	.p2align 4
	.globl	k_free
	.type	k_free, @function
k_free:
.LFB26:
	.cfi_startproc
# a.out.c:215:   if (!a) return;
	testq	%rdi, %rdi	# a
	je	.L14	#,
# a.out.c:214: void k_free(kha_obj * a) {
	pushq	%r12	#
	.cfi_def_cfa_offset 16
	.cfi_offset 12, -16
	pushq	%rbp	#
	.cfi_def_cfa_offset 24
	.cfi_offset 6, -24
	pushq	%rbx	#
	.cfi_def_cfa_offset 32
	.cfi_offset 3, -32
# a.out.c:216:   switch (a->tag) {
	cmpb	$7, (%rdi)	#, a_44(D)->D.4393.D.4391.tag
	movq	%rdi, %rbx	# tmp261, a
	ja	.L16	#,
	movzbl	(%rdi), %eax	# a_44(D)->D.4393.D.4391.tag, a_44(D)->D.4393.D.4391.tag
	leaq	.L18(%rip), %rdx	#, tmp121
	movslq	(%rdx,%rax,4), %rax	#, tmp123
	addq	%rdx, %rax	# tmp121, tmp124
	jmp	*%rax	# tmp124
	.section	.rodata
	.align 4
	.align 4
.L18:
	.long	.L22-.L18
	.long	.L21-.L18
	.long	.L63-.L18
	.long	.L63-.L18
	.long	.L63-.L18
	.long	.L63-.L18
	.long	.L19-.L18
	.long	.L17-.L18
	.text
	.p2align 4,,10
	.p2align 3
.L19:
# a.out.c:256:       free(a->data.str->data);
	movq	8(%rdi), %rax	# a_44(D)->data.str, a_44(D)->data.str
# a.out.c:256:       free(a->data.str->data);
	movq	(%rax), %rdi	# _32->data, _32->data
.L64:
	call	free@PLT	#
# a.out.c:257:       free(a->data.str);
	movq	8(%rbx), %rdi	#, a_44(D)->data.str
.L65:
	call	free@PLT	#
.L63:
# a.out.c:259:       free(a);
	movq	%rbx, %rdi	# a,
# a.out.c:268: }
	popq	%rbx	#
	.cfi_remember_state
	.cfi_restore 3
	.cfi_def_cfa_offset 24
	popq	%rbp	#
	.cfi_restore 6
	.cfi_def_cfa_offset 16
	popq	%r12	#
	.cfi_restore 12
	.cfi_def_cfa_offset 8
# a.out.c:259:       free(a);
	jmp	free@PLT	#
	.p2align 4,,10
	.p2align 3
.L17:
	.cfi_restore_state
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %r12	#, tmp258
# a.out.c:245:       for (int i = 0; i < a->data.tuple->len; i++) {
	movq	8(%rdi), %rax	#, _98
# a.out.c:245:       for (int i = 0; i < a->data.tuple->len; i++) {
	xorl	%ebp, %ebp	# ivtmp.99
# a.out.c:245:       for (int i = 0; i < a->data.tuple->len; i++) {
	movq	(%rax), %rdx	# _90->len, prephitmp_120
# a.out.c:245:       for (int i = 0; i < a->data.tuple->len; i++) {
	testq	%rdx, %rdx	# prephitmp_120
	jne	.L23	#,
	jmp	.L24	#
	.p2align 4,,10
	.p2align 3
.L62:
# a.out.c:245:       for (int i = 0; i < a->data.tuple->len; i++) {
	movq	8(%rbx), %rax	# a_44(D)->data.tuple, _98
# a.out.c:245:       for (int i = 0; i < a->data.tuple->len; i++) {
	movq	(%rax), %rdx	#* _98, prephitmp_120
.L33:
# a.out.c:245:       for (int i = 0; i < a->data.tuple->len; i++) {
	addq	$1, %rbp	#, ivtmp.99
	cmpq	%rdx, %rbp	# prephitmp_120, ivtmp.99
	jnb	.L24	#,
.L23:
# a.out.c:246:         unref(a->data.tuple->tups[i]);
	movq	8(%rax), %rcx	# _98->tups, _98->tups
	movq	(%rcx,%rbp,8), %rdi	# *_22, _23
# a.out.c:205:   if (!a) {
	testq	%rdi, %rdi	# _23
	je	.L33	#,
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# MEM[(struct kha_obj *)_23], tmp215
	shrq	$8, %rax	#, tmp215
# a.out.c:208:   a->gc -= 1;
	addq	%r12, %rax	# tmp258, _72
	andq	%r12, %rax	# tmp258, _72
	movq	%rax, %rdx	# _72, tmp228
	movb	%al, 1(%rdi)	# _72,
	shrq	$16, %rdx	#, tmp228
	movb	%ah, 2(%rdi)	# _72,
	movb	%dl, 3(%rdi)	# tmp228,
	movq	%rax, %rdx	# _72, tmp233
	shrq	$24, %rdx	#, tmp233
	movb	%dl, 4(%rdi)	# tmp233,
	movq	%rax, %rdx	# _72, tmp238
	shrq	$32, %rdx	#, tmp238
	movb	%dl, 5(%rdi)	# tmp238,
	movq	%rax, %rdx	# _72, tmp243
	shrq	$40, %rdx	#, tmp243
	movb	%dl, 6(%rdi)	# tmp243,
	movq	%rax, %rdx	# _72, tmp249
	shrq	$48, %rdx	#, tmp249
	movb	%dl, 7(%rdi)	# tmp249,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _72
	jne	.L62	#,
# a.out.c:210:     k_free(a);
	call	k_free	#
	jmp	.L62	#
	.p2align 4,,10
	.p2align 3
.L22:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %r12	#, tmp259
# a.out.c:235:       for (int i = 0; i < a->data.pap->argnum; i++) {
	movq	8(%rdi), %rax	#, _95
# a.out.c:235:       for (int i = 0; i < a->data.pap->argnum; i++) {
	xorl	%ebp, %ebp	# ivtmp.88
# a.out.c:235:       for (int i = 0; i < a->data.pap->argnum; i++) {
	movq	16(%rax), %rdx	# _92->argnum, prephitmp_147
# a.out.c:235:       for (int i = 0; i < a->data.pap->argnum; i++) {
	testq	%rdx, %rdx	# prephitmp_147
	jne	.L27	#,
	jmp	.L28	#
	.p2align 4,,10
	.p2align 3
.L61:
# a.out.c:235:       for (int i = 0; i < a->data.pap->argnum; i++) {
	movq	8(%rbx), %rax	# a_44(D)->data.pap, _95
# a.out.c:235:       for (int i = 0; i < a->data.pap->argnum; i++) {
	movq	16(%rax), %rdx	#, prephitmp_147
.L31:
# a.out.c:235:       for (int i = 0; i < a->data.pap->argnum; i++) {
	addq	$1, %rbp	#, ivtmp.88
	cmpq	%rdx, %rbp	# prephitmp_147, ivtmp.88
	jnb	.L28	#,
.L27:
# a.out.c:236: 	unref(a->data.adt->data[i]);
	movq	8(%rax), %rcx	# MEM[(struct kha_obj_adt *)_95].data, MEM[(struct kha_obj_adt *)_95].data
	movq	(%rcx,%rbp,8), %rdi	# *_13, _14
# a.out.c:205:   if (!a) {
	testq	%rdi, %rdi	# _14
	je	.L31	#,
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# MEM[(struct kha_obj *)_14], tmp172
	shrq	$8, %rax	#, tmp172
# a.out.c:208:   a->gc -= 1;
	addq	%r12, %rax	# tmp259, _70
	andq	%r12, %rax	# tmp259, _70
	movq	%rax, %rdx	# _70, tmp185
	movb	%al, 1(%rdi)	# _70,
	shrq	$16, %rdx	#, tmp185
	movb	%ah, 2(%rdi)	# _70,
	movb	%dl, 3(%rdi)	# tmp185,
	movq	%rax, %rdx	# _70, tmp190
	shrq	$24, %rdx	#, tmp190
	movb	%dl, 4(%rdi)	# tmp190,
	movq	%rax, %rdx	# _70, tmp195
	shrq	$32, %rdx	#, tmp195
	movb	%dl, 5(%rdi)	# tmp195,
	movq	%rax, %rdx	# _70, tmp200
	shrq	$40, %rdx	#, tmp200
	movb	%dl, 6(%rdi)	# tmp200,
	movq	%rax, %rdx	# _70, tmp206
	shrq	$48, %rdx	#, tmp206
	movb	%dl, 7(%rdi)	# tmp206,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _70
	jne	.L61	#,
# a.out.c:210:     k_free(a);
	call	k_free	#
	jmp	.L61	#
	.p2align 4,,10
	.p2align 3
.L21:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %r12	#, tmp260
# a.out.c:225:       for (int i = 0; i < a->data.pap->argnum; i++) {
	movq	8(%rdi), %rax	#, _89
# a.out.c:225:       for (int i = 0; i < a->data.pap->argnum; i++) {
	xorl	%ebp, %ebp	# ivtmp.94
# a.out.c:225:       for (int i = 0; i < a->data.pap->argnum; i++) {
	movq	16(%rax), %rdx	# _86->argnum, prephitmp_135
# a.out.c:225:       for (int i = 0; i < a->data.pap->argnum; i++) {
	testq	%rdx, %rdx	# prephitmp_135
	jne	.L25	#,
	jmp	.L28	#
	.p2align 4,,10
	.p2align 3
.L60:
# a.out.c:225:       for (int i = 0; i < a->data.pap->argnum; i++) {
	movq	8(%rbx), %rax	# a_44(D)->data.pap, _89
# a.out.c:225:       for (int i = 0; i < a->data.pap->argnum; i++) {
	movq	16(%rax), %rdx	#, prephitmp_135
.L29:
# a.out.c:225:       for (int i = 0; i < a->data.pap->argnum; i++) {
	addq	$1, %rbp	#, ivtmp.94
	cmpq	%rdx, %rbp	# prephitmp_135, ivtmp.94
	jnb	.L28	#,
.L25:
# a.out.c:226: 	unref(a->data.pap->args[i]);
	movq	8(%rax), %rcx	# _89->args, _89->args
	movq	(%rcx,%rbp,8), %rdi	# *_4, _5
# a.out.c:205:   if (!a) {
	testq	%rdi, %rdi	# _5
	je	.L29	#,
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# MEM[(struct kha_obj *)_5], tmp129
	shrq	$8, %rax	#, tmp129
# a.out.c:208:   a->gc -= 1;
	addq	%r12, %rax	# tmp260, _68
	andq	%r12, %rax	# tmp260, _68
	movq	%rax, %rdx	# _68, tmp142
	movb	%al, 1(%rdi)	# _68,
	shrq	$16, %rdx	#, tmp142
	movb	%ah, 2(%rdi)	# _68,
	movb	%dl, 3(%rdi)	# tmp142,
	movq	%rax, %rdx	# _68, tmp147
	shrq	$24, %rdx	#, tmp147
	movb	%dl, 4(%rdi)	# tmp147,
	movq	%rax, %rdx	# _68, tmp152
	shrq	$32, %rdx	#, tmp152
	movb	%dl, 5(%rdi)	# tmp152,
	movq	%rax, %rdx	# _68, tmp157
	shrq	$40, %rdx	#, tmp157
	movb	%dl, 6(%rdi)	# tmp157,
	movq	%rax, %rdx	# _68, tmp163
	shrq	$48, %rdx	#, tmp163
	movb	%dl, 7(%rdi)	# tmp163,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _68
	jne	.L60	#,
# a.out.c:210:     k_free(a);
	call	k_free	#
	jmp	.L60	#
	.p2align 4,,10
	.p2align 3
.L28:
# a.out.c:238:       free(a->data.adt->data);
	movq	8(%rax), %rdi	#, MEM[(struct kha_obj_adt *)_96].data
	jmp	.L64	#
	.p2align 4,,10
	.p2align 3
.L14:
	.cfi_def_cfa_offset 8
	.cfi_restore 3
	.cfi_restore 6
	.cfi_restore 12
	ret	
	.p2align 4,,10
	.p2align 3
.L24:
	.cfi_def_cfa_offset 32
	.cfi_offset 3, -32
	.cfi_offset 6, -24
	.cfi_offset 12, -16
# a.out.c:248:       if (a->data.tuple->tups)
	movq	8(%rax), %rdi	# _99->tups, _28
# a.out.c:248:       if (a->data.tuple->tups)
	testq	%rdi, %rdi	# _28
	je	.L35	#,
# a.out.c:249: 	free(a->data.tuple->tups);
	call	free@PLT	#
# a.out.c:250:       free(a->data.tuple);
	movq	8(%rbx), %rax	# a_44(D)->data.tuple, _98
.L35:
# a.out.c:250:       free(a->data.tuple);
	movq	%rax, %rdi	# _98,
	jmp	.L65	#
.L16:
# a.out.c:264:     fprintf(stderr, "UNREACHABLE???\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$15, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC1(%rip), %rdi	#, tmp257
	call	fwrite@PLT	#
# a.out.c:265:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE26:
	.size	k_free, .-k_free
	.p2align 4
	.globl	unref
	.type	unref, @function
unref:
.LFB25:
	.cfi_startproc
# a.out.c:205:   if (!a) {
	testq	%rdi, %rdi	# a
	je	.L66	#,
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp89
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_4(D), tmp87
	shrq	$8, %rax	#, tmp87
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp89, _2
	andq	%rdx, %rax	# tmp89, _2
	movq	%rax, %rdx	# _2, tmp100
	movb	%al, 1(%rdi)	# _2,
	shrq	$16, %rdx	#, tmp100
	movb	%ah, 2(%rdi)	# _2,
	movb	%dl, 3(%rdi)	# tmp100,
	movq	%rax, %rdx	# _2, tmp105
	shrq	$24, %rdx	#, tmp105
	movb	%dl, 4(%rdi)	# tmp105,
	movq	%rax, %rdx	# _2, tmp110
	shrq	$32, %rdx	#, tmp110
	movb	%dl, 5(%rdi)	# tmp110,
	movq	%rax, %rdx	# _2, tmp115
	shrq	$40, %rdx	#, tmp115
	movb	%dl, 6(%rdi)	# tmp115,
	movq	%rax, %rdx	# _2, tmp121
	shrq	$48, %rdx	#, tmp121
	movb	%dl, 7(%rdi)	# tmp121,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _2
	je	.L70	#,
.L66:
# a.out.c:212: }
	ret	
	.p2align 4,,10
	.p2align 3
.L70:
# a.out.c:210:     k_free(a);
	jmp	k_free	#
	.cfi_endproc
.LFE25:
	.size	unref, .-unref
	.p2align 4
	.globl	make_raw_ptr
	.type	make_raw_ptr, @function
make_raw_ptr:
.LFB27:
	.cfi_startproc
	pushq	%rbx	#
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
# a.out.c:272: kha_obj * make_raw_ptr(void *p) {
	movq	%rdi, %rbx	# tmp87, p
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	%rbx, 8(%rax)	# p, a_6->data.ptr
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_6]
# a.out.c:277: }
	popq	%rbx	#
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE27:
	.size	make_raw_ptr, .-make_raw_ptr
	.p2align 4
	.globl	make_ptr
	.type	make_ptr, @function
make_ptr:
.LFB28:
	.cfi_startproc
	pushq	%rbx	#
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
# a.out.c:279: kha_obj * make_ptr(kha_obj * p) {
	movq	%rdi, %rbx	# tmp145, p
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$3, (%rax)	#, MEM[(union  *)a_8]
# a.out.c:196:   if (!a) {
	testq	%rbx, %rbx	# p
	je	.L76	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %rcx	#, tmp94
# a.out.c:200:   a->gc += 1;
	movq	(%rbx), %rdx	# *p_3(D), tmp90
	shrq	$8, %rdx	#, tmp90
# a.out.c:200:   a->gc += 1;
	addq	$1, %rdx	#, tmp92
	andq	%rcx, %rdx	# tmp94, tmp93
	movq	%rdx, %rcx	# tmp93, tmp104
	movb	%dl, 1(%rbx)	# tmp93,
	shrq	$16, %rcx	#, tmp104
	movb	%dh, 2(%rbx)	# tmp93,
	movb	%cl, 3(%rbx)	# tmp104,
	movq	%rdx, %rcx	# tmp93, tmp109
	shrq	$24, %rcx	#, tmp109
	movb	%cl, 4(%rbx)	# tmp109,
	movq	%rdx, %rcx	# tmp93, tmp114
	shrq	$32, %rcx	#, tmp114
	movb	%cl, 5(%rbx)	# tmp114,
	movq	%rdx, %rcx	# tmp93, tmp119
	shrq	$48, %rdx	#, tmp125
	shrq	$40, %rcx	#, tmp119
	movb	%dl, 7(%rbx)	# tmp125,
	movb	%cl, 6(%rbx)	# tmp119,
# a.out.c:281:   k->data.ptr = ref(p);
	movq	%rbx, 8(%rax)	# p, a_8->data.ptr
# a.out.c:282:   k->gc = 1;
	movb	$1, 1(%rax)	#,
	movb	$0, 2(%rax)	#,
	movb	$0, 3(%rax)	#,
	movb	$0, 4(%rax)	#,
	movb	$0, 5(%rax)	#,
	movb	$0, 6(%rax)	#,
	movb	$0, 7(%rax)	#,
# a.out.c:284: }
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 8
	ret	
.L76:
	.cfi_restore_state
	call	ref.part.0	#
	.cfi_endproc
.LFE28:
	.size	make_ptr, .-make_ptr
	.p2align 4
	.globl	make_int
	.type	make_int, @function
make_int:
.LFB29:
	.cfi_startproc
	pushq	%rbx	#
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
# a.out.c:286: kha_obj * make_int(i64 i) {
	movq	%rdi, %rbx	# tmp86, i
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:288:   k->data.i = i;
	movq	%rbx, 8(%rax)	# i, a_5->data.i
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_5]
# a.out.c:291: }
	popq	%rbx	#
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE29:
	.size	make_int, .-make_int
	.p2align 4
	.globl	make_float
	.type	make_float, @function
make_float:
.LFB30:
	.cfi_startproc
	subq	$24, %rsp	#,
	.cfi_def_cfa_offset 32
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:293: kha_obj * make_float(f64 f) {
	movsd	%xmm0, 8(%rsp)	# f, %sfp
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:295:   k->data.f = f;
	movsd	8(%rsp), %xmm0	# %sfp, f
# a.out.c:189:   a->tag = t;
	movq	$261, (%rax)	#, MEM[(union  *)a_5]
# a.out.c:295:   k->data.f = f;
	movsd	%xmm0, 8(%rax)	# f, a_5->data.f
# a.out.c:298: }
	addq	$24, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE30:
	.size	make_float, .-make_float
	.p2align 4
	.globl	make_string
	.type	make_string, @function
make_string:
.LFB31:
	.cfi_startproc
	pushq	%r12	#
	.cfi_def_cfa_offset 16
	.cfi_offset 12, -16
	movq	%rdi, %r12	# tmp95, f
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:300: kha_obj * make_string(char * f) {
	pushq	%rbp	#
	.cfi_def_cfa_offset 24
	.cfi_offset 6, -24
	pushq	%rbx	#
	.cfi_def_cfa_offset 32
	.cfi_offset 3, -32
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:302:   k->data.str = malloc(sizeof(struct kha_obj_str));
	movl	$16, %edi	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %rbx	# tmp96, tmp88
# a.out.c:302:   k->data.str = malloc(sizeof(struct kha_obj_str));
	call	malloc@PLT	#
# a.out.c:303:   k->data.str->data = strdup(f);
	movq	%r12, %rdi	# f,
# a.out.c:302:   k->data.str = malloc(sizeof(struct kha_obj_str));
	movq	%rax, 8(%rbx)	# tmp89, a_13->data.str
# a.out.c:302:   k->data.str = malloc(sizeof(struct kha_obj_str));
	movq	%rax, %rbp	# tmp97, tmp89
# a.out.c:303:   k->data.str->data = strdup(f);
	call	strdup@PLT	#
# a.out.c:304:   k->data.str->len = strlen(f);
	movq	%r12, %rdi	# f,
# a.out.c:303:   k->data.str->data = strdup(f);
	movq	%rax, 0(%rbp)	# tmp98, MEM[(struct kha_obj_str *)_1].data
# a.out.c:304:   k->data.str->len = strlen(f);
	call	strlen@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$262, (%rbx)	#, MEM[(union  *)a_13]
# a.out.c:304:   k->data.str->len = strlen(f);
	movq	%rax, 8(%rbp)	# tmp99, MEM[(struct kha_obj_str *)_1].len
# a.out.c:307: }
	movq	%rbx, %rax	# tmp88,
	popq	%rbx	#
	.cfi_def_cfa_offset 24
	popq	%rbp	#
	.cfi_def_cfa_offset 16
	popq	%r12	#
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE31:
	.size	make_string, .-make_string
	.p2align 4
	.globl	make_pap
	.type	make_pap, @function
make_pap:
.LFB32:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	movq	%rdi, %r13	# tmp91, argnum
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:309: kha_obj * make_pap(u64 argnum, void * p, kha_obj ** args) {
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	movq	%rdx, %r12	# tmp93, args
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	movq	%rsi, %rbp	# tmp92, p
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 48
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movl	$24, %edi	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %rbx	# tmp94, tmp88
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$257, (%rbx)	#, MEM[(union  *)a_13]
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movq	%rax, 8(%rbx)	# tmp89, a_13->data.pap
# a.out.c:312:   k->data.pap->argnum = argnum;
	movq	%r13, 16(%rax)	# argnum, MEM[(struct kha_obj_pap *)_1].argnum
# a.out.c:313:   k->data.pap->args = args;
	movq	%r12, 8(%rax)	# args, MEM[(struct kha_obj_pap *)_1].args
# a.out.c:314:   k->data.pap->func = p;
	movq	%rbp, (%rax)	# p, MEM[(struct kha_obj_pap *)_1].func
# a.out.c:317: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 40
	movq	%rbx, %rax	# tmp88,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE32:
	.size	make_pap, .-make_pap
	.p2align 4
	.globl	make_tuple
	.type	make_tuple, @function
make_tuple:
.LFB33:
	.cfi_startproc
	pushq	%r15	#
	.cfi_def_cfa_offset 16
	.cfi_offset 15, -16
	pushq	%r14	#
	.cfi_def_cfa_offset 24
	.cfi_offset 14, -24
	pushq	%r13	#
	.cfi_def_cfa_offset 32
	.cfi_offset 13, -32
	pushq	%r12	#
	.cfi_def_cfa_offset 40
	.cfi_offset 12, -40
	pushq	%rbp	#
	.cfi_def_cfa_offset 48
	.cfi_offset 6, -48
	pushq	%rbx	#
	.cfi_def_cfa_offset 56
	.cfi_offset 3, -56
	subq	$104, %rsp	#,
	.cfi_def_cfa_offset 160
# a.out.c:319: kha_obj * make_tuple(u64 num, ...) {
	movq	%rdi, 8(%rsp)	# num, %sfp
	movq	%rsi, 56(%rsp)	#,
	movq	%rdx, 64(%rsp)	#,
	movq	%rcx, 72(%rsp)	#,
	movq	%r8, 80(%rsp)	#,
	movq	%r9, 88(%rsp)	#,
	movq	%fs:40, %rax	# MEM[(<address-space-1> long unsigned int *)40B], tmp251
	movq	%rax, 40(%rsp)	# tmp251, D.6004
	xorl	%eax, %eax	# tmp251
# a.out.c:321:   if (num == 0) {
	testq	%rdi, %rdi	# num
	je	.L97	#,
# a.out.c:326:     va_start(ap, num);
	leaq	160(%rsp), %rax	#, tmp254
# a.out.c:327:     arr = malloc(sizeof(kha_obj*) * num);
	leaq	0(,%rdi,8), %rdi	#, tmp115
# a.out.c:326:     va_start(ap, num);
	movl	$8, 16(%rsp)	#, MEM[(struct [1] *)&ap].gp_offset
# a.out.c:329:       arr[i] = ref(va_arg(ap, kha_obj*));
	xorl	%r12d, %r12d	# ap__overflow_arg_area_lsm_flag.143
# a.out.c:326:     va_start(ap, num);
	movq	%rax, 24(%rsp)	# tmp254, MEM[(struct [1] *)&ap].overflow_arg_area
	leaq	48(%rsp), %rax	#, tmp255
	movq	%rax, 32(%rsp)	# tmp255, MEM[(struct [1] *)&ap].reg_save_area
# a.out.c:327:     arr = malloc(sizeof(kha_obj*) * num);
	call	malloc@PLT	#
# a.out.c:329:       arr[i] = ref(va_arg(ap, kha_obj*));
	movq	32(%rsp), %r11	# MEM[(struct  *)&ap].reg_save_area, D.5975
	movl	16(%rsp), %esi	# MEM[(struct  *)&ap].gp_offset, ap__gp_offset_lsm.144
	xorl	%r9d, %r9d	# ap__gp_offset_lsm_flag.145
	movq	24(%rsp), %r8	# MEM[(struct  *)&ap].overflow_arg_area, ap__overflow_arg_area_lsm.142
# a.out.c:327:     arr = malloc(sizeof(kha_obj*) * num);
	movq	%rax, %rbp	# tmp246, arr
# a.out.c:329:       arr[i] = ref(va_arg(ap, kha_obj*));
	movl	$1, %ecx	#, ivtmp.138
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r10	#, tmp244
	.p2align 4,,10
	.p2align 3
.L91:
# a.out.c:329:       arr[i] = ref(va_arg(ap, kha_obj*));
	cmpl	$47, %esi	#, ap__gp_offset_lsm.144
	jbe	.L110	#,
	movq	%r8, %rax	# ap__overflow_arg_area_lsm.142, addr.126
	movl	%esi, %edi	# ap__gp_offset_lsm.144, D.5977
	addq	$8, %r8	#, ap__overflow_arg_area_lsm.142
	movl	$1, %r12d	#, ap__overflow_arg_area_lsm_flag.143
.L88:
	movq	(%rax), %rdx	# MEM[(struct kha_obj * * {ref-all})addr.126_41], _2
# a.out.c:196:   if (!a) {
	testq	%rdx, %rdx	# _2
	je	.L94	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rdx), %rax	# *_2, tmp122
	shrq	$8, %rax	#, tmp122
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp124
	andq	%r10, %rax	# tmp244, tmp125
	movq	%rax, %r13	# tmp125, tmp136
	movb	%al, 1(%rdx)	# tmp125,
	shrq	$16, %r13	#, tmp136
	movb	%ah, 2(%rdx)	# tmp125,
	movb	%r13b, 3(%rdx)	# tmp136,
	movq	%rax, %r13	# tmp125, tmp141
	shrq	$24, %r13	#, tmp141
	movb	%r13b, 4(%rdx)	# tmp141,
	movq	%rax, %r13	# tmp125, tmp146
	shrq	$32, %r13	#, tmp146
	movb	%r13b, 5(%rdx)	# tmp146,
	movq	%rax, %r13	# tmp125, tmp151
	shrq	$48, %rax	#, tmp157
	shrq	$40, %r13	#, tmp151
	movb	%al, 7(%rdx)	# tmp157,
	movb	%r13b, 6(%rdx)	# tmp151,
# a.out.c:329:       arr[i] = ref(va_arg(ap, kha_obj*));
	movq	%rdx, -8(%rbp,%rcx,8)	# _2, MEM[(struct kha_obj * *)arr_46 + -8B + ivtmp.138_73 * 8]
# a.out.c:328:     for (int i = 0; i < num; i++) {
	cmpq	%rcx, 8(%rsp)	# ivtmp.138, %sfp
	je	.L86	#,
	leaq	1(%rcx), %rax	#, ivtmp.138
	cmpl	$47, %esi	#, ap__gp_offset_lsm.144
	jbe	.L98	#,
	testb	%r9b, %r9b	# ap__gp_offset_lsm_flag.145
	je	.L92	#,
	movl	%edi, 16(%rsp)	# D.5977, MEM[(struct  *)&ap].gp_offset
.L92:
	testb	%r12b, %r12b	# ap__overflow_arg_area_lsm_flag.143
	je	.L93	#,
	movq	%r8, 24(%rsp)	# ap__overflow_arg_area_lsm.142, MEM[(struct  *)&ap].overflow_arg_area
.L93:
	movslq	%ecx, %r10	# ivtmp.138, ivtmp.138
	movq	24(%rsp), %r11	# MEM[(void * *)&ap + 8B], D.5979
	addq	$1, %r10	#, ivtmp.134
	jmp	.L95	#
	.p2align 4,,10
	.p2align 3
.L99:
	movq	%r15, %r10	# ivtmp.134, ivtmp.134
.L95:
	movq	%r11, %rax	# D.5979, ap__overflow_arg_area_lsm0.129
# a.out.c:329:       arr[i] = ref(va_arg(ap, kha_obj*));
	leaq	0(%rbp,%rcx,8), %r12	#, _61
# a.out.c:329:       arr[i] = ref(va_arg(ap, kha_obj*));
	addq	$8, %r11	#, D.5979
	movq	(%rax), %rdx	# MEM[(struct kha_obj * * {ref-all})ap__overflow_arg_area_lsm0.129_32], _59
# a.out.c:196:   if (!a) {
	testq	%rdx, %rdx	# _59
	je	.L94	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rdx), %rax	# *_59, tmp165
# a.out.c:328:     for (int i = 0; i < num; i++) {
	leaq	1(%r10), %r15	#, ivtmp.134
	movq	%r10, %rcx	# ivtmp.134, ivtmp.138
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %rbx	#, tmp263
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp165
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, _63
	andq	%rbx, %rax	# tmp263, _63
	movq	%rax, %r9	# _63, tmp177
	movq	%rax, %r8	# _63, tmp182
	movq	%rax, %rdi	# _63, tmp187
	movq	%rax, %rsi	# _63, tmp192
	shrq	$16, %r9	#, tmp177
	shrq	$24, %r8	#, tmp182
	movzbl	%ah, %ebx	# _63, tmp173
	movzbl	%al, %r14d	# _63, _63
	shrq	$32, %rdi	#, tmp187
	shrq	$40, %rsi	#, tmp192
	movzbl	%r9b, %r9d	# tmp177, tmp178
	movzbl	%r8b, %r8d	# tmp182, tmp183
	movzbl	%dil, %edi	# tmp187, tmp188
	movzbl	%sil, %esi	# tmp192, tmp193
	shrq	$48, %rax	#, tmp198
	movb	%r14b, 1(%rdx)	# _63,
	movb	%bl, 2(%rdx)	# tmp173,
	movq	%rbx, %r13	# tmp173, tmp173
	movb	%r9b, 3(%rdx)	# tmp178,
	movb	%r8b, 4(%rdx)	# tmp183,
	movb	%dil, 5(%rdx)	# tmp188,
	movb	%sil, 6(%rdx)	# tmp193,
	movb	%al, 7(%rdx)	# tmp198,
# a.out.c:328:     for (int i = 0; i < num; i++) {
	movq	8(%rsp), %rbx	# %sfp, num
# a.out.c:329:       arr[i] = ref(va_arg(ap, kha_obj*));
	movq	%rdx, (%r12)	# _59, *_61
# a.out.c:328:     for (int i = 0; i < num; i++) {
	cmpq	%rbx, %r10	# num, ivtmp.138
	jb	.L99	#,
	movb	%r14b, 1(%rdx)	# _63,
	movb	%r13b, 2(%rdx)	# tmp173,
	movb	%r9b, 3(%rdx)	# tmp178,
	movb	%r8b, 4(%rdx)	# tmp183,
	movb	%dil, 5(%rdx)	# tmp188,
	movb	%sil, 6(%rdx)	# tmp193,
	movb	%al, 7(%rdx)	# tmp198,
	movq	%rdx, (%r12)	# _59, *_61
.L86:
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:334:   k->data.tuple = malloc(sizeof(struct kha_obj_tuple));
	movl	$16, %edi	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp247, tmp236
# a.out.c:334:   k->data.tuple = malloc(sizeof(struct kha_obj_tuple));
	call	malloc@PLT	#
# a.out.c:335:   k->data.tuple->len = num;
	movq	8(%rsp), %rbx	# %sfp, num
# a.out.c:189:   a->tag = t;
	movq	$263, (%r12)	#, MEM[(union  *)a_28]
# a.out.c:334:   k->data.tuple = malloc(sizeof(struct kha_obj_tuple));
	movq	%rax, 8(%r12)	# tmp237, a_28->data.tuple
# a.out.c:335:   k->data.tuple->len = num;
	movq	%rbx, (%rax)	# num, MEM[(struct kha_obj_tuple *)_6].len
# a.out.c:336:   k->data.tuple->tups = arr;
	movq	%rbp, 8(%rax)	# arr, MEM[(struct kha_obj_tuple *)_6].tups
# a.out.c:339: }
	movq	40(%rsp), %rax	# D.6004, tmp252
	subq	%fs:40, %rax	# MEM[(<address-space-1> long unsigned int *)40B], tmp252
	jne	.L111	#,
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
	movq	%r12, %rax	# tmp236,
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L110:
	.cfi_restore_state
# a.out.c:329:       arr[i] = ref(va_arg(ap, kha_obj*));
	movl	%esi, %eax	# ap__gp_offset_lsm.144, D.5976
	leal	8(%rsi), %edi	#, D.5977
	movl	$1, %r9d	#, ap__gp_offset_lsm_flag.145
	addq	%r11, %rax	# D.5975, addr.126
	jmp	.L88	#
	.p2align 4,,10
	.p2align 3
.L98:
# a.out.c:328:     for (int i = 0; i < num; i++) {
	movl	%edi, %esi	# D.5977, ap__gp_offset_lsm.144
	movq	%rax, %rcx	# ivtmp.138, ivtmp.138
	jmp	.L91	#
	.p2align 4,,10
	.p2align 3
.L97:
# a.out.c:322:     arr = NULL;
	xorl	%ebp, %ebp	# arr
	jmp	.L86	#
.L94:
# a.out.c:197:     fprintf(stderr, "can't ref null\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$15, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC0(%rip), %rdi	#, tmp119
	call	fwrite@PLT	#
# a.out.c:198:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
.L111:
# a.out.c:339: }
	call	__stack_chk_fail@PLT	#
	.cfi_endproc
.LFE33:
	.size	make_tuple, .-make_tuple
	.section	.rodata.str1.1
.LC2:
	.string	"TODO: copy other stuff"
	.text
	.p2align 4
	.globl	copy
	.type	copy, @function
copy:
.LFB34:
	.cfi_startproc
	pushq	%r14	#
	.cfi_def_cfa_offset 16
	.cfi_offset 14, -16
	pushq	%r13	#
	.cfi_def_cfa_offset 24
	.cfi_offset 13, -24
	pushq	%r12	#
	.cfi_def_cfa_offset 32
	.cfi_offset 12, -32
	pushq	%rbp	#
	.cfi_def_cfa_offset 40
	.cfi_offset 6, -40
	pushq	%rbx	#
	.cfi_def_cfa_offset 48
	.cfi_offset 3, -48
# a.out.c:342:   if (a->tag == PAP) {
	cmpb	$1, (%rdi)	#, a_18(D)->D.4393.D.4391.tag
	jne	.L113	#,
	movq	%rdi, %r12	# tmp170, a
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:344:     new->data.pap = malloc(sizeof(struct kha_obj_pap));
	movl	$24, %edi	#,
# a.out.c:189:   a->tag = t;
	movq	$1, (%rax)	#, MEM[(union  *)a_30]
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r14	# tmp171, <retval>
# a.out.c:344:     new->data.pap = malloc(sizeof(struct kha_obj_pap));
	call	malloc@PLT	#
# a.out.c:346:       = a->data.pap->argnum;
	movq	8(%r12), %r13	# a_18(D)->data.pap, _3
# a.out.c:344:     new->data.pap = malloc(sizeof(struct kha_obj_pap));
	movq	%rax, %rbp	# tmp172, tmp100
# a.out.c:344:     new->data.pap = malloc(sizeof(struct kha_obj_pap));
	movq	%rax, 8(%r14)	# tmp100, a_30->data.pap
# a.out.c:346:       = a->data.pap->argnum;
	movq	16(%r13), %r12	# _3->argnum, _4
# a.out.c:346:       = a->data.pap->argnum;
	movq	%r12, 16(%rax)	# _4, MEM[(struct kha_obj_pap *)_2].argnum
# a.out.c:348:       = a->data.pap->func;
	movq	0(%r13), %rax	# _3->func, _5
# a.out.c:350:       = malloc(sizeof(kha_obj *)
	salq	$3, %r12	#, _6
	movq	%r12, %rdi	# _6,
# a.out.c:348:       = a->data.pap->func;
	movq	%rax, 0(%rbp)	# _5, MEM[(struct kha_obj_pap *)_2].func
# a.out.c:350:       = malloc(sizeof(kha_obj *)
	call	malloc@PLT	#
# a.out.c:352:     memcpy(new->data.pap->args,
	movq	%r12, %rdx	# _6,
# a.out.c:350:       = malloc(sizeof(kha_obj *)
	movq	%rax, 8(%rbp)	# _7, MEM[(struct kha_obj_pap *)_2].args
# a.out.c:352:     memcpy(new->data.pap->args,
	movq	8(%r13), %rsi	# _3->args, _3->args
# a.out.c:350:       = malloc(sizeof(kha_obj *)
	movq	%rax, %rdi	# tmp173, _7
# a.out.c:352:     memcpy(new->data.pap->args,
	call	memcpy@PLT	#
# a.out.c:356:     for (int i = 0; i < a->data.pap->argnum; i++) {
	movq	16(%r13), %r8	# _3->argnum, _37
# a.out.c:352:     memcpy(new->data.pap->args,
	movq	%rax, %rdi	#, _7
# a.out.c:356:     for (int i = 0; i < a->data.pap->argnum; i++) {
	testq	%r8, %r8	# _37
	je	.L114	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r9	#, tmp169
# a.out.c:356:     for (int i = 0; i < a->data.pap->argnum; i++) {
	xorl	%ecx, %ecx	# ivtmp.151
	.p2align 4,,10
	.p2align 3
.L116:
# a.out.c:357:       ref(new->data.pap->args[i]);
	movq	(%rdi,%rcx,8), %rdx	# MEM[(struct kha_obj * *)_7 + ivtmp.151_47 * 8], _11
# a.out.c:196:   if (!a) {
	testq	%rdx, %rdx	# _11
	je	.L123	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rdx), %rax	# MEM[(struct kha_obj *)_11], tmp112
# a.out.c:356:     for (int i = 0; i < a->data.pap->argnum; i++) {
	addq	$1, %rcx	#, ivtmp.151
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp112
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp114
	andq	%r9, %rax	# tmp169, tmp115
	movq	%rax, %rsi	# tmp115, tmp126
	movb	%al, 1(%rdx)	# tmp115,
	shrq	$16, %rsi	#, tmp126
	movb	%ah, 2(%rdx)	# tmp115,
	movb	%sil, 3(%rdx)	# tmp126,
	movq	%rax, %rsi	# tmp115, tmp131
	shrq	$24, %rsi	#, tmp131
	movb	%sil, 4(%rdx)	# tmp131,
	movq	%rax, %rsi	# tmp115, tmp136
	shrq	$32, %rsi	#, tmp136
	movb	%sil, 5(%rdx)	# tmp136,
	movq	%rax, %rsi	# tmp115, tmp141
	shrq	$48, %rax	#, tmp147
	shrq	$40, %rsi	#, tmp141
	movb	%al, 7(%rdx)	# tmp147,
	movb	%sil, 6(%rdx)	# tmp141,
# a.out.c:356:     for (int i = 0; i < a->data.pap->argnum; i++) {
	cmpq	%rcx, %r8	# ivtmp.151, _37
	jne	.L116	#,
.L114:
# a.out.c:359:     new->gc = 1;
	movb	$1, 1(%r14)	#,
# a.out.c:366: }
	movq	%r14, %rax	# <retval>,
# a.out.c:359:     new->gc = 1;
	movb	$0, 2(%r14)	#,
	movb	$0, 3(%r14)	#,
	movb	$0, 4(%r14)	#,
	movb	$0, 5(%r14)	#,
	movb	$0, 6(%r14)	#,
	movb	$0, 7(%r14)	#,
# a.out.c:366: }
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	popq	%rbp	#
	.cfi_def_cfa_offset 32
	popq	%r12	#
	.cfi_def_cfa_offset 24
	popq	%r13	#
	.cfi_def_cfa_offset 16
	popq	%r14	#
	.cfi_def_cfa_offset 8
	ret	
.L123:
	.cfi_restore_state
# a.out.c:197:     fprintf(stderr, "can't ref null\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$15, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC0(%rip), %rdi	#, tmp109
	call	fwrite@PLT	#
# a.out.c:198:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
.L113:
# a.out.c:363:     fprintf(stderr, "TODO: copy other stuff");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$22, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC2(%rip), %rdi	#, tmp168
	call	fwrite@PLT	#
# a.out.c:364:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE34:
	.size	copy, .-copy
	.section	.rodata.str1.1
.LC3:
	.string	"Can't copy_pap non-pap\n"
	.text
	.p2align 4
	.globl	copy_pap
	.type	copy_pap, @function
copy_pap:
.LFB35:
	.cfi_startproc
	pushq	%r14	#
	.cfi_def_cfa_offset 16
	.cfi_offset 14, -16
	pushq	%r13	#
	.cfi_def_cfa_offset 24
	.cfi_offset 13, -24
	pushq	%r12	#
	.cfi_def_cfa_offset 32
	.cfi_offset 12, -32
	pushq	%rbp	#
	.cfi_def_cfa_offset 40
	.cfi_offset 6, -40
	pushq	%rbx	#
	.cfi_def_cfa_offset 48
	.cfi_offset 3, -48
# a.out.c:372:   if (a->gc == 1) {
	movq	(%rdi), %rax	# *a_20(D), tmp102
	shrq	$8, %rax	#, tmp102
# a.out.c:372:   if (a->gc == 1) {
	cmpq	$1, %rax	#, tmp102
	je	.L130	#,
# a.out.c:375:   if (a->tag != PAP) {
	cmpb	$1, (%rdi)	#, a_20(D)->D.4393.D.4391.tag
	jne	.L136	#,
# a.out.c:380: 			   * (a->data.pap->argnum));
	movq	8(%rdi), %rbp	# a_20(D)->data.pap, _3
# a.out.c:379:   kha_obj ** args = malloc(sizeof(kha_obj*)
	movq	16(%rbp), %rax	# _3->argnum, tmp167
	leaq	0(,%rax,8), %r12	#, _5
	movq	%r12, %rdi	# _5,
	call	malloc@PLT	#
# a.out.c:381:   memcpy(args, a->data.pap->args,
	movq	8(%rbp), %rsi	# _3->args, _3->args
	movq	%r12, %rdx	# _5,
	movq	%rax, %rdi	# args,
# a.out.c:379:   kha_obj ** args = malloc(sizeof(kha_obj*)
	movq	%rax, %r14	# tmp162, args
# a.out.c:381:   memcpy(args, a->data.pap->args,
	call	memcpy@PLT	#
# a.out.c:383:   for(int i = 0; i < a->data.pap->argnum; i++) {
	movq	16(%rbp), %r12	# _3->argnum, _24
# a.out.c:383:   for(int i = 0; i < a->data.pap->argnum; i++) {
	testq	%r12, %r12	# _24
	je	.L127	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %rdi	#, tmp160
# a.out.c:383:   for(int i = 0; i < a->data.pap->argnum; i++) {
	xorl	%ecx, %ecx	# ivtmp.160
	.p2align 4,,10
	.p2align 3
.L129:
# a.out.c:384:     ref(args[i]);
	movq	(%r14,%rcx,8), %rdx	# MEM[(struct kha_obj * *)args_22 + ivtmp.160_51 * 8], _12
# a.out.c:196:   if (!a) {
	testq	%rdx, %rdx	# _12
	je	.L137	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rdx), %rax	# *_12, tmp118
# a.out.c:383:   for(int i = 0; i < a->data.pap->argnum; i++) {
	addq	$1, %rcx	#, ivtmp.160
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp118
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp120
	andq	%rdi, %rax	# tmp160, tmp121
	movq	%rax, %rsi	# tmp121, tmp132
	movb	%al, 1(%rdx)	# tmp121,
	shrq	$16, %rsi	#, tmp132
	movb	%ah, 2(%rdx)	# tmp121,
	movb	%sil, 3(%rdx)	# tmp132,
	movq	%rax, %rsi	# tmp121, tmp137
	shrq	$24, %rsi	#, tmp137
	movb	%sil, 4(%rdx)	# tmp137,
	movq	%rax, %rsi	# tmp121, tmp142
	shrq	$32, %rsi	#, tmp142
	movb	%sil, 5(%rdx)	# tmp142,
	movq	%rax, %rsi	# tmp121, tmp147
	shrq	$48, %rax	#, tmp153
	shrq	$40, %rsi	#, tmp147
	movb	%al, 7(%rdx)	# tmp153,
	movb	%sil, 6(%rdx)	# tmp147,
# a.out.c:383:   for(int i = 0; i < a->data.pap->argnum; i++) {
	cmpq	%rcx, %r12	# ivtmp.160, _24
	jne	.L129	#,
.L127:
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:387: 			   a->data.pap->func,
	movq	0(%rbp), %r13	# _3->func, _15
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movl	$24, %edi	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %rbp	# tmp163, <retval>
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$257, 0(%rbp)	#, MEM[(union  *)a_33]
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movq	%rax, 8(%rbp)	# tmp158, a_33->data.pap
# a.out.c:312:   k->data.pap->argnum = argnum;
	movq	%r12, 16(%rax)	# _24, MEM[(struct kha_obj_pap *)_34].argnum
# a.out.c:313:   k->data.pap->args = args;
	movq	%r14, 8(%rax)	# args, MEM[(struct kha_obj_pap *)_34].args
# a.out.c:314:   k->data.pap->func = p;
	movq	%r13, (%rax)	# _15, MEM[(struct kha_obj_pap *)_34].func
# a.out.c:390: }
	movq	%rbp, %rax	# <retval>,
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	popq	%rbp	#
	.cfi_def_cfa_offset 32
	popq	%r12	#
	.cfi_def_cfa_offset 24
	popq	%r13	#
	.cfi_def_cfa_offset 16
	popq	%r14	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L130:
	.cfi_restore_state
	movq	%rdi, %rbp	# a, <retval>
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%rbp, %rax	# <retval>,
	popq	%rbp	#
	.cfi_def_cfa_offset 32
	popq	%r12	#
	.cfi_def_cfa_offset 24
	popq	%r13	#
	.cfi_def_cfa_offset 16
	popq	%r14	#
	.cfi_def_cfa_offset 8
	ret	
.L137:
	.cfi_restore_state
# a.out.c:197:     fprintf(stderr, "can't ref null\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$15, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC0(%rip), %rdi	#, tmp115
	call	fwrite@PLT	#
# a.out.c:198:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
.L136:
# a.out.c:376:     fprintf(stderr, "Can't copy_pap non-pap\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$23, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC3(%rip), %rdi	#, tmp105
	call	fwrite@PLT	#
# a.out.c:377:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE35:
	.size	copy_pap, .-copy_pap
	.section	.rodata.str1.8,"aMS",@progbits,1
	.align 8
.LC4:
	.string	"IMPOSSIBLE: reached end of 'call' \n"
	.text
	.p2align 4
	.globl	call
	.type	call, @function
call:
.LFB38:
	.cfi_startproc
	pushq	%r15	#
	.cfi_def_cfa_offset 16
	.cfi_offset 15, -16
	pushq	%r14	#
	.cfi_def_cfa_offset 24
	.cfi_offset 14, -24
	pushq	%r13	#
	.cfi_def_cfa_offset 32
	.cfi_offset 13, -32
	pushq	%r12	#
	.cfi_def_cfa_offset 40
	.cfi_offset 12, -40
	pushq	%rbp	#
	.cfi_def_cfa_offset 48
	.cfi_offset 6, -48
	pushq	%rbx	#
	.cfi_def_cfa_offset 56
	.cfi_offset 3, -56
	movq	%rdi, %rbx	# tmp1140, a
	subq	$104, %rsp	#,
	.cfi_def_cfa_offset 160
# a.out.c:455:   GET_ARGS(argnum, a->data.pap->func);
	movq	8(%rdi), %rax	# a_177(D)->data.pap, _1
	movq	(%rax), %rbp	# _1->func, _2
# a.out.c:457:   if (a->data.pap->argnum < argnum) {
	movq	16(%rax), %rcx	# _1->argnum, _6
# a.out.c:455:   GET_ARGS(argnum, a->data.pap->func);
	movq	-8(%rbp), %rdx	# *_5, argnum
# a.out.c:457:   if (a->data.pap->argnum < argnum) {
	cmpq	%rdx, %rcx	# argnum, _6
	jb	.L192	#,
# a.out.c:459:   } else if (a->data.pap->argnum == argnum) {
	je	.L197	#,
# a.out.c:721:     switch (argnum) {
	cmpq	$15, %rdx	#, argnum
	ja	.L141	#,
	leaq	.L176(%rip), %rcx	#, tmp1056
	movslq	(%rcx,%rdx,4), %rdx	#, tmp1058
	addq	%rcx, %rdx	# tmp1056, tmp1059
	jmp	*%rdx	# tmp1059
	.section	.rodata
	.align 4
	.align 4
.L176:
	.long	.L191-.L176
	.long	.L190-.L176
	.long	.L189-.L176
	.long	.L188-.L176
	.long	.L187-.L176
	.long	.L186-.L176
	.long	.L185-.L176
	.long	.L184-.L176
	.long	.L183-.L176
	.long	.L182-.L176
	.long	.L181-.L176
	.long	.L180-.L176
	.long	.L179-.L176
	.long	.L178-.L176
	.long	.L177-.L176
	.long	.L175-.L176
	.text
	.p2align 4,,10
	.p2align 3
.L197:
# a.out.c:460:     switch (argnum) {
	cmpq	$15, %rcx	#, _6
	ja	.L141	#,
	leaq	.L143(%rip), %rsi	#, tmp410
	movslq	(%rsi,%rcx,4), %rdx	#, tmp412
	addq	%rsi, %rdx	# tmp410, tmp413
	jmp	*%rdx	# tmp413
	.section	.rodata
	.align 4
	.align 4
.L143:
	.long	.L158-.L143
	.long	.L157-.L143
	.long	.L156-.L143
	.long	.L155-.L143
	.long	.L154-.L143
	.long	.L153-.L143
	.long	.L152-.L143
	.long	.L151-.L143
	.long	.L150-.L143
	.long	.L149-.L143
	.long	.L148-.L143
	.long	.L147-.L143
	.long	.L146-.L143
	.long	.L145-.L143
	.long	.L144-.L143
	.long	.L142-.L143
	.text
	.p2align 4,,10
	.p2align 3
.L192:
	movq	%rdi, %rax	# a, <retval>
.L138:
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L177:
	.cfi_restore_state
# a.out.c:857:           a->data.pap->args[12], a->data.pap->args[13]));
	movq	8(%rax), %rax	# _1->args, _140
# a.out.c:851:     return MUSTTAIL reconcile(
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_140 + 16B], MEM[(struct kha_obj * *)_140 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_140 + 8B], MEM[(struct kha_obj * *)_140 + 8B]
	movq	(%rax), %rdi	# *_140, *_140
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_140 + 40B], MEM[(struct kha_obj * *)_140 + 40B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_140 + 32B], MEM[(struct kha_obj * *)_140 + 32B]
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_140 + 24B], MEM[(struct kha_obj * *)_140 + 24B]
	pushq	104(%rax)	# MEM[(struct kha_obj * *)_140 + 104B]
	.cfi_def_cfa_offset 168
	pushq	96(%rax)	# MEM[(struct kha_obj * *)_140 + 96B]
	.cfi_def_cfa_offset 176
	pushq	88(%rax)	# MEM[(struct kha_obj * *)_140 + 88B]
	.cfi_def_cfa_offset 184
	pushq	80(%rax)	# MEM[(struct kha_obj * *)_140 + 80B]
	.cfi_def_cfa_offset 192
	pushq	72(%rax)	# MEM[(struct kha_obj * *)_140 + 72B]
	.cfi_def_cfa_offset 200
	pushq	64(%rax)	# MEM[(struct kha_obj * *)_140 + 64B]
	.cfi_def_cfa_offset 208
	pushq	56(%rax)	# MEM[(struct kha_obj * *)_140 + 56B]
	.cfi_def_cfa_offset 216
	pushq	48(%rax)	# MEM[(struct kha_obj * *)_140 + 48B]
	.cfi_def_cfa_offset 224
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$14, %edi	#,
	movq	%rax, %rdx	# tmp1164, _155
# a.out.c:875: }
	addq	$168, %rsp	#,
	.cfi_def_cfa_offset 56
.L196:
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
# a.out.c:864:     return MUSTTAIL reconcile(
	jmp	reconcile	#
	.p2align 4,,10
	.p2align 3
.L175:
	.cfi_def_cfa_offset 160
# a.out.c:870:           a->data.pap->args[12], a->data.pap->args[13], a->data.pap->args[14]));
	movq	8(%rax), %rax	# _1->args, _156
# a.out.c:864:     return MUSTTAIL reconcile(
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 168
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_156 + 16B], MEM[(struct kha_obj * *)_156 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_156 + 8B], MEM[(struct kha_obj * *)_156 + 8B]
	movq	(%rax), %rdi	# *_156, *_156
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_156 + 40B], MEM[(struct kha_obj * *)_156 + 40B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_156 + 32B], MEM[(struct kha_obj * *)_156 + 32B]
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_156 + 24B], MEM[(struct kha_obj * *)_156 + 24B]
	pushq	112(%rax)	# MEM[(struct kha_obj * *)_156 + 112B]
	.cfi_def_cfa_offset 176
	pushq	104(%rax)	# MEM[(struct kha_obj * *)_156 + 104B]
	.cfi_def_cfa_offset 184
	pushq	96(%rax)	# MEM[(struct kha_obj * *)_156 + 96B]
	.cfi_def_cfa_offset 192
	pushq	88(%rax)	# MEM[(struct kha_obj * *)_156 + 88B]
	.cfi_def_cfa_offset 200
	pushq	80(%rax)	# MEM[(struct kha_obj * *)_156 + 80B]
	.cfi_def_cfa_offset 208
	pushq	72(%rax)	# MEM[(struct kha_obj * *)_156 + 72B]
	.cfi_def_cfa_offset 216
	pushq	64(%rax)	# MEM[(struct kha_obj * *)_156 + 64B]
	.cfi_def_cfa_offset 224
	pushq	56(%rax)	# MEM[(struct kha_obj * *)_156 + 56B]
	.cfi_def_cfa_offset 232
	pushq	48(%rax)	# MEM[(struct kha_obj * *)_156 + 48B]
	.cfi_def_cfa_offset 240
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$15, %edi	#,
	movq	%rax, %rdx	# tmp1165, _172
# a.out.c:875: }
	addq	$184, %rsp	#,
	.cfi_def_cfa_offset 56
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L191:
	.cfi_def_cfa_offset 160
# a.out.c:724:       return MUSTTAIL reconcile(argnum, a, f());
	xorl	%eax, %eax	#
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	xorl	%edi, %edi	#
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:724:       return MUSTTAIL reconcile(argnum, a, f());
	movq	%rax, %rdx	# tmp1150, _22
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L190:
	.cfi_restore_state
# a.out.c:729:     return MUSTTAIL reconcile(argnum, a, f(a->data.pap->args[0]));
	movq	8(%rax), %rax	# _1->args, _1->args
	movq	(%rax), %rdi	# *_23, *_23
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$1, %edi	#,
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:729:     return MUSTTAIL reconcile(argnum, a, f(a->data.pap->args[0]));
	movq	%rax, %rdx	# tmp1151, _25
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L189:
	.cfi_restore_state
# a.out.c:735:                               f(a->data.pap->args[0], a->data.pap->args[1]));
	movq	8(%rax), %rax	# _1->args, _26
# a.out.c:734:     return MUSTTAIL reconcile(argnum, a,
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_26 + 8B], MEM[(struct kha_obj * *)_26 + 8B]
	movq	(%rax), %rdi	# *_26, *_26
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$2, %edi	#,
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:734:     return MUSTTAIL reconcile(argnum, a,
	movq	%rax, %rdx	# tmp1152, _29
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L188:
	.cfi_restore_state
# a.out.c:742:         f(a->data.pap->args[0], a->data.pap->args[1], a->data.pap->args[2]));
	movq	8(%rax), %rax	# _1->args, _30
# a.out.c:740:     return MUSTTAIL reconcile(
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_30 + 16B], MEM[(struct kha_obj * *)_30 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_30 + 8B], MEM[(struct kha_obj * *)_30 + 8B]
	movq	(%rax), %rdi	# *_30, *_30
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$3, %edi	#,
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:740:     return MUSTTAIL reconcile(
	movq	%rax, %rdx	# tmp1153, _34
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L187:
	.cfi_restore_state
# a.out.c:749:                                 a->data.pap->args[2], a->data.pap->args[3]));
	movq	8(%rax), %rax	# _1->args, _35
# a.out.c:747:     return MUSTTAIL reconcile(argnum, a,
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_35 + 16B], MEM[(struct kha_obj * *)_35 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_35 + 8B], MEM[(struct kha_obj * *)_35 + 8B]
	movq	(%rax), %rdi	# *_35, *_35
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_35 + 24B], MEM[(struct kha_obj * *)_35 + 24B]
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$4, %edi	#,
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:747:     return MUSTTAIL reconcile(argnum, a,
	movq	%rax, %rdx	# tmp1154, _40
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L186:
	.cfi_restore_state
# a.out.c:757:                                 a->data.pap->args[4]));
	movq	8(%rax), %rax	# _1->args, _41
# a.out.c:754:     return MUSTTAIL reconcile(argnum, a,
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_41 + 16B], MEM[(struct kha_obj * *)_41 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_41 + 8B], MEM[(struct kha_obj * *)_41 + 8B]
	movq	(%rax), %rdi	# *_41, *_41
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_41 + 24B], MEM[(struct kha_obj * *)_41 + 24B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_41 + 32B],
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$5, %edi	#,
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:754:     return MUSTTAIL reconcile(argnum, a,
	movq	%rax, %rdx	# tmp1155, _47
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L185:
	.cfi_restore_state
# a.out.c:766:                                 a->data.pap->args[4], a->data.pap->args[5]));
	movq	8(%rax), %rax	# _1->args, _48
# a.out.c:763:     return MUSTTAIL reconcile(argnum, a,
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_48 + 16B], MEM[(struct kha_obj * *)_48 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_48 + 8B], MEM[(struct kha_obj * *)_48 + 8B]
	movq	(%rax), %rdi	# *_48, *_48
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_48 + 24B], MEM[(struct kha_obj * *)_48 + 24B]
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_48 + 40B],
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_48 + 32B],
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$6, %edi	#,
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:763:     return MUSTTAIL reconcile(argnum, a,
	movq	%rax, %rdx	# tmp1156, _55
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L184:
	.cfi_restore_state
# a.out.c:776:                                 a->data.pap->args[6]));
	movq	8(%rax), %rax	# _1->args, _56
# a.out.c:772:     return MUSTTAIL reconcile(argnum, a,
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 168
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_56 + 16B], MEM[(struct kha_obj * *)_56 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_56 + 8B], MEM[(struct kha_obj * *)_56 + 8B]
	movq	(%rax), %rdi	# *_56, *_56
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_56 + 40B], MEM[(struct kha_obj * *)_56 + 40B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_56 + 32B], MEM[(struct kha_obj * *)_56 + 32B]
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_56 + 24B], MEM[(struct kha_obj * *)_56 + 24B]
	pushq	48(%rax)	# MEM[(struct kha_obj * *)_56 + 48B]
	.cfi_def_cfa_offset 176
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$7, %edi	#,
	movq	%rax, %rdx	# tmp1157, _64
# a.out.c:875: }
	addq	$120, %rsp	#,
	.cfi_def_cfa_offset 56
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L183:
	.cfi_def_cfa_offset 160
# a.out.c:786:                                 a->data.pap->args[6], a->data.pap->args[7]));
	movq	8(%rax), %rax	# _1->args, _65
# a.out.c:782:     return MUSTTAIL reconcile(argnum, a,
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_65 + 16B], MEM[(struct kha_obj * *)_65 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_65 + 8B], MEM[(struct kha_obj * *)_65 + 8B]
	movq	(%rax), %rdi	# *_65, *_65
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_65 + 40B], MEM[(struct kha_obj * *)_65 + 40B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_65 + 32B], MEM[(struct kha_obj * *)_65 + 32B]
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_65 + 24B], MEM[(struct kha_obj * *)_65 + 24B]
	pushq	56(%rax)	# MEM[(struct kha_obj * *)_65 + 56B]
	.cfi_def_cfa_offset 168
	pushq	48(%rax)	# MEM[(struct kha_obj * *)_65 + 48B]
	.cfi_def_cfa_offset 176
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$8, %edi	#,
	movq	%rax, %rdx	# tmp1158, _74
# a.out.c:875: }
	addq	$120, %rsp	#,
	.cfi_def_cfa_offset 56
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L182:
	.cfi_def_cfa_offset 160
# a.out.c:796:           a->data.pap->args[6], a->data.pap->args[7], a->data.pap->args[8]));
	movq	8(%rax), %rax	# _1->args, _75
# a.out.c:792:     return MUSTTAIL reconcile(
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 168
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_75 + 16B], MEM[(struct kha_obj * *)_75 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_75 + 8B], MEM[(struct kha_obj * *)_75 + 8B]
	movq	(%rax), %rdi	# *_75, *_75
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_75 + 40B], MEM[(struct kha_obj * *)_75 + 40B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_75 + 32B], MEM[(struct kha_obj * *)_75 + 32B]
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_75 + 24B], MEM[(struct kha_obj * *)_75 + 24B]
	pushq	64(%rax)	# MEM[(struct kha_obj * *)_75 + 64B]
	.cfi_def_cfa_offset 176
	pushq	56(%rax)	# MEM[(struct kha_obj * *)_75 + 56B]
	.cfi_def_cfa_offset 184
	pushq	48(%rax)	# MEM[(struct kha_obj * *)_75 + 48B]
	.cfi_def_cfa_offset 192
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$9, %edi	#,
	movq	%rax, %rdx	# tmp1159, _85
# a.out.c:875: }
	addq	$136, %rsp	#,
	.cfi_def_cfa_offset 56
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L181:
	.cfi_def_cfa_offset 160
# a.out.c:807:                                 a->data.pap->args[8], a->data.pap->args[9]));
	movq	8(%rax), %rax	# _1->args, _86
# a.out.c:802:     return MUSTTAIL reconcile(argnum, a,
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_86 + 16B], MEM[(struct kha_obj * *)_86 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_86 + 8B], MEM[(struct kha_obj * *)_86 + 8B]
	movq	(%rax), %rdi	# *_86, *_86
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_86 + 40B], MEM[(struct kha_obj * *)_86 + 40B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_86 + 32B], MEM[(struct kha_obj * *)_86 + 32B]
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_86 + 24B], MEM[(struct kha_obj * *)_86 + 24B]
	pushq	72(%rax)	# MEM[(struct kha_obj * *)_86 + 72B]
	.cfi_def_cfa_offset 168
	pushq	64(%rax)	# MEM[(struct kha_obj * *)_86 + 64B]
	.cfi_def_cfa_offset 176
	pushq	56(%rax)	# MEM[(struct kha_obj * *)_86 + 56B]
	.cfi_def_cfa_offset 184
	pushq	48(%rax)	# MEM[(struct kha_obj * *)_86 + 48B]
	.cfi_def_cfa_offset 192
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$10, %edi	#,
	movq	%rax, %rdx	# tmp1160, _97
# a.out.c:875: }
	addq	$136, %rsp	#,
	.cfi_def_cfa_offset 56
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L180:
	.cfi_def_cfa_offset 160
# a.out.c:819:           a->data.pap->args[9], a->data.pap->args[10]));
	movq	8(%rax), %rax	# _1->args, _98
# a.out.c:814:     return MUSTTAIL reconcile(
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 168
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_98 + 16B], MEM[(struct kha_obj * *)_98 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_98 + 8B], MEM[(struct kha_obj * *)_98 + 8B]
	movq	(%rax), %rdi	# *_98, *_98
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_98 + 40B], MEM[(struct kha_obj * *)_98 + 40B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_98 + 32B], MEM[(struct kha_obj * *)_98 + 32B]
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_98 + 24B], MEM[(struct kha_obj * *)_98 + 24B]
	pushq	80(%rax)	# MEM[(struct kha_obj * *)_98 + 80B]
	.cfi_def_cfa_offset 176
	pushq	72(%rax)	# MEM[(struct kha_obj * *)_98 + 72B]
	.cfi_def_cfa_offset 184
	pushq	64(%rax)	# MEM[(struct kha_obj * *)_98 + 64B]
	.cfi_def_cfa_offset 192
	pushq	56(%rax)	# MEM[(struct kha_obj * *)_98 + 56B]
	.cfi_def_cfa_offset 200
	pushq	48(%rax)	# MEM[(struct kha_obj * *)_98 + 48B]
	.cfi_def_cfa_offset 208
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$11, %edi	#,
	movq	%rax, %rdx	# tmp1161, _110
# a.out.c:875: }
	addq	$152, %rsp	#,
	.cfi_def_cfa_offset 56
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L179:
	.cfi_def_cfa_offset 160
# a.out.c:831:           a->data.pap->args[9], a->data.pap->args[10], a->data.pap->args[11]));
	movq	8(%rax), %rax	# _1->args, _111
# a.out.c:826:     return MUSTTAIL reconcile(
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_111 + 16B], MEM[(struct kha_obj * *)_111 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_111 + 8B], MEM[(struct kha_obj * *)_111 + 8B]
	movq	(%rax), %rdi	# *_111, *_111
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_111 + 40B], MEM[(struct kha_obj * *)_111 + 40B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_111 + 32B], MEM[(struct kha_obj * *)_111 + 32B]
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_111 + 24B], MEM[(struct kha_obj * *)_111 + 24B]
	pushq	88(%rax)	# MEM[(struct kha_obj * *)_111 + 88B]
	.cfi_def_cfa_offset 168
	pushq	80(%rax)	# MEM[(struct kha_obj * *)_111 + 80B]
	.cfi_def_cfa_offset 176
	pushq	72(%rax)	# MEM[(struct kha_obj * *)_111 + 72B]
	.cfi_def_cfa_offset 184
	pushq	64(%rax)	# MEM[(struct kha_obj * *)_111 + 64B]
	.cfi_def_cfa_offset 192
	pushq	56(%rax)	# MEM[(struct kha_obj * *)_111 + 56B]
	.cfi_def_cfa_offset 200
	pushq	48(%rax)	# MEM[(struct kha_obj * *)_111 + 48B]
	.cfi_def_cfa_offset 208
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$12, %edi	#,
	movq	%rax, %rdx	# tmp1162, _124
# a.out.c:875: }
	addq	$152, %rsp	#,
	.cfi_def_cfa_offset 56
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L178:
	.cfi_def_cfa_offset 160
# a.out.c:844:           a->data.pap->args[12]));
	movq	8(%rax), %rax	# _1->args, _125
# a.out.c:838:     return MUSTTAIL reconcile(
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 168
	movq	16(%rax), %rdx	# MEM[(struct kha_obj * *)_125 + 16B], MEM[(struct kha_obj * *)_125 + 16B]
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_125 + 8B], MEM[(struct kha_obj * *)_125 + 8B]
	movq	(%rax), %rdi	# *_125, *_125
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_125 + 40B], MEM[(struct kha_obj * *)_125 + 40B]
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_125 + 32B], MEM[(struct kha_obj * *)_125 + 32B]
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_125 + 24B], MEM[(struct kha_obj * *)_125 + 24B]
	pushq	96(%rax)	# MEM[(struct kha_obj * *)_125 + 96B]
	.cfi_def_cfa_offset 176
	pushq	88(%rax)	# MEM[(struct kha_obj * *)_125 + 88B]
	.cfi_def_cfa_offset 184
	pushq	80(%rax)	# MEM[(struct kha_obj * *)_125 + 80B]
	.cfi_def_cfa_offset 192
	pushq	72(%rax)	# MEM[(struct kha_obj * *)_125 + 72B]
	.cfi_def_cfa_offset 200
	pushq	64(%rax)	# MEM[(struct kha_obj * *)_125 + 64B]
	.cfi_def_cfa_offset 208
	pushq	56(%rax)	# MEM[(struct kha_obj * *)_125 + 56B]
	.cfi_def_cfa_offset 216
	pushq	48(%rax)	# MEM[(struct kha_obj * *)_125 + 48B]
	.cfi_def_cfa_offset 224
	call	*%rbp	# _2
	movq	%rbx, %rsi	# a,
	movl	$13, %edi	#,
	movq	%rax, %rdx	# tmp1163, _139
# a.out.c:875: }
	addq	$168, %rsp	#,
	.cfi_def_cfa_offset 56
	jmp	.L196	#
	.p2align 4,,10
	.p2align 3
.L144:
	.cfi_def_cfa_offset 160
# a.out.c:676:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _20
# a.out.c:678:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %rcx	# MEM[(struct kha_obj * *)_20 + 16B], tmp_2
# a.out.c:676:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %rsi	# *_20, tmp_0
# a.out.c:687:       tmp_11 = (a->data.pap->args[11]);
	movq	88(%rax), %rdi	# MEM[(struct kha_obj * *)_20 + 88B], tmp_11
# a.out.c:680:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_20 + 32B], tmp_4
# a.out.c:681:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_20 + 40B], tmp_5
# a.out.c:682:       tmp_6 = (a->data.pap->args[6]);
	movq	48(%rax), %r13	# MEM[(struct kha_obj * *)_20 + 48B], tmp_6
# a.out.c:678:       tmp_2 = (a->data.pap->args[2]);
	movq	%rcx, 16(%rsp)	# tmp_2, %sfp
# a.out.c:679:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_20 + 24B], tmp_3
# a.out.c:683:       tmp_7 = (a->data.pap->args[7]);
	movq	56(%rax), %r14	# MEM[(struct kha_obj * *)_20 + 56B], tmp_7
# a.out.c:676:       tmp_0 = (a->data.pap->args[0]);
	movq	%rsi, 8(%rsp)	# tmp_0, %sfp
# a.out.c:684:       tmp_8 = (a->data.pap->args[8]);
	movq	64(%rax), %r15	# MEM[(struct kha_obj * *)_20 + 64B], tmp_8
# a.out.c:677:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_20 + 8B], tmp_1
# a.out.c:687:       tmp_11 = (a->data.pap->args[11]);
	movq	%rdi, 32(%rsp)	# tmp_11, %sfp
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdi	#, tmp980
# a.out.c:685:       tmp_9 = (a->data.pap->args[9]);
	movq	72(%rax), %r12	# MEM[(struct kha_obj * *)_20 + 72B], tmp_9
# a.out.c:688:       tmp_12 = (a->data.pap->args[12]);
	movq	96(%rax), %r10	# MEM[(struct kha_obj * *)_20 + 96B], tmp_12
# a.out.c:679:       tmp_3 = (a->data.pap->args[3]);
	movq	%rcx, 24(%rsp)	# tmp_3, %sfp
# a.out.c:689:       tmp_13 = (a->data.pap->args[13]);
	movq	104(%rax), %r11	# MEM[(struct kha_obj * *)_20 + 104B], tmp_13
# a.out.c:686:       tmp_10 = (a->data.pap->args[10]);
	movq	80(%rax), %rcx	# MEM[(struct kha_obj * *)_20 + 80B], tmp_10
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *a_177(D), tmp978
	shrq	$8, %rax	#, tmp978
# a.out.c:208:   a->gc -= 1;
	addq	%rdi, %rax	# tmp980, _410
	andq	%rdi, %rax	# tmp980, _410
	movq	%rax, %rdi	# _410, tmp991
	movb	%al, 1(%rbx)	# _410,
	shrq	$16, %rdi	#, tmp991
	movb	%ah, 2(%rbx)	# _410,
	movb	%dil, 3(%rbx)	# tmp991,
	movq	%rax, %rdi	# _410, tmp996
	shrq	$24, %rdi	#, tmp996
	movb	%dil, 4(%rbx)	# tmp996,
	movq	%rax, %rdi	# _410, tmp1001
	shrq	$32, %rdi	#, tmp1001
	movb	%dil, 5(%rbx)	# tmp1001,
	movq	%rax, %rdi	# _410, tmp1006
	shrq	$40, %rdi	#, tmp1006
	movb	%dil, 6(%rbx)	# tmp1006,
	movq	%rax, %rdi	# _410, tmp1012
	shrq	$48, %rdi	#, tmp1012
	movb	%dil, 7(%rbx)	# tmp1012,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _410
	je	.L198	#,
.L173:
# a.out.c:691:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7,
	pushq	%r11	# tmp_13
	.cfi_def_cfa_offset 168
	pushq	%r10	# tmp_12
	.cfi_def_cfa_offset 176
	pushq	48(%rsp)	# %sfp
	.cfi_def_cfa_offset 184
	pushq	%rcx	# tmp_10
	.cfi_def_cfa_offset 192
	pushq	%r12	# tmp_9
	.cfi_def_cfa_offset 200
	pushq	%r15	# tmp_8
	.cfi_def_cfa_offset 208
	pushq	%r14	# tmp_7
	.cfi_def_cfa_offset 216
	pushq	%r13	# tmp_6
	.cfi_def_cfa_offset 224
	movq	88(%rsp), %rcx	# %sfp,
	movq	80(%rsp), %rdx	# %sfp,
	movq	72(%rsp), %rdi	# %sfp,
	call	*%rbp	# _2
	addq	$64, %rsp	#,
	.cfi_def_cfa_offset 160
	jmp	.L138	#
	.p2align 4,,10
	.p2align 3
.L142:
# a.out.c:701:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _21
# a.out.c:711:       tmp_10 = (a->data.pap->args[10]);
	movq	80(%rax), %rdi	# MEM[(struct kha_obj * *)_21 + 80B], tmp_10
# a.out.c:701:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %rsi	# *_21, tmp_0
# a.out.c:703:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %rcx	# MEM[(struct kha_obj * *)_21 + 16B], tmp_2
# a.out.c:705:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_21 + 32B], tmp_4
# a.out.c:706:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_21 + 40B], tmp_5
# a.out.c:707:       tmp_6 = (a->data.pap->args[6]);
	movq	48(%rax), %r12	# MEM[(struct kha_obj * *)_21 + 48B], tmp_6
# a.out.c:711:       tmp_10 = (a->data.pap->args[10]);
	movq	%rdi, 24(%rsp)	# tmp_10, %sfp
# a.out.c:712:       tmp_11 = (a->data.pap->args[11]);
	movq	88(%rax), %rdi	# MEM[(struct kha_obj * *)_21 + 88B], tmp_11
# a.out.c:708:       tmp_7 = (a->data.pap->args[7]);
	movq	56(%rax), %r13	# MEM[(struct kha_obj * *)_21 + 56B], tmp_7
# a.out.c:701:       tmp_0 = (a->data.pap->args[0]);
	movq	%rsi, 8(%rsp)	# tmp_0, %sfp
# a.out.c:709:       tmp_8 = (a->data.pap->args[8]);
	movq	64(%rax), %r14	# MEM[(struct kha_obj * *)_21 + 64B], tmp_8
# a.out.c:702:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_21 + 8B], tmp_1
# a.out.c:703:       tmp_2 = (a->data.pap->args[2]);
	movq	%rcx, 16(%rsp)	# tmp_2, %sfp
# a.out.c:710:       tmp_9 = (a->data.pap->args[9]);
	movq	72(%rax), %r15	# MEM[(struct kha_obj * *)_21 + 72B], tmp_9
# a.out.c:704:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_21 + 24B], tmp_3
# a.out.c:712:       tmp_11 = (a->data.pap->args[11]);
	movq	%rdi, 32(%rsp)	# tmp_11, %sfp
# a.out.c:714:       tmp_13 = (a->data.pap->args[13]);
	movq	104(%rax), %r10	# MEM[(struct kha_obj * *)_21 + 104B], tmp_13
# a.out.c:713:       tmp_12 = (a->data.pap->args[12]);
	movq	96(%rax), %rdi	# MEM[(struct kha_obj * *)_21 + 96B], tmp_12
# a.out.c:715:       tmp_14 = (a->data.pap->args[14]);
	movq	112(%rax), %r11	# MEM[(struct kha_obj * *)_21 + 112B], tmp_14
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *a_177(D), tmp1018
# a.out.c:713:       tmp_12 = (a->data.pap->args[12]);
	movq	%rdi, 40(%rsp)	# tmp_12, %sfp
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdi	#, tmp1020
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rax	#, tmp1018
# a.out.c:208:   a->gc -= 1;
	addq	%rdi, %rax	# tmp1020, _412
	andq	%rdi, %rax	# tmp1020, _412
	movq	%rax, %rdi	# _412, tmp1031
	movb	%al, 1(%rbx)	# _412,
	shrq	$16, %rdi	#, tmp1031
	movb	%ah, 2(%rbx)	# _412,
	movb	%dil, 3(%rbx)	# tmp1031,
	movq	%rax, %rdi	# _412, tmp1036
	shrq	$24, %rdi	#, tmp1036
	movb	%dil, 4(%rbx)	# tmp1036,
	movq	%rax, %rdi	# _412, tmp1041
	shrq	$32, %rdi	#, tmp1041
	movb	%dil, 5(%rbx)	# tmp1041,
	movq	%rax, %rdi	# _412, tmp1046
	shrq	$40, %rdi	#, tmp1046
	movb	%dil, 6(%rbx)	# tmp1046,
	movq	%rax, %rdi	# _412, tmp1052
	shrq	$48, %rdi	#, tmp1052
	movb	%dil, 7(%rbx)	# tmp1052,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _412
	je	.L199	#,
.L174:
# a.out.c:717:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7,
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 168
	pushq	%r11	# tmp_14
	.cfi_def_cfa_offset 176
	pushq	%r10	# tmp_13
	.cfi_def_cfa_offset 184
	pushq	64(%rsp)	# %sfp
	.cfi_def_cfa_offset 192
	pushq	64(%rsp)	# %sfp
	.cfi_def_cfa_offset 200
	pushq	64(%rsp)	# %sfp
	.cfi_def_cfa_offset 208
	pushq	%r15	# tmp_9
	.cfi_def_cfa_offset 216
	pushq	%r14	# tmp_8
	.cfi_def_cfa_offset 224
	pushq	%r13	# tmp_7
	.cfi_def_cfa_offset 232
	pushq	%r12	# tmp_6
	.cfi_def_cfa_offset 240
	movq	96(%rsp), %rdx	# %sfp,
	movq	88(%rsp), %rdi	# %sfp,
	call	*%rbp	# _2
	addq	$80, %rsp	#,
	.cfi_def_cfa_offset 160
	jmp	.L138	#
	.p2align 4,,10
	.p2align 3
.L152:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp660
# a.out.c:521:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _12
# a.out.c:521:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_12, tmp_0
# a.out.c:522:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_12 + 8B], tmp_1
# a.out.c:523:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %r14	# MEM[(struct kha_obj * *)_12 + 16B], tmp_2
# a.out.c:524:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %r15	# MEM[(struct kha_obj * *)_12 + 24B], tmp_3
# a.out.c:525:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_12 + 32B], tmp_4
# a.out.c:526:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_12 + 40B], tmp_5
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp658
	shrq	$8, %rax	#, tmp658
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp660, _394
	andq	%rdx, %rax	# tmp660, _394
	movq	%rax, %rdx	# _394, tmp671
	movb	%al, 1(%rdi)	# _394,
	shrq	$16, %rdx	#, tmp671
	movb	%ah, 2(%rdi)	# _394,
	movb	%dl, 3(%rdi)	# tmp671,
	movq	%rax, %rdx	# _394, tmp676
	shrq	$24, %rdx	#, tmp676
	movb	%dl, 4(%rdi)	# tmp676,
	movq	%rax, %rdx	# _394, tmp681
	shrq	$32, %rdx	#, tmp681
	movb	%dl, 5(%rdi)	# tmp681,
	movq	%rax, %rdx	# _394, tmp686
	shrq	$40, %rdx	#, tmp686
	movb	%dl, 6(%rdi)	# tmp686,
	movq	%rax, %rdx	# _394, tmp692
	shrq	$48, %rdx	#, tmp692
	movb	%dl, 7(%rdi)	# tmp692,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _394
	je	.L200	#,
.L165:
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:528:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5);
	movq	%r15, %rcx	# tmp_3,
	movq	%r14, %rdx	# tmp_2,
	movq	%r13, %rsi	# tmp_1,
# a.out.c:875: }
	popq	%rbx	#
	.cfi_def_cfa_offset 48
# a.out.c:528:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5);
	movq	%r12, %rdi	# tmp_0,
	movq	%rbp, %rax	# _2, _2
# a.out.c:875: }
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
# a.out.c:528:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5);
	jmp	*%rax	# _2
	.p2align 4,,10
	.p2align 3
.L156:
	.cfi_restore_state
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp500
# a.out.c:478:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _8
# a.out.c:478:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_8, tmp_0
# a.out.c:479:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_8 + 8B], tmp_1
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp498
	shrq	$8, %rax	#, tmp498
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp500, _386
	andq	%rdx, %rax	# tmp500, _386
	movq	%rax, %rdx	# _386, tmp511
	movb	%al, 1(%rdi)	# _386,
	shrq	$16, %rdx	#, tmp511
	movb	%ah, 2(%rdi)	# _386,
	movb	%dl, 3(%rdi)	# tmp511,
	movq	%rax, %rdx	# _386, tmp516
	shrq	$24, %rdx	#, tmp516
	movb	%dl, 4(%rdi)	# tmp516,
	movq	%rax, %rdx	# _386, tmp521
	shrq	$32, %rdx	#, tmp521
	movb	%dl, 5(%rdi)	# tmp521,
	movq	%rax, %rdx	# _386, tmp526
	shrq	$40, %rdx	#, tmp526
	movb	%dl, 6(%rdi)	# tmp526,
	movq	%rax, %rdx	# _386, tmp532
	shrq	$48, %rdx	#, tmp532
	movb	%dl, 7(%rdi)	# tmp532,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _386
	je	.L201	#,
.L161:
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:481:       return MUSTTAIL f(tmp_0, tmp_1);
	movq	%r13, %rsi	# tmp_1,
	movq	%r12, %rdi	# tmp_0,
	movq	%rbp, %rax	# _2, _2
# a.out.c:875: }
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
# a.out.c:481:       return MUSTTAIL f(tmp_0, tmp_1);
	jmp	*%rax	# _2
	.p2align 4,,10
	.p2align 3
.L148:
	.cfi_restore_state
# a.out.c:586:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _16
# a.out.c:586:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_16, tmp_0
# a.out.c:587:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_16 + 8B], tmp_1
# a.out.c:588:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %r14	# MEM[(struct kha_obj * *)_16 + 16B], tmp_2
# a.out.c:589:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %r15	# MEM[(struct kha_obj * *)_16 + 24B], tmp_3
# a.out.c:590:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_16 + 32B], tmp_4
# a.out.c:591:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_16 + 40B], tmp_5
# a.out.c:592:       tmp_6 = (a->data.pap->args[6]);
	movq	48(%rax), %r11	# MEM[(struct kha_obj * *)_16 + 48B], tmp_6
# a.out.c:593:       tmp_7 = (a->data.pap->args[7]);
	movq	56(%rax), %rcx	# MEM[(struct kha_obj * *)_16 + 56B], tmp_7
# a.out.c:594:       tmp_8 = (a->data.pap->args[8]);
	movq	64(%rax), %rsi	# MEM[(struct kha_obj * *)_16 + 64B], tmp_8
# a.out.c:595:       tmp_9 = (a->data.pap->args[9]);
	movq	72(%rax), %r10	# MEM[(struct kha_obj * *)_16 + 72B], tmp_9
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp818
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdi	#, tmp820
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rax	#, tmp818
# a.out.c:208:   a->gc -= 1;
	addq	%rdi, %rax	# tmp820, _402
	andq	%rdi, %rax	# tmp820, _402
	movq	%rax, %rdi	# _402, tmp831
	movb	%al, 1(%rbx)	# _402,
	shrq	$16, %rdi	#, tmp831
	movb	%ah, 2(%rbx)	# _402,
	movb	%dil, 3(%rbx)	# tmp831,
	movq	%rax, %rdi	# _402, tmp836
	shrq	$24, %rdi	#, tmp836
	movb	%dil, 4(%rbx)	# tmp836,
	movq	%rax, %rdi	# _402, tmp841
	shrq	$32, %rdi	#, tmp841
	movb	%dil, 5(%rbx)	# tmp841,
	movq	%rax, %rdi	# _402, tmp846
	shrq	$40, %rdi	#, tmp846
	movb	%dil, 6(%rbx)	# tmp846,
	movq	%rax, %rdi	# _402, tmp852
	shrq	$48, %rdi	#, tmp852
	movb	%dil, 7(%rbx)	# tmp852,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _402
	je	.L202	#,
.L169:
# a.out.c:597:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7,
	pushq	%r10	# tmp_9
	.cfi_def_cfa_offset 168
	pushq	%rsi	# tmp_8
	.cfi_def_cfa_offset 176
	pushq	%rcx	# tmp_7
	.cfi_def_cfa_offset 184
	pushq	%r11	# tmp_6
	.cfi_def_cfa_offset 192
.L195:
	movq	%r15, %rcx	# tmp_3,
	movq	%r14, %rdx	# tmp_2,
	movq	%r13, %rsi	# tmp_1,
	movq	%r12, %rdi	# tmp_0,
	call	*%rbp	# _2
	addq	$32, %rsp	#,
	.cfi_def_cfa_offset 160
	jmp	.L138	#
	.p2align 4,,10
	.p2align 3
.L158:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp419
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp417
	shrq	$8, %rax	#, tmp417
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp419, _382
	andq	%rdx, %rax	# tmp419, _382
	movq	%rax, %rdx	# _382, tmp430
	movb	%al, 1(%rdi)	# _382,
	shrq	$16, %rdx	#, tmp430
	movb	%ah, 2(%rdi)	# _382,
	movb	%dl, 3(%rdi)	# tmp430,
	movq	%rax, %rdx	# _382, tmp435
	shrq	$24, %rdx	#, tmp435
	movb	%dl, 4(%rdi)	# tmp435,
	movq	%rax, %rdx	# _382, tmp440
	shrq	$32, %rdx	#, tmp440
	movb	%dl, 5(%rdi)	# tmp440,
	movq	%rax, %rdx	# _382, tmp445
	shrq	$40, %rdx	#, tmp445
	movb	%dl, 6(%rdi)	# tmp445,
	movq	%rax, %rdx	# _382, tmp451
	shrq	$48, %rdx	#, tmp451
	movb	%dl, 7(%rdi)	# tmp451,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _382
	je	.L203	#,
.L159:
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:464:       return MUSTTAIL f();
	movq	%rbp, %rsi	# _2, _2
	xorl	%eax, %eax	#
# a.out.c:875: }
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
# a.out.c:464:       return MUSTTAIL f();
	jmp	*%rsi	# _2
	.p2align 4,,10
	.p2align 3
.L150:
	.cfi_restore_state
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp740
# a.out.c:550:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _14
# a.out.c:550:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_14, tmp_0
# a.out.c:551:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_14 + 8B], tmp_1
# a.out.c:552:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %r14	# MEM[(struct kha_obj * *)_14 + 16B], tmp_2
# a.out.c:553:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %r15	# MEM[(struct kha_obj * *)_14 + 24B], tmp_3
# a.out.c:554:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_14 + 32B], tmp_4
# a.out.c:555:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_14 + 40B], tmp_5
# a.out.c:556:       tmp_6 = (a->data.pap->args[6]);
	movq	48(%rax), %rcx	# MEM[(struct kha_obj * *)_14 + 48B], tmp_6
# a.out.c:557:       tmp_7 = (a->data.pap->args[7]);
	movq	56(%rax), %rsi	# MEM[(struct kha_obj * *)_14 + 56B], tmp_7
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp738
	shrq	$8, %rax	#, tmp738
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp740, _398
	andq	%rdx, %rax	# tmp740, _398
	movq	%rax, %rdx	# _398, tmp751
	movb	%al, 1(%rdi)	# _398,
	shrq	$16, %rdx	#, tmp751
	movb	%ah, 2(%rdi)	# _398,
	movb	%dl, 3(%rdi)	# tmp751,
	movq	%rax, %rdx	# _398, tmp756
	shrq	$24, %rdx	#, tmp756
	movb	%dl, 4(%rdi)	# tmp756,
	movq	%rax, %rdx	# _398, tmp761
	shrq	$32, %rdx	#, tmp761
	movb	%dl, 5(%rdi)	# tmp761,
	movq	%rax, %rdx	# _398, tmp766
	shrq	$40, %rdx	#, tmp766
	movb	%dl, 6(%rdi)	# tmp766,
	movq	%rax, %rdx	# _398, tmp772
	shrq	$48, %rdx	#, tmp772
	movb	%dl, 7(%rdi)	# tmp772,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _398
	je	.L204	#,
# a.out.c:559:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7);
	pushq	%rsi	# tmp_7
	.cfi_remember_state
	.cfi_def_cfa_offset 168
	jmp	.L194	#
	.p2align 4,,10
	.p2align 3
.L154:
	.cfi_restore_state
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp580
# a.out.c:497:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _10
# a.out.c:497:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_10, tmp_0
# a.out.c:498:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_10 + 8B], tmp_1
# a.out.c:499:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %r14	# MEM[(struct kha_obj * *)_10 + 16B], tmp_2
# a.out.c:500:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %r15	# MEM[(struct kha_obj * *)_10 + 24B], tmp_3
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp578
	shrq	$8, %rax	#, tmp578
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp580, _390
	andq	%rdx, %rax	# tmp580, _390
	movq	%rax, %rdx	# _390, tmp591
	movb	%al, 1(%rdi)	# _390,
	shrq	$16, %rdx	#, tmp591
	movb	%ah, 2(%rdi)	# _390,
	movb	%dl, 3(%rdi)	# tmp591,
	movq	%rax, %rdx	# _390, tmp596
	shrq	$24, %rdx	#, tmp596
	movb	%dl, 4(%rdi)	# tmp596,
	movq	%rax, %rdx	# _390, tmp601
	shrq	$32, %rdx	#, tmp601
	movb	%dl, 5(%rdi)	# tmp601,
	movq	%rax, %rdx	# _390, tmp606
	shrq	$40, %rdx	#, tmp606
	movb	%dl, 6(%rdi)	# tmp606,
	movq	%rax, %rdx	# _390, tmp612
	shrq	$48, %rdx	#, tmp612
	movb	%dl, 7(%rdi)	# tmp612,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _390
	je	.L205	#,
.L163:
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:502:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3);
	movq	%r15, %rcx	# tmp_3,
	movq	%r14, %rdx	# tmp_2,
	movq	%r13, %rsi	# tmp_1,
# a.out.c:875: }
	popq	%rbx	#
	.cfi_def_cfa_offset 48
# a.out.c:502:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3);
	movq	%r12, %rdi	# tmp_0,
	movq	%rbp, %rax	# _2, _2
# a.out.c:875: }
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
# a.out.c:502:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3);
	jmp	*%rax	# _2
	.p2align 4,,10
	.p2align 3
.L153:
	.cfi_restore_state
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp620
# a.out.c:508:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _11
# a.out.c:508:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_11, tmp_0
# a.out.c:509:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_11 + 8B], tmp_1
# a.out.c:510:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %r14	# MEM[(struct kha_obj * *)_11 + 16B], tmp_2
# a.out.c:511:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %r15	# MEM[(struct kha_obj * *)_11 + 24B], tmp_3
# a.out.c:512:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_11 + 32B], tmp_4
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp618
	shrq	$8, %rax	#, tmp618
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp620, _392
	andq	%rdx, %rax	# tmp620, _392
	movq	%rax, %rdx	# _392, tmp631
	movb	%al, 1(%rdi)	# _392,
	shrq	$16, %rdx	#, tmp631
	movb	%ah, 2(%rdi)	# _392,
	movb	%dl, 3(%rdi)	# tmp631,
	movq	%rax, %rdx	# _392, tmp636
	shrq	$24, %rdx	#, tmp636
	movb	%dl, 4(%rdi)	# tmp636,
	movq	%rax, %rdx	# _392, tmp641
	shrq	$32, %rdx	#, tmp641
	movb	%dl, 5(%rdi)	# tmp641,
	movq	%rax, %rdx	# _392, tmp646
	shrq	$40, %rdx	#, tmp646
	movb	%dl, 6(%rdi)	# tmp646,
	movq	%rax, %rdx	# _392, tmp652
	shrq	$48, %rdx	#, tmp652
	movb	%dl, 7(%rdi)	# tmp652,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _392
	je	.L206	#,
.L164:
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:514:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4);
	movq	%r15, %rcx	# tmp_3,
	movq	%r14, %rdx	# tmp_2,
	movq	%r13, %rsi	# tmp_1,
# a.out.c:875: }
	popq	%rbx	#
	.cfi_def_cfa_offset 48
# a.out.c:514:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4);
	movq	%r12, %rdi	# tmp_0,
	movq	%rbp, %rax	# _2, _2
# a.out.c:875: }
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
# a.out.c:514:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4);
	jmp	*%rax	# _2
	.p2align 4,,10
	.p2align 3
.L146:
	.cfi_restore_state
# a.out.c:629:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _18
# a.out.c:629:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %rsi	# *_18, tmp_0
# a.out.c:631:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %rcx	# MEM[(struct kha_obj * *)_18 + 16B], tmp_2
# a.out.c:633:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_18 + 32B], tmp_4
# a.out.c:634:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_18 + 40B], tmp_5
# a.out.c:635:       tmp_6 = (a->data.pap->args[6]);
	movq	48(%rax), %r12	# MEM[(struct kha_obj * *)_18 + 48B], tmp_6
# a.out.c:636:       tmp_7 = (a->data.pap->args[7]);
	movq	56(%rax), %r13	# MEM[(struct kha_obj * *)_18 + 56B], tmp_7
# a.out.c:629:       tmp_0 = (a->data.pap->args[0]);
	movq	%rsi, 8(%rsp)	# tmp_0, %sfp
# a.out.c:637:       tmp_8 = (a->data.pap->args[8]);
	movq	64(%rax), %r14	# MEM[(struct kha_obj * *)_18 + 64B], tmp_8
# a.out.c:630:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_18 + 8B], tmp_1
# a.out.c:631:       tmp_2 = (a->data.pap->args[2]);
	movq	%rcx, 16(%rsp)	# tmp_2, %sfp
# a.out.c:638:       tmp_9 = (a->data.pap->args[9]);
	movq	72(%rax), %r15	# MEM[(struct kha_obj * *)_18 + 72B], tmp_9
# a.out.c:632:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %rcx	# MEM[(struct kha_obj * *)_18 + 24B], tmp_3
# a.out.c:639:       tmp_10 = (a->data.pap->args[10]);
	movq	80(%rax), %r10	# MEM[(struct kha_obj * *)_18 + 80B], tmp_10
# a.out.c:640:       tmp_11 = (a->data.pap->args[11]);
	movq	88(%rax), %r11	# MEM[(struct kha_obj * *)_18 + 88B], tmp_11
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp898
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdi	#, tmp900
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rax	#, tmp898
# a.out.c:208:   a->gc -= 1;
	addq	%rdi, %rax	# tmp900, _406
	andq	%rdi, %rax	# tmp900, _406
	movq	%rax, %rdi	# _406, tmp911
	movb	%al, 1(%rbx)	# _406,
	shrq	$16, %rdi	#, tmp911
	movb	%ah, 2(%rbx)	# _406,
	movb	%dil, 3(%rbx)	# tmp911,
	movq	%rax, %rdi	# _406, tmp916
	shrq	$24, %rdi	#, tmp916
	movb	%dil, 4(%rbx)	# tmp916,
	movq	%rax, %rdi	# _406, tmp921
	shrq	$32, %rdi	#, tmp921
	movb	%dil, 5(%rbx)	# tmp921,
	movq	%rax, %rdi	# _406, tmp926
	shrq	$40, %rdi	#, tmp926
	movb	%dil, 6(%rbx)	# tmp926,
	movq	%rax, %rdi	# _406, tmp932
	shrq	$48, %rdi	#, tmp932
	movb	%dil, 7(%rbx)	# tmp932,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _406
	je	.L207	#,
.L171:
# a.out.c:642:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7,
	pushq	%r11	# tmp_11
	.cfi_def_cfa_offset 168
	pushq	%r10	# tmp_10
	.cfi_def_cfa_offset 176
	pushq	%r15	# tmp_9
	.cfi_def_cfa_offset 184
	pushq	%r14	# tmp_8
	.cfi_def_cfa_offset 192
	pushq	%r13	# tmp_7
	.cfi_def_cfa_offset 200
	pushq	%r12	# tmp_6
	.cfi_def_cfa_offset 208
	movq	64(%rsp), %rdx	# %sfp,
	movq	56(%rsp), %rdi	# %sfp,
	call	*%rbp	# _2
	addq	$48, %rsp	#,
	.cfi_def_cfa_offset 160
	jmp	.L138	#
	.p2align 4,,10
	.p2align 3
.L157:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp460
# a.out.c:470:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _1->args
	movq	(%rax), %r12	# *_7, tmp_0
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp458
	shrq	$8, %rax	#, tmp458
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp460, _384
	andq	%rdx, %rax	# tmp460, _384
	movq	%rax, %rdx	# _384, tmp471
	movb	%al, 1(%rdi)	# _384,
	shrq	$16, %rdx	#, tmp471
	movb	%ah, 2(%rdi)	# _384,
	movb	%dl, 3(%rdi)	# tmp471,
	movq	%rax, %rdx	# _384, tmp476
	shrq	$24, %rdx	#, tmp476
	movb	%dl, 4(%rdi)	# tmp476,
	movq	%rax, %rdx	# _384, tmp481
	shrq	$32, %rdx	#, tmp481
	movb	%dl, 5(%rdi)	# tmp481,
	movq	%rax, %rdx	# _384, tmp486
	shrq	$40, %rdx	#, tmp486
	movb	%dl, 6(%rdi)	# tmp486,
	movq	%rax, %rdx	# _384, tmp492
	shrq	$48, %rdx	#, tmp492
	movb	%dl, 7(%rdi)	# tmp492,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _384
	je	.L208	#,
.L160:
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:472:       return MUSTTAIL f(tmp_0);
	movq	%r12, %rdi	# tmp_0,
	movq	%rbp, %rax	# _2, _2
# a.out.c:875: }
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
# a.out.c:472:       return MUSTTAIL f(tmp_0);
	jmp	*%rax	# _2
	.p2align 4,,10
	.p2align 3
.L151:
	.cfi_restore_state
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp700
# a.out.c:535:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _13
# a.out.c:535:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_13, tmp_0
# a.out.c:536:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_13 + 8B], tmp_1
# a.out.c:537:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %r14	# MEM[(struct kha_obj * *)_13 + 16B], tmp_2
# a.out.c:538:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %r15	# MEM[(struct kha_obj * *)_13 + 24B], tmp_3
# a.out.c:539:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_13 + 32B], tmp_4
# a.out.c:540:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_13 + 40B], tmp_5
# a.out.c:541:       tmp_6 = (a->data.pap->args[6]);
	movq	48(%rax), %rcx	# MEM[(struct kha_obj * *)_13 + 48B], tmp_6
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp698
	shrq	$8, %rax	#, tmp698
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp700, _396
	andq	%rdx, %rax	# tmp700, _396
	movq	%rax, %rdx	# _396, tmp711
	movb	%al, 1(%rdi)	# _396,
	shrq	$16, %rdx	#, tmp711
	movb	%ah, 2(%rdi)	# _396,
	movb	%dl, 3(%rdi)	# tmp711,
	movq	%rax, %rdx	# _396, tmp716
	shrq	$24, %rdx	#, tmp716
	movb	%dl, 4(%rdi)	# tmp716,
	movq	%rax, %rdx	# _396, tmp721
	shrq	$32, %rdx	#, tmp721
	movb	%dl, 5(%rdi)	# tmp721,
	movq	%rax, %rdx	# _396, tmp726
	shrq	$40, %rdx	#, tmp726
	movb	%dl, 6(%rdi)	# tmp726,
	movq	%rax, %rdx	# _396, tmp732
	shrq	$48, %rdx	#, tmp732
	movb	%dl, 7(%rdi)	# tmp732,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _396
	je	.L209	#,
.L166:
# a.out.c:543:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6);
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 168
.L194:
# a.out.c:559:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7);
	pushq	%rcx	# tmp_6
	.cfi_def_cfa_offset 176
	movq	%r14, %rdx	# tmp_2,
	movq	%r15, %rcx	# tmp_3,
	movq	%r13, %rsi	# tmp_1,
	movq	%r12, %rdi	# tmp_0,
	call	*%rbp	# _2
	popq	%rdx	#
	.cfi_def_cfa_offset 168
	popq	%rcx	#
	.cfi_def_cfa_offset 160
	jmp	.L138	#
	.p2align 4,,10
	.p2align 3
.L155:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp540
# a.out.c:487:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _9
# a.out.c:487:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_9, tmp_0
# a.out.c:488:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_9 + 8B], tmp_1
# a.out.c:489:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %r14	# MEM[(struct kha_obj * *)_9 + 16B], tmp_2
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp538
	shrq	$8, %rax	#, tmp538
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp540, _388
	andq	%rdx, %rax	# tmp540, _388
	movq	%rax, %rdx	# _388, tmp551
	movb	%al, 1(%rdi)	# _388,
	shrq	$16, %rdx	#, tmp551
	movb	%ah, 2(%rdi)	# _388,
	movb	%dl, 3(%rdi)	# tmp551,
	movq	%rax, %rdx	# _388, tmp556
	shrq	$24, %rdx	#, tmp556
	movb	%dl, 4(%rdi)	# tmp556,
	movq	%rax, %rdx	# _388, tmp561
	shrq	$32, %rdx	#, tmp561
	movb	%dl, 5(%rdi)	# tmp561,
	movq	%rax, %rdx	# _388, tmp566
	shrq	$40, %rdx	#, tmp566
	movb	%dl, 6(%rdi)	# tmp566,
	movq	%rax, %rdx	# _388, tmp572
	shrq	$48, %rdx	#, tmp572
	movb	%dl, 7(%rdi)	# tmp572,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _388
	je	.L210	#,
.L162:
# a.out.c:875: }
	addq	$104, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
# a.out.c:491:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2);
	movq	%r14, %rdx	# tmp_2,
	movq	%r13, %rsi	# tmp_1,
	movq	%r12, %rdi	# tmp_0,
# a.out.c:875: }
	popq	%rbx	#
	.cfi_def_cfa_offset 48
# a.out.c:491:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2);
	movq	%rbp, %rax	# _2, _2
# a.out.c:875: }
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
# a.out.c:491:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2);
	jmp	*%rax	# _2
	.p2align 4,,10
	.p2align 3
.L147:
	.cfi_restore_state
# a.out.c:607:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _17
# a.out.c:613:       tmp_6 = (a->data.pap->args[6]);
	movq	48(%rax), %rsi	# MEM[(struct kha_obj * *)_17 + 48B], tmp_6
# a.out.c:607:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_17, tmp_0
# a.out.c:608:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_17 + 8B], tmp_1
# a.out.c:609:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %r14	# MEM[(struct kha_obj * *)_17 + 16B], tmp_2
# a.out.c:610:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %r15	# MEM[(struct kha_obj * *)_17 + 24B], tmp_3
# a.out.c:611:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_17 + 32B], tmp_4
# a.out.c:613:       tmp_6 = (a->data.pap->args[6]);
	movq	%rsi, 8(%rsp)	# tmp_6, %sfp
# a.out.c:612:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_17 + 40B], tmp_5
# a.out.c:614:       tmp_7 = (a->data.pap->args[7]);
	movq	56(%rax), %rcx	# MEM[(struct kha_obj * *)_17 + 56B], tmp_7
# a.out.c:615:       tmp_8 = (a->data.pap->args[8]);
	movq	64(%rax), %rsi	# MEM[(struct kha_obj * *)_17 + 64B], tmp_8
# a.out.c:616:       tmp_9 = (a->data.pap->args[9]);
	movq	72(%rax), %r10	# MEM[(struct kha_obj * *)_17 + 72B], tmp_9
# a.out.c:617:       tmp_10 = (a->data.pap->args[10]);
	movq	80(%rax), %r11	# MEM[(struct kha_obj * *)_17 + 80B], tmp_10
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp858
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdi	#, tmp860
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rax	#, tmp858
# a.out.c:208:   a->gc -= 1;
	addq	%rdi, %rax	# tmp860, _404
	andq	%rdi, %rax	# tmp860, _404
	movq	%rax, %rdi	# _404, tmp871
	movb	%al, 1(%rbx)	# _404,
	shrq	$16, %rdi	#, tmp871
	movb	%ah, 2(%rbx)	# _404,
	movb	%dil, 3(%rbx)	# tmp871,
	movq	%rax, %rdi	# _404, tmp876
	shrq	$24, %rdi	#, tmp876
	movb	%dil, 4(%rbx)	# tmp876,
	movq	%rax, %rdi	# _404, tmp881
	shrq	$32, %rdi	#, tmp881
	movb	%dil, 5(%rbx)	# tmp881,
	movq	%rax, %rdi	# _404, tmp886
	shrq	$40, %rdi	#, tmp886
	movb	%dil, 6(%rbx)	# tmp886,
	movq	%rax, %rdi	# _404, tmp892
	shrq	$48, %rdi	#, tmp892
	movb	%dil, 7(%rbx)	# tmp892,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _404
	je	.L211	#,
.L170:
# a.out.c:619:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7,
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 168
	movq	%r14, %rdx	# tmp_2,
	movq	%r12, %rdi	# tmp_0,
	pushq	%r11	# tmp_10
	.cfi_def_cfa_offset 176
	pushq	%r10	# tmp_9
	.cfi_def_cfa_offset 184
	pushq	%rsi	# tmp_8
	.cfi_def_cfa_offset 192
	movq	%r13, %rsi	# tmp_1,
	pushq	%rcx	# tmp_7
	.cfi_def_cfa_offset 200
	movq	%r15, %rcx	# tmp_3,
	pushq	48(%rsp)	# %sfp
	.cfi_def_cfa_offset 208
	call	*%rbp	# _2
	addq	$48, %rsp	#,
	.cfi_def_cfa_offset 160
	jmp	.L138	#
	.p2align 4,,10
	.p2align 3
.L149:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp780
# a.out.c:567:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _15
# a.out.c:567:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %r12	# *_15, tmp_0
# a.out.c:568:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %r13	# MEM[(struct kha_obj * *)_15 + 8B], tmp_1
# a.out.c:569:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %r14	# MEM[(struct kha_obj * *)_15 + 16B], tmp_2
# a.out.c:570:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %r15	# MEM[(struct kha_obj * *)_15 + 24B], tmp_3
# a.out.c:571:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_15 + 32B], tmp_4
# a.out.c:572:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_15 + 40B], tmp_5
# a.out.c:573:       tmp_6 = (a->data.pap->args[6]);
	movq	48(%rax), %rcx	# MEM[(struct kha_obj * *)_15 + 48B], tmp_6
# a.out.c:574:       tmp_7 = (a->data.pap->args[7]);
	movq	56(%rax), %rsi	# MEM[(struct kha_obj * *)_15 + 56B], tmp_7
# a.out.c:575:       tmp_8 = (a->data.pap->args[8]);
	movq	64(%rax), %r10	# MEM[(struct kha_obj * *)_15 + 64B], tmp_8
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp778
	shrq	$8, %rax	#, tmp778
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp780, _400
	andq	%rdx, %rax	# tmp780, _400
	movq	%rax, %rdx	# _400, tmp791
	movb	%al, 1(%rdi)	# _400,
	shrq	$16, %rdx	#, tmp791
	movb	%ah, 2(%rdi)	# _400,
	movb	%dl, 3(%rdi)	# tmp791,
	movq	%rax, %rdx	# _400, tmp796
	shrq	$24, %rdx	#, tmp796
	movb	%dl, 4(%rdi)	# tmp796,
	movq	%rax, %rdx	# _400, tmp801
	shrq	$32, %rdx	#, tmp801
	movb	%dl, 5(%rdi)	# tmp801,
	movq	%rax, %rdx	# _400, tmp806
	shrq	$40, %rdx	#, tmp806
	movb	%dl, 6(%rdi)	# tmp806,
	movq	%rax, %rdx	# _400, tmp812
	shrq	$48, %rdx	#, tmp812
	movb	%dl, 7(%rdi)	# tmp812,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _400
	je	.L212	#,
.L168:
# a.out.c:577:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7,
	subq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 168
	pushq	%r10	# tmp_8
	.cfi_def_cfa_offset 176
	pushq	%rsi	# tmp_7
	.cfi_def_cfa_offset 184
	pushq	%rcx	# tmp_6
	.cfi_def_cfa_offset 192
	jmp	.L195	#
	.p2align 4,,10
	.p2align 3
.L145:
	.cfi_restore_state
# a.out.c:652:       tmp_0 = (a->data.pap->args[0]);
	movq	8(%rax), %rax	# _1->args, _19
# a.out.c:654:       tmp_2 = (a->data.pap->args[2]);
	movq	16(%rax), %rcx	# MEM[(struct kha_obj * *)_19 + 16B], tmp_2
# a.out.c:652:       tmp_0 = (a->data.pap->args[0]);
	movq	(%rax), %rsi	# *_19, tmp_0
# a.out.c:655:       tmp_3 = (a->data.pap->args[3]);
	movq	24(%rax), %r13	# MEM[(struct kha_obj * *)_19 + 24B], tmp_3
# a.out.c:656:       tmp_4 = (a->data.pap->args[4]);
	movq	32(%rax), %r8	# MEM[(struct kha_obj * *)_19 + 32B], tmp_4
# a.out.c:657:       tmp_5 = (a->data.pap->args[5]);
	movq	40(%rax), %r9	# MEM[(struct kha_obj * *)_19 + 40B], tmp_5
# a.out.c:658:       tmp_6 = (a->data.pap->args[6]);
	movq	48(%rax), %r14	# MEM[(struct kha_obj * *)_19 + 48B], tmp_6
# a.out.c:654:       tmp_2 = (a->data.pap->args[2]);
	movq	%rcx, 16(%rsp)	# tmp_2, %sfp
# a.out.c:660:       tmp_8 = (a->data.pap->args[8]);
	movq	64(%rax), %rcx	# MEM[(struct kha_obj * *)_19 + 64B], tmp_8
# a.out.c:659:       tmp_7 = (a->data.pap->args[7]);
	movq	56(%rax), %r15	# MEM[(struct kha_obj * *)_19 + 56B], tmp_7
# a.out.c:652:       tmp_0 = (a->data.pap->args[0]);
	movq	%rsi, 8(%rsp)	# tmp_0, %sfp
# a.out.c:662:       tmp_10 = (a->data.pap->args[10]);
	movq	80(%rax), %r12	# MEM[(struct kha_obj * *)_19 + 80B], tmp_10
# a.out.c:653:       tmp_1 = (a->data.pap->args[1]);
	movq	8(%rax), %rsi	# MEM[(struct kha_obj * *)_19 + 8B], tmp_1
# a.out.c:663:       tmp_11 = (a->data.pap->args[11]);
	movq	88(%rax), %r10	# MEM[(struct kha_obj * *)_19 + 88B], tmp_11
# a.out.c:664:       tmp_12 = (a->data.pap->args[12]);
	movq	96(%rax), %r11	# MEM[(struct kha_obj * *)_19 + 96B], tmp_12
# a.out.c:660:       tmp_8 = (a->data.pap->args[8]);
	movq	%rcx, 24(%rsp)	# tmp_8, %sfp
# a.out.c:661:       tmp_9 = (a->data.pap->args[9]);
	movq	72(%rax), %rcx	# MEM[(struct kha_obj * *)_19 + 72B], tmp_9
# a.out.c:208:   a->gc -= 1;
	movq	(%rdi), %rax	# *a_177(D), tmp938
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdi	#, tmp940
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rax	#, tmp938
# a.out.c:208:   a->gc -= 1;
	addq	%rdi, %rax	# tmp940, _408
	andq	%rdi, %rax	# tmp940, _408
	movq	%rax, %rdi	# _408, tmp951
	movb	%al, 1(%rbx)	# _408,
	shrq	$16, %rdi	#, tmp951
	movb	%ah, 2(%rbx)	# _408,
	movb	%dil, 3(%rbx)	# tmp951,
	movq	%rax, %rdi	# _408, tmp956
	shrq	$24, %rdi	#, tmp956
	movb	%dil, 4(%rbx)	# tmp956,
	movq	%rax, %rdi	# _408, tmp961
	shrq	$32, %rdi	#, tmp961
	movb	%dil, 5(%rbx)	# tmp961,
	movq	%rax, %rdi	# _408, tmp966
	shrq	$40, %rdi	#, tmp966
	movb	%dil, 6(%rbx)	# tmp966,
	movq	%rax, %rdi	# _408, tmp972
	shrq	$48, %rdi	#, tmp972
	movb	%dil, 7(%rbx)	# tmp972,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _408
	je	.L213	#,
.L172:
# a.out.c:666:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7,
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 168
	pushq	%r11	# tmp_12
	.cfi_def_cfa_offset 176
	pushq	%r10	# tmp_11
	.cfi_def_cfa_offset 184
	pushq	%r12	# tmp_10
	.cfi_def_cfa_offset 192
	pushq	%rcx	# tmp_9
	.cfi_def_cfa_offset 200
	movq	%r13, %rcx	# tmp_3,
	pushq	64(%rsp)	# %sfp
	.cfi_def_cfa_offset 208
	pushq	%r15	# tmp_7
	.cfi_def_cfa_offset 216
	pushq	%r14	# tmp_6
	.cfi_def_cfa_offset 224
	movq	80(%rsp), %rdx	# %sfp,
	movq	72(%rsp), %rdi	# %sfp,
	call	*%rbp	# _2
	addq	$64, %rsp	#,
	.cfi_def_cfa_offset 160
	jmp	.L138	#
.L204:
	movq	%rsi, 32(%rsp)	# tmp_7, %sfp
	movq	%rcx, 24(%rsp)	# tmp_6, %sfp
	movq	%r9, 16(%rsp)	# tmp_5, %sfp
	movq	%r8, 8(%rsp)	# tmp_4, %sfp
# a.out.c:210:     k_free(a);
	call	k_free	#
	movq	32(%rsp), %rsi	# %sfp, tmp_7
	movq	24(%rsp), %rcx	# %sfp, tmp_6
	movq	16(%rsp), %r9	# %sfp, tmp_5
	movq	8(%rsp), %r8	# %sfp, tmp_4
# a.out.c:559:       return MUSTTAIL f(tmp_0, tmp_1, tmp_2, tmp_3, tmp_4, tmp_5, tmp_6, tmp_7);
	pushq	%rsi	# tmp_7
	.cfi_remember_state
	.cfi_def_cfa_offset 168
	jmp	.L194	#
.L205:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	call	k_free	#
	jmp	.L163	#
.L213:
	movq	%rbx, %rdi	# a,
	movq	%r11, 72(%rsp)	# tmp_12, %sfp
	movq	%r10, 64(%rsp)	# tmp_11, %sfp
	movq	%rcx, 56(%rsp)	# tmp_9, %sfp
	movq	%r9, 48(%rsp)	# tmp_5, %sfp
	movq	%r8, 40(%rsp)	# tmp_4, %sfp
	movq	%rsi, 32(%rsp)	# tmp_1, %sfp
	call	k_free	#
	movq	72(%rsp), %r11	# %sfp, tmp_12
	movq	64(%rsp), %r10	# %sfp, tmp_11
	movq	56(%rsp), %rcx	# %sfp, tmp_9
	movq	48(%rsp), %r9	# %sfp, tmp_5
	movq	40(%rsp), %r8	# %sfp, tmp_4
	movq	32(%rsp), %rsi	# %sfp, tmp_1
	jmp	.L172	#
.L200:
	movq	%r9, 16(%rsp)	# tmp_5, %sfp
	movq	%r8, 8(%rsp)	# tmp_4, %sfp
	call	k_free	#
	movq	16(%rsp), %r9	# %sfp, tmp_5
	movq	8(%rsp), %r8	# %sfp, tmp_4
	jmp	.L165	#
.L209:
	movq	%rcx, 24(%rsp)	# tmp_6, %sfp
	movq	%r9, 16(%rsp)	# tmp_5, %sfp
	movq	%r8, 8(%rsp)	# tmp_4, %sfp
	call	k_free	#
	movq	24(%rsp), %rcx	# %sfp, tmp_6
	movq	16(%rsp), %r9	# %sfp, tmp_5
	movq	8(%rsp), %r8	# %sfp, tmp_4
	jmp	.L166	#
.L198:
	movq	%rbx, %rdi	# a,
	movq	%r11, 80(%rsp)	# tmp_13, %sfp
	movq	%r10, 72(%rsp)	# tmp_12, %sfp
	movq	%rcx, 64(%rsp)	# tmp_10, %sfp
	movq	%r9, 56(%rsp)	# tmp_5, %sfp
	movq	%r8, 48(%rsp)	# tmp_4, %sfp
	movq	%rsi, 40(%rsp)	# tmp_1, %sfp
	call	k_free	#
	movq	80(%rsp), %r11	# %sfp, tmp_13
	movq	72(%rsp), %r10	# %sfp, tmp_12
	movq	64(%rsp), %rcx	# %sfp, tmp_10
	movq	56(%rsp), %r9	# %sfp, tmp_5
	movq	48(%rsp), %r8	# %sfp, tmp_4
	movq	40(%rsp), %rsi	# %sfp, tmp_1
	jmp	.L173	#
.L202:
	movq	%rbx, %rdi	# a,
	movq	%r10, 48(%rsp)	# tmp_9, %sfp
	movq	%rsi, 40(%rsp)	# tmp_8, %sfp
	movq	%rcx, 32(%rsp)	# tmp_7, %sfp
	movq	%r11, 24(%rsp)	# tmp_6, %sfp
	movq	%r9, 16(%rsp)	# tmp_5, %sfp
	movq	%r8, 8(%rsp)	# tmp_4, %sfp
	call	k_free	#
	movq	48(%rsp), %r10	# %sfp, tmp_9
	movq	40(%rsp), %rsi	# %sfp, tmp_8
	movq	32(%rsp), %rcx	# %sfp, tmp_7
	movq	24(%rsp), %r11	# %sfp, tmp_6
	movq	16(%rsp), %r9	# %sfp, tmp_5
	movq	8(%rsp), %r8	# %sfp, tmp_4
	jmp	.L169	#
.L207:
	movq	%rbx, %rdi	# a,
	movq	%r11, 64(%rsp)	# tmp_11, %sfp
	movq	%r10, 56(%rsp)	# tmp_10, %sfp
	movq	%r9, 48(%rsp)	# tmp_5, %sfp
	movq	%r8, 40(%rsp)	# tmp_4, %sfp
	movq	%rcx, 32(%rsp)	# tmp_3, %sfp
	movq	%rsi, 24(%rsp)	# tmp_1, %sfp
	call	k_free	#
	movq	64(%rsp), %r11	# %sfp, tmp_11
	movq	56(%rsp), %r10	# %sfp, tmp_10
	movq	48(%rsp), %r9	# %sfp, tmp_5
	movq	40(%rsp), %r8	# %sfp, tmp_4
	movq	32(%rsp), %rcx	# %sfp, tmp_3
	movq	24(%rsp), %rsi	# %sfp, tmp_1
	jmp	.L171	#
.L199:
	movq	%rbx, %rdi	# a,
	movq	%r11, 88(%rsp)	# tmp_14, %sfp
	movq	%r10, 80(%rsp)	# tmp_13, %sfp
	movq	%r9, 72(%rsp)	# tmp_5, %sfp
	movq	%r8, 64(%rsp)	# tmp_4, %sfp
	movq	%rcx, 56(%rsp)	# tmp_3, %sfp
	movq	%rsi, 48(%rsp)	# tmp_1, %sfp
	call	k_free	#
	movq	88(%rsp), %r11	# %sfp, tmp_14
	movq	80(%rsp), %r10	# %sfp, tmp_13
	movq	72(%rsp), %r9	# %sfp, tmp_5
	movq	64(%rsp), %r8	# %sfp, tmp_4
	movq	56(%rsp), %rcx	# %sfp, tmp_3
	movq	48(%rsp), %rsi	# %sfp, tmp_1
	jmp	.L174	#
.L208:
	call	k_free	#
	jmp	.L160	#
.L203:
	call	k_free	#
	jmp	.L159	#
.L211:
	movq	%rbx, %rdi	# a,
	movq	%r11, 56(%rsp)	# tmp_10, %sfp
	movq	%r10, 48(%rsp)	# tmp_9, %sfp
	movq	%rsi, 40(%rsp)	# tmp_8, %sfp
	movq	%rcx, 32(%rsp)	# tmp_7, %sfp
	movq	%r9, 24(%rsp)	# tmp_5, %sfp
	movq	%r8, 16(%rsp)	# tmp_4, %sfp
	call	k_free	#
	movq	56(%rsp), %r11	# %sfp, tmp_10
	movq	48(%rsp), %r10	# %sfp, tmp_9
	movq	40(%rsp), %rsi	# %sfp, tmp_8
	movq	32(%rsp), %rcx	# %sfp, tmp_7
	movq	24(%rsp), %r9	# %sfp, tmp_5
	movq	16(%rsp), %r8	# %sfp, tmp_4
	jmp	.L170	#
.L201:
	call	k_free	#
	jmp	.L161	#
.L210:
	call	k_free	#
	jmp	.L162	#
.L206:
	movq	%r8, 8(%rsp)	# tmp_4, %sfp
	call	k_free	#
	movq	8(%rsp), %r8	# %sfp, tmp_4
	jmp	.L164	#
.L212:
	movq	%r10, 40(%rsp)	# tmp_8, %sfp
	movq	%rsi, 32(%rsp)	# tmp_7, %sfp
	movq	%rcx, 24(%rsp)	# tmp_6, %sfp
	movq	%r9, 16(%rsp)	# tmp_5, %sfp
	movq	%r8, 8(%rsp)	# tmp_4, %sfp
	call	k_free	#
	movq	40(%rsp), %r10	# %sfp, tmp_8
	movq	32(%rsp), %rsi	# %sfp, tmp_7
	movq	24(%rsp), %rcx	# %sfp, tmp_6
	movq	16(%rsp), %r9	# %sfp, tmp_5
	movq	8(%rsp), %r8	# %sfp, tmp_4
	jmp	.L168	#
.L141:
# a.out.c:873:   fprintf(stderr, "IMPOSSIBLE: reached end of 'call' \n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$35, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC4(%rip), %rdi	#, tmp1138
	call	fwrite@PLT	#
# a.out.c:874:   exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE38:
	.size	call, .-call
	.section	.rodata.str1.1
.LC5:
	.string	"ERROR: Can't call non-ptr %d"
	.text
	.p2align 4
	.globl	add_arg
	.type	add_arg, @function
add_arg:
.LFB36:
	.cfi_startproc
	pushq	%r14	#
	.cfi_def_cfa_offset 16
	.cfi_offset 14, -16
	pushq	%r13	#
	.cfi_def_cfa_offset 24
	.cfi_offset 13, -24
	pushq	%r12	#
	.cfi_def_cfa_offset 32
	.cfi_offset 12, -32
	pushq	%rbp	#
	.cfi_def_cfa_offset 40
	.cfi_offset 6, -40
	movq	%rdi, %rbp	# tmp247, a
	pushq	%rbx	#
	.cfi_def_cfa_offset 48
	.cfi_offset 3, -48
# a.out.c:393:   if (a->tag == PAP) {
	movzbl	(%rdi), %eax	# a_20(D)->D.4393.D.4391.tag, _1
# a.out.c:392: kha_obj * add_arg(kha_obj *a, kha_obj *b) {
	movq	%rsi, %rbx	# tmp248, b
# a.out.c:393:   if (a->tag == PAP) {
	cmpb	$1, %al	#, _1
	je	.L225	#,
# a.out.c:406:   } else if (a->tag == PTR) {
	cmpb	$3, %al	#, _1
	jne	.L217	#,
# a.out.c:407:     kha_obj **args = malloc(sizeof(kha_obj *));
	movl	$8, %edi	#,
	call	malloc@PLT	#
	movq	%rax, %r12	# tmp251, tmp159
# a.out.c:196:   if (!a) {
	testq	%rbx, %rbx	# b
	je	.L218	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rbx), %rax	# *b_25(D), tmp162
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r13	#, tmp166
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp162
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp164
	andq	%r13, %rax	# tmp166, tmp165
	movq	%rax, %rdx	# tmp165, tmp176
	movb	%al, 1(%rbx)	# tmp165,
	shrq	$16, %rdx	#, tmp176
	movb	%ah, 2(%rbx)	# tmp165,
	movb	%dl, 3(%rbx)	# tmp176,
	movq	%rax, %rdx	# tmp165, tmp181
	shrq	$24, %rdx	#, tmp181
	movb	%dl, 4(%rbx)	# tmp181,
	movq	%rax, %rdx	# tmp165, tmp186
	shrq	$32, %rdx	#, tmp186
	movb	%dl, 5(%rbx)	# tmp186,
	movq	%rax, %rdx	# tmp165, tmp191
	shrq	$48, %rax	#, tmp197
	shrq	$40, %rdx	#, tmp191
	movb	%al, 7(%rbx)	# tmp197,
	movb	%dl, 6(%rbx)	# tmp191,
# a.out.c:409:     kha_obj *k = make_pap(1, a->data.ptr, args);
	movq	8(%rbp), %r14	# a_20(D)->data.ptr, _14
# a.out.c:408:     args[0] = ref(b);
	movq	%rbx, (%r12)	# b, *args_24
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movl	$24, %edi	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %rbx	# tmp252, a
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$257, (%rbx)	#, MEM[(union  *)a_52]
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movq	%rax, 8(%rbx)	# tmp202, a_52->data.pap
# a.out.c:312:   k->data.pap->argnum = argnum;
	movq	$1, 16(%rax)	#, MEM[(struct kha_obj_pap *)_53].argnum
# a.out.c:313:   k->data.pap->args = args;
	movq	%r12, 8(%rax)	# tmp159, MEM[(struct kha_obj_pap *)_53].args
# a.out.c:314:   k->data.pap->func = p;
	movq	%r14, (%rax)	# _14, MEM[(struct kha_obj_pap *)_53].func
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *a_20(D), tmp205
	shrq	$8, %rax	#, tmp205
# a.out.c:208:   a->gc -= 1;
	addq	%r13, %rax	# tmp166, _42
	andq	%r13, %rax	# tmp166, _42
	movq	%rax, %rdx	# _42, tmp218
	movb	%al, 1(%rbp)	# _42,
	shrq	$16, %rdx	#, tmp218
	movb	%ah, 2(%rbp)	# _42,
	movb	%dl, 3(%rbp)	# tmp218,
	movq	%rax, %rdx	# _42, tmp223
	shrq	$24, %rdx	#, tmp223
	movb	%dl, 4(%rbp)	# tmp223,
	movq	%rax, %rdx	# _42, tmp228
	shrq	$32, %rdx	#, tmp228
	movb	%dl, 5(%rbp)	# tmp228,
	movq	%rax, %rdx	# _42, tmp233
	shrq	$40, %rdx	#, tmp233
	movb	%dl, 6(%rbp)	# tmp233,
	movq	%rax, %rdx	# _42, tmp239
	shrq	$48, %rdx	#, tmp239
	movb	%dl, 7(%rbp)	# tmp239,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _42
	je	.L226	#,
.L219:
# a.out.c:412:     return call(k);
	movq	%rbx, %rdi	# a,
# a.out.c:417: }
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	popq	%rbp	#
	.cfi_def_cfa_offset 32
	popq	%r12	#
	.cfi_def_cfa_offset 24
	popq	%r13	#
	.cfi_def_cfa_offset 16
	popq	%r14	#
	.cfi_def_cfa_offset 8
# a.out.c:412:     return call(k);
	jmp	call	#
	.p2align 4,,10
	.p2align 3
.L226:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# a,
	call	k_free	#
	jmp	.L219	#
	.p2align 4,,10
	.p2align 3
.L225:
# a.out.c:397:     a = copy_pap(a);
	call	copy_pap	#
# a.out.c:399:     a->data.pap->argnum++;
	movq	8(%rax), %r12	# a_32->data.pap, _2
# a.out.c:397:     a = copy_pap(a);
	movq	%rax, %rbp	# tmp249, a
# a.out.c:399:     a->data.pap->argnum++;
	movq	16(%r12), %rax	# _2->argnum, tmp255
# a.out.c:401:         realloc(a->data.pap->args,
	movq	8(%r12), %rdi	# _2->args, _2->args
# a.out.c:399:     a->data.pap->argnum++;
	leaq	1(%rax), %rsi	#, _4
	movq	%rsi, 16(%r12)	# _4, _2->argnum
# a.out.c:401:         realloc(a->data.pap->args,
	salq	$3, %rsi	#, tmp112
	call	realloc@PLT	#
# a.out.c:400:     a->data.pap->args =
	movq	%rax, 8(%r12)	# tmp250, _2->args
# a.out.c:403:     a->data.pap->args[a->data.pap->argnum - 1] = ref(b);
	movq	8(%rbp), %rax	# a_32->data.pap, _8
# a.out.c:403:     a->data.pap->args[a->data.pap->argnum - 1] = ref(b);
	movq	16(%rax), %rdx	# _8->argnum, _8->argnum
	movq	8(%rax), %rax	# _8->args, _8->args
	leaq	-8(%rax,%rdx,8), %rdx	#, _13
# a.out.c:196:   if (!a) {
	testq	%rbx, %rbx	# b
	je	.L218	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %rcx	#, tmp124
# a.out.c:200:   a->gc += 1;
	movq	(%rbx), %rax	# *b_25(D), tmp120
# a.out.c:405:     return call(a);
	movq	%rbp, %rdi	# a,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp120
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp122
	andq	%rcx, %rax	# tmp124, tmp123
	movq	%rax, %rcx	# tmp123, tmp134
	movb	%al, 1(%rbx)	# tmp123,
	shrq	$16, %rcx	#, tmp134
	movb	%ah, 2(%rbx)	# tmp123,
	movb	%cl, 3(%rbx)	# tmp134,
	movq	%rax, %rcx	# tmp123, tmp139
	shrq	$24, %rcx	#, tmp139
	movb	%cl, 4(%rbx)	# tmp139,
	movq	%rax, %rcx	# tmp123, tmp144
	shrq	$32, %rcx	#, tmp144
	movb	%cl, 5(%rbx)	# tmp144,
	movq	%rax, %rcx	# tmp123, tmp149
	shrq	$48, %rax	#, tmp155
	shrq	$40, %rcx	#, tmp149
	movb	%al, 7(%rbx)	# tmp155,
	movb	%cl, 6(%rbx)	# tmp149,
# a.out.c:403:     a->data.pap->args[a->data.pap->argnum - 1] = ref(b);
	movq	%rbx, (%rdx)	# b, *_13
# a.out.c:417: }
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	popq	%rbp	#
	.cfi_def_cfa_offset 32
	popq	%r12	#
	.cfi_def_cfa_offset 24
	popq	%r13	#
	.cfi_def_cfa_offset 16
	popq	%r14	#
	.cfi_def_cfa_offset 8
# a.out.c:412:     return call(k);
	jmp	call	#
.L218:
	.cfi_restore_state
	call	ref.part.0	#
.L217:
# a.out.c:414:     fprintf(stderr, "ERROR: Can't call non-ptr %d", a->tag);
	movq	stderr(%rip), %rdi	# stderr,
	movzbl	%al, %edx	# _1, _1
	xorl	%eax, %eax	#
	leaq	.LC5(%rip), %rsi	#, tmp245
	call	fprintf@PLT	#
# a.out.c:415:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE36:
	.size	add_arg, .-add_arg
	.section	.rodata.str1.1
.LC6:
	.string	"Cannot reconcile: %d\n"
	.text
	.p2align 4
	.globl	reconcile
	.type	reconcile, @function
reconcile:
.LFB37:
	.cfi_startproc
	pushq	%r15	#
	.cfi_def_cfa_offset 16
	.cfi_offset 15, -16
	pushq	%r14	#
	.cfi_def_cfa_offset 24
	.cfi_offset 14, -24
	pushq	%r13	#
	.cfi_def_cfa_offset 32
	.cfi_offset 13, -32
	pushq	%r12	#
	.cfi_def_cfa_offset 40
	.cfi_offset 12, -40
	pushq	%rbp	#
	.cfi_def_cfa_offset 48
	.cfi_offset 6, -48
	movq	%rdx, %rbp	# tmp351, ret
	pushq	%rbx	#
	.cfi_def_cfa_offset 56
	.cfi_offset 3, -56
	subq	$24, %rsp	#,
	.cfi_def_cfa_offset 80
# a.out.c:420:   u64 extra = pap->data.pap->argnum - arg;
	movq	8(%rsi), %r14	# pap_38(D)->data.pap, _1
# a.out.c:421:   if (ret->tag == PAP) {
	movzbl	(%rdx), %eax	# ret_41(D)->D.4393.D.4391.tag, _3
# a.out.c:419: kha_obj *reconcile(u64 arg, kha_obj *pap, kha_obj *ret) {
	movq	%rsi, 8(%rsp)	# pap, %sfp
# a.out.c:420:   u64 extra = pap->data.pap->argnum - arg;
	movq	16(%r14), %r12	# _1->argnum, extra
	subq	%rdi, %r12	# tmp349, extra
# a.out.c:421:   if (ret->tag == PAP) {
	cmpb	$1, %al	#, _3
	je	.L247	#,
# a.out.c:435:   else if (ret->tag == PTR) {
	cmpb	$3, %al	#, _3
	jne	.L233	#,
# a.out.c:436:     kha_obj **args = malloc(sizeof(kha_obj *) * (pap->data.pap->argnum - arg));
	leaq	0(,%r12,8), %rdi	#, tmp216
	call	malloc@PLT	#
	movq	%rax, %r13	# tmp353, args
# a.out.c:438:     for (int i = 0; i < (pap->data.pap->argnum - arg); i++) {
	testq	%r12, %r12	# extra
	je	.L234	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r8	#, tmp348
# a.out.c:439:       args[i] = ref(pap->data.pap->args[i]);
	movq	8(%r14), %rdi	# _1->args, _22
	xorl	%ecx, %ecx	# ivtmp.186
	.p2align 4,,10
	.p2align 3
.L236:
# a.out.c:439:       args[i] = ref(pap->data.pap->args[i]);
	movq	(%rdi,%rcx,8), %rdx	# MEM[(struct kha_obj * *)_22 + ivtmp.186_118 * 8], _25
# a.out.c:196:   if (!a) {
	testq	%rdx, %rdx	# _25
	je	.L246	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rdx), %rax	# MEM[(struct kha_obj *)_25], tmp222
	shrq	$8, %rax	#, tmp222
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp224
	andq	%r8, %rax	# tmp348, tmp225
	movq	%rax, %rsi	# tmp225, tmp236
	movb	%al, 1(%rdx)	# tmp225,
	shrq	$16, %rsi	#, tmp236
	movb	%ah, 2(%rdx)	# tmp225,
	movb	%sil, 3(%rdx)	# tmp236,
	movq	%rax, %rsi	# tmp225, tmp241
	shrq	$24, %rsi	#, tmp241
	movb	%sil, 4(%rdx)	# tmp241,
	movq	%rax, %rsi	# tmp225, tmp246
	shrq	$32, %rsi	#, tmp246
	movb	%sil, 5(%rdx)	# tmp246,
	movq	%rax, %rsi	# tmp225, tmp251
	shrq	$48, %rax	#, tmp257
	shrq	$40, %rsi	#, tmp251
	movb	%al, 7(%rdx)	# tmp257,
	movb	%sil, 6(%rdx)	# tmp251,
# a.out.c:439:       args[i] = ref(pap->data.pap->args[i]);
	movq	%rdx, 0(%r13,%rcx,8)	# _25, MEM[(struct kha_obj * *)args_45 + ivtmp.186_118 * 8]
# a.out.c:438:     for (int i = 0; i < (pap->data.pap->argnum - arg); i++) {
	addq	$1, %rcx	#, ivtmp.186
	cmpq	%rcx, %r12	# ivtmp.186, extra
	jne	.L236	#,
.L234:
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:442:     kha_obj * new = make_pap(pap->data.pap->argnum - arg, ret->data.ptr, args);
	movq	8(%rbp), %r15	# ret_41(D)->data.ptr, _28
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movl	$24, %edi	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r14	# tmp354, a
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$257, (%r14)	#, MEM[(union  *)a_84]
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp267
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movq	%rax, 8(%r14)	# tmp262, a_84->data.pap
# a.out.c:312:   k->data.pap->argnum = argnum;
	movq	%r12, 16(%rax)	# extra, MEM[(struct kha_obj_pap *)_85].argnum
# a.out.c:313:   k->data.pap->args = args;
	movq	%r13, 8(%rax)	# args, MEM[(struct kha_obj_pap *)_85].args
# a.out.c:314:   k->data.pap->func = p;
	movq	%r15, (%rax)	# _28, MEM[(struct kha_obj_pap *)_85].func
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *ret_41(D), tmp265
	shrq	$8, %rax	#, tmp265
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp267, _68
	andq	%rdx, %rax	# tmp267, _68
	movq	%rax, %rdx	# _68, tmp278
	movb	%al, 1(%rbp)	# _68,
	shrq	$16, %rdx	#, tmp278
	movb	%ah, 2(%rbp)	# _68,
	movb	%dl, 3(%rbp)	# tmp278,
	movq	%rax, %rdx	# _68, tmp283
	shrq	$24, %rdx	#, tmp283
	movb	%dl, 4(%rbp)	# tmp283,
	movq	%rax, %rdx	# _68, tmp288
	shrq	$32, %rdx	#, tmp288
	movb	%dl, 5(%rbp)	# tmp288,
	movq	%rax, %rdx	# _68, tmp293
	shrq	$40, %rdx	#, tmp293
	movb	%dl, 6(%rbp)	# tmp293,
	movq	%rax, %rdx	# _68, tmp299
	shrq	$48, %rdx	#, tmp299
	movb	%dl, 7(%rbp)	# tmp299,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _68
	je	.L248	#,
.L237:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp307
# a.out.c:208:   a->gc -= 1;
	movq	8(%rsp), %rdi	# %sfp, pap
	movq	(%rdi), %rax	# *pap_38(D), tmp305
	shrq	$8, %rax	#, tmp305
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp307, _66
	andq	%rdx, %rax	# tmp307, _66
	movq	%rax, %rdx	# _66, tmp318
	movb	%al, 1(%rdi)	# _66,
	shrq	$16, %rdx	#, tmp318
	movb	%ah, 2(%rdi)	# _66,
	movb	%dl, 3(%rdi)	# tmp318,
	movq	%rax, %rdx	# _66, tmp323
	shrq	$24, %rdx	#, tmp323
	movb	%dl, 4(%rdi)	# tmp323,
	movq	%rax, %rdx	# _66, tmp328
	shrq	$32, %rdx	#, tmp328
	movb	%dl, 5(%rdi)	# tmp328,
	movq	%rax, %rdx	# _66, tmp333
	shrq	$40, %rdx	#, tmp333
	movb	%dl, 6(%rdi)	# tmp333,
	movq	%rax, %rdx	# _66, tmp339
	shrq	$48, %rdx	#, tmp339
	movb	%dl, 7(%rdi)	# tmp339,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _66
	je	.L249	#,
.L238:
# a.out.c:446:     return MUSTTAIL call(new);
	movq	%r14, %rdi	# a,
.L245:
# a.out.c:452: }
	addq	$24, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
# a.out.c:446:     return MUSTTAIL call(new);
	jmp	call	#
	.p2align 4,,10
	.p2align 3
.L248:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# ret,
	call	k_free	#
	jmp	.L237	#
	.p2align 4,,10
	.p2align 3
.L249:
	movq	8(%rsp), %rdi	# %sfp,
	call	k_free	#
	jmp	.L238	#
	.p2align 4,,10
	.p2align 3
.L247:
# a.out.c:426: 				  * (ret->data.pap->argnum + extra));
	movq	8(%rdx), %r13	# ret_41(D)->data.pap, _4
# a.out.c:426: 				  * (ret->data.pap->argnum + extra));
	movq	16(%r13), %rsi	# _4->argnum, tmp128
# a.out.c:424:     ret->data.pap->args = realloc(ret->data.pap->args,
	movq	8(%r13), %rdi	# _4->args, _4->args
# a.out.c:426: 				  * (ret->data.pap->argnum + extra));
	addq	%r12, %rsi	# extra, tmp128
# a.out.c:424:     ret->data.pap->args = realloc(ret->data.pap->args,
	salq	$3, %rsi	#, tmp130
	call	realloc@PLT	#
# a.out.c:424:     ret->data.pap->args = realloc(ret->data.pap->args,
	movq	%rax, 8(%r13)	# tmp352, _4->args
# a.out.c:428:     for(int i = ret->data.pap->argnum; i < ret->data.pap->argnum + extra; i++) {
	movq	8(%rbp), %rax	# ret_41(D)->data.pap, _10
# a.out.c:428:     for(int i = ret->data.pap->argnum; i < ret->data.pap->argnum + extra; i++) {
	movq	16(%rax), %rdi	# _10->argnum, _11
# a.out.c:428:     for(int i = ret->data.pap->argnum; i < ret->data.pap->argnum + extra; i++) {
	movslq	%edi, %rcx	# _11, ivtmp.180
# a.out.c:428:     for(int i = ret->data.pap->argnum; i < ret->data.pap->argnum + extra; i++) {
	addq	%r12, %rdi	# extra, _108
# a.out.c:428:     for(int i = ret->data.pap->argnum; i < ret->data.pap->argnum + extra; i++) {
	cmpq	%rdi, %rcx	# _108, ivtmp.180
	jnb	.L229	#,
# a.out.c:429:       ret->data.pap->args[i] = ref(pap->data.pap->args[i]);
	movq	8(%rsp), %rbx	# %sfp, pap
# a.out.c:429:       ret->data.pap->args[i] = ref(pap->data.pap->args[i]);
	movq	8(%rax), %r9	# _10->args, _17
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r8	#, tmp347
# a.out.c:429:       ret->data.pap->args[i] = ref(pap->data.pap->args[i]);
	movq	8(%rbx), %rdx	# pap_38(D)->data.pap, pap_38(D)->data.pap
	movq	8(%rdx), %r10	# _12->args, _13
	.p2align 4,,10
	.p2align 3
.L231:
# a.out.c:429:       ret->data.pap->args[i] = ref(pap->data.pap->args[i]);
	movq	(%r10,%rcx,8), %rdx	# MEM[(struct kha_obj * *)_13 + ivtmp.180_46 * 8], _16
# a.out.c:196:   if (!a) {
	testq	%rdx, %rdx	# _16
	je	.L246	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rdx), %rax	# MEM[(struct kha_obj *)_16], tmp137
	shrq	$8, %rax	#, tmp137
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp139
	andq	%r8, %rax	# tmp347, tmp140
	movq	%rax, %rsi	# tmp140, tmp151
	movb	%al, 1(%rdx)	# tmp140,
	shrq	$16, %rsi	#, tmp151
	movb	%ah, 2(%rdx)	# tmp140,
	movb	%sil, 3(%rdx)	# tmp151,
	movq	%rax, %rsi	# tmp140, tmp156
	shrq	$24, %rsi	#, tmp156
	movb	%sil, 4(%rdx)	# tmp156,
	movq	%rax, %rsi	# tmp140, tmp161
	shrq	$32, %rsi	#, tmp161
	movb	%sil, 5(%rdx)	# tmp161,
	movq	%rax, %rsi	# tmp140, tmp166
	shrq	$48, %rax	#, tmp172
	shrq	$40, %rsi	#, tmp166
	movb	%al, 7(%rdx)	# tmp172,
	movb	%sil, 6(%rdx)	# tmp166,
# a.out.c:429:       ret->data.pap->args[i] = ref(pap->data.pap->args[i]);
	movq	%rdx, (%r9,%rcx,8)	# _16, MEM[(struct kha_obj * *)_17 + ivtmp.180_46 * 8]
# a.out.c:428:     for(int i = ret->data.pap->argnum; i < ret->data.pap->argnum + extra; i++) {
	addq	$1, %rcx	#, ivtmp.180
	cmpq	%rdi, %rcx	# _108, ivtmp.180
	jb	.L231	#,
.L229:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp180
# a.out.c:208:   a->gc -= 1;
	movq	8(%rsp), %rdi	# %sfp, pap
	movq	(%rdi), %rax	# *pap_38(D), tmp178
	shrq	$8, %rax	#, tmp178
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp180, _62
	andq	%rdx, %rax	# tmp180, _62
	movq	%rax, %rdx	# _62, tmp191
	movb	%al, 1(%rdi)	# _62,
	shrq	$16, %rdx	#, tmp191
	movb	%ah, 2(%rdi)	# _62,
	movb	%dl, 3(%rdi)	# tmp191,
	movq	%rax, %rdx	# _62, tmp196
	shrq	$24, %rdx	#, tmp196
	movb	%dl, 4(%rdi)	# tmp196,
	movq	%rax, %rdx	# _62, tmp201
	shrq	$32, %rdx	#, tmp201
	movb	%dl, 5(%rdi)	# tmp201,
	movq	%rax, %rdx	# _62, tmp206
	shrq	$40, %rdx	#, tmp206
	movb	%dl, 6(%rdi)	# tmp206,
	movq	%rax, %rdx	# _62, tmp212
	shrq	$48, %rdx	#, tmp212
	movb	%dl, 7(%rdi)	# tmp212,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _62
	je	.L250	#,
.L232:
# a.out.c:433:     return MUSTTAIL call(ret);
	movq	%rbp, %rdi	# ret,
	jmp	.L245	#
.L250:
# a.out.c:210:     k_free(a);
	movq	8(%rsp), %rdi	# %sfp,
	call	k_free	#
	jmp	.L232	#
.L246:
# a.out.c:197:     fprintf(stderr, "can't ref null\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$15, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC0(%rip), %rdi	#, tmp219
	call	fwrite@PLT	#
# a.out.c:198:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
.L233:
# a.out.c:449:     fprintf(stderr, "Cannot reconcile: %d\n", ret->tag);
	movq	stderr(%rip), %rdi	# stderr,
	movzbl	%al, %edx	# _3, _3
	xorl	%eax, %eax	#
	leaq	.LC6(%rip), %rsi	#, tmp345
	call	fprintf@PLT	#
# a.out.c:450:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE37:
	.size	reconcile, .-reconcile
	.p2align 4
	.globl	kha_extern_96_s_95_eq_impl
	.type	kha_extern_96_s_95_eq_impl, @function
kha_extern_96_s_95_eq_impl:
.LFB39:
	.cfi_startproc
	pushq	%r12	#
	.cfi_def_cfa_offset 16
	.cfi_offset 12, -16
# a.out.c:885:   if (b->tag != c->tag) {
	movzbl	(%rsi), %eax	# c_9(D)->D.4393.D.4391.tag, tmp185
# a.out.c:883: KHASM_ENTRY(kha_extern_96_s_95_eq, 2, kha_obj *b, kha_obj *c) {
	pushq	%rbp	#
	.cfi_def_cfa_offset 24
	.cfi_offset 6, -24
	movq	%rdi, %rbp	# tmp179, b
	pushq	%rbx	#
	.cfi_def_cfa_offset 32
	.cfi_offset 3, -32
# a.out.c:883: KHASM_ENTRY(kha_extern_96_s_95_eq, 2, kha_obj *b, kha_obj *c) {
	movq	%rsi, %rbx	# tmp180, c
# a.out.c:885:   if (b->tag != c->tag) {
	cmpb	%al, (%rdi)	# tmp185, b_8(D)->D.4393.D.4391.tag
	jne	.L258	#,
# a.out.c:888:   else if (b->data.i != c->data.i) {
	movq	8(%rsi), %rax	# c_9(D)->data.i, tmp186
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:888:   else if (b->data.i != c->data.i) {
	cmpq	%rax, 8(%rbp)	# tmp186, b_8(D)->data.i
	je	.L254	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#,* <retval>
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp182, <retval>
# a.out.c:288:   k->data.i = i;
	movq	$0, 8(%rax)	#,
.L253:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp102
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *b_8(D), tmp100
	shrq	$8, %rax	#, tmp100
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp102, _16
	andq	%rdx, %rax	# tmp102, _16
	movq	%rax, %rdx	# _16, tmp113
	movb	%al, 1(%rbp)	# _16,
	shrq	$16, %rdx	#, tmp113
	movb	%ah, 2(%rbp)	# _16,
	movb	%dl, 3(%rbp)	# tmp113,
	movq	%rax, %rdx	# _16, tmp118
	shrq	$24, %rdx	#, tmp118
	movb	%dl, 4(%rbp)	# tmp118,
	movq	%rax, %rdx	# _16, tmp123
	shrq	$32, %rdx	#, tmp123
	movb	%dl, 5(%rbp)	# tmp123,
	movq	%rax, %rdx	# _16, tmp128
	shrq	$40, %rdx	#, tmp128
	movb	%dl, 6(%rbp)	# tmp128,
	movq	%rax, %rdx	# _16, tmp134
	shrq	$48, %rdx	#, tmp134
	movb	%dl, 7(%rbp)	# tmp134,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _16
	je	.L259	#,
.L255:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp142
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *c_9(D), tmp140
	shrq	$8, %rax	#, tmp140
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp142, _14
	andq	%rdx, %rax	# tmp142, _14
	movq	%rax, %rdx	# _14, tmp153
	movb	%al, 1(%rbx)	# _14,
	shrq	$16, %rdx	#, tmp153
	movb	%ah, 2(%rbx)	# _14,
	movb	%dl, 3(%rbx)	# tmp153,
	movq	%rax, %rdx	# _14, tmp158
	shrq	$24, %rdx	#, tmp158
	movb	%dl, 4(%rbx)	# tmp158,
	movq	%rax, %rdx	# _14, tmp163
	shrq	$32, %rdx	#, tmp163
	movb	%dl, 5(%rbx)	# tmp163,
	movq	%rax, %rdx	# _14, tmp168
	shrq	$40, %rdx	#, tmp168
	movb	%dl, 6(%rbx)	# tmp168,
	movq	%rax, %rdx	# _14, tmp174
	shrq	$48, %rdx	#, tmp174
	movb	%dl, 7(%rbx)	# tmp174,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _14
	je	.L260	#,
# a.out.c:897: }
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 24
	popq	%rbp	#
	.cfi_def_cfa_offset 16
	popq	%r12	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L258:
	.cfi_restore_state
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#,* <retval>
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp181, <retval>
# a.out.c:288:   k->data.i = i;
	movq	$0, 8(%rax)	#,
	jmp	.L253	#
	.p2align 4,,10
	.p2align 3
.L260:
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# c,
	call	k_free	#
# a.out.c:897: }
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 24
	popq	%rbp	#
	.cfi_def_cfa_offset 16
	popq	%r12	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L259:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# b,
	call	k_free	#
	jmp	.L255	#
	.p2align 4,,10
	.p2align 3
.L254:
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#,* <retval>
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp183, <retval>
# a.out.c:288:   k->data.i = i;
	movq	$1, 8(%rax)	#, a_12->data.i
	jmp	.L253	#
	.cfi_endproc
.LFE39:
	.size	kha_extern_96_s_95_eq_impl, .-kha_extern_96_s_95_eq_impl
	.section	.rodata.str1.1
.LC7:
	.string	"INVALID ADDITION\n"
	.text
	.p2align 4
	.globl	kha_extern_96_int_95_add_impl
	.type	kha_extern_96_int_95_add_impl, @function
kha_extern_96_int_95_add_impl:
.LFB40:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 48
# a.out.c:899:   if (b->tag != c->tag || b->tag != INT) {
	movzbl	(%rdi), %eax	# b_8(D)->D.4393.D.4391.tag, _1
# a.out.c:899:   if (b->tag != c->tag || b->tag != INT) {
	cmpb	%al, (%rsi)	# _1, c_9(D)->D.4393.D.4391.tag
	jne	.L266	#,
	cmpb	$4, %al	#, _1
	jne	.L266	#,
	movq	%rdi, %rbp	# tmp188, b
# a.out.c:903:   kha_obj * ret = make_int(b->data.i + c->data.i);
	movq	8(%rsi), %r12	# c_9(D)->data.i, c_9(D)->data.i
	addq	8(%rdi), %r12	# b_8(D)->data.i, _6
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	movq	%rsi, %rbx	# tmp189, c
	call	malloc@PLT	#
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp111
# a.out.c:288:   k->data.i = i;
	movq	%r12, 8(%rax)	# _6, a_16->data.i
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r13	# tmp190, <retval>
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_16]
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *b_8(D), tmp109
	shrq	$8, %rax	#, tmp109
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp111, _15
	andq	%rdx, %rax	# tmp111, _15
	movq	%rax, %rdx	# _15, tmp122
	movb	%al, 1(%rbp)	# _15,
	shrq	$16, %rdx	#, tmp122
	movb	%ah, 2(%rbp)	# _15,
	movb	%dl, 3(%rbp)	# tmp122,
	movq	%rax, %rdx	# _15, tmp127
	shrq	$24, %rdx	#, tmp127
	movb	%dl, 4(%rbp)	# tmp127,
	movq	%rax, %rdx	# _15, tmp132
	shrq	$32, %rdx	#, tmp132
	movb	%dl, 5(%rbp)	# tmp132,
	movq	%rax, %rdx	# _15, tmp137
	shrq	$40, %rdx	#, tmp137
	movb	%dl, 6(%rbp)	# tmp137,
	movq	%rax, %rdx	# _15, tmp143
	shrq	$48, %rdx	#, tmp143
	movb	%dl, 7(%rbp)	# tmp143,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _15
	je	.L268	#,
.L264:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp151
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *c_9(D), tmp149
	shrq	$8, %rax	#, tmp149
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp151, _13
	andq	%rdx, %rax	# tmp151, _13
	movq	%rax, %rdx	# _13, tmp162
	movb	%al, 1(%rbx)	# _13,
	shrq	$16, %rdx	#, tmp162
	movb	%ah, 2(%rbx)	# _13,
	movb	%dl, 3(%rbx)	# tmp162,
	movq	%rax, %rdx	# _13, tmp167
	shrq	$24, %rdx	#, tmp167
	movb	%dl, 4(%rbx)	# tmp167,
	movq	%rax, %rdx	# _13, tmp172
	shrq	$32, %rdx	#, tmp172
	movb	%dl, 5(%rbx)	# tmp172,
	movq	%rax, %rdx	# _13, tmp177
	shrq	$40, %rdx	#, tmp177
	movb	%dl, 6(%rbx)	# tmp177,
	movq	%rax, %rdx	# _13, tmp183
	shrq	$48, %rdx	#, tmp183
	movb	%dl, 7(%rbx)	# tmp183,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _13
	je	.L269	#,
# a.out.c:907: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r13, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L268:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# b,
	call	k_free	#
	jmp	.L264	#
	.p2align 4,,10
	.p2align 3
.L269:
	movq	%rbx, %rdi	# c,
	call	k_free	#
# a.out.c:907: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r13, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
.L266:
	.cfi_restore_state
# a.out.c:900:     fprintf(stderr, "INVALID ADDITION\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$17, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC7(%rip), %rdi	#, tmp103
	call	fwrite@PLT	#
# a.out.c:901:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE40:
	.size	kha_extern_96_int_95_add_impl, .-kha_extern_96_int_95_add_impl
	.section	.rodata.str1.1
.LC8:
	.string	"INVALID SUBTRACTION\n"
	.text
	.p2align 4
	.globl	kha_extern_96_int_95_sub_impl
	.type	kha_extern_96_int_95_sub_impl, @function
kha_extern_96_int_95_sub_impl:
.LFB41:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 48
# a.out.c:911:   if (b->tag != c->tag || b->tag != INT) {
	movzbl	(%rdi), %eax	# b_8(D)->D.4393.D.4391.tag, _1
# a.out.c:911:   if (b->tag != c->tag || b->tag != INT) {
	cmpb	%al, (%rsi)	# _1, c_9(D)->D.4393.D.4391.tag
	jne	.L275	#,
	cmpb	$4, %al	#, _1
	jne	.L275	#,
	movq	%rdi, %rbp	# tmp187, b
# a.out.c:915:   kha_obj * ret = make_int(b->data.i - c->data.i);
	movq	8(%rdi), %r12	# b_8(D)->data.i, b_8(D)->data.i
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:915:   kha_obj * ret = make_int(b->data.i - c->data.i);
	subq	8(%rsi), %r12	# c_9(D)->data.i, _6
	movq	%rsi, %rbx	# tmp188, c
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp110
# a.out.c:288:   k->data.i = i;
	movq	%r12, 8(%rax)	# _6, a_16->data.i
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r13	# tmp189, <retval>
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_16]
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *b_8(D), tmp108
	shrq	$8, %rax	#, tmp108
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp110, _15
	andq	%rdx, %rax	# tmp110, _15
	movq	%rax, %rdx	# _15, tmp121
	movb	%al, 1(%rbp)	# _15,
	shrq	$16, %rdx	#, tmp121
	movb	%ah, 2(%rbp)	# _15,
	movb	%dl, 3(%rbp)	# tmp121,
	movq	%rax, %rdx	# _15, tmp126
	shrq	$24, %rdx	#, tmp126
	movb	%dl, 4(%rbp)	# tmp126,
	movq	%rax, %rdx	# _15, tmp131
	shrq	$32, %rdx	#, tmp131
	movb	%dl, 5(%rbp)	# tmp131,
	movq	%rax, %rdx	# _15, tmp136
	shrq	$40, %rdx	#, tmp136
	movb	%dl, 6(%rbp)	# tmp136,
	movq	%rax, %rdx	# _15, tmp142
	shrq	$48, %rdx	#, tmp142
	movb	%dl, 7(%rbp)	# tmp142,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _15
	je	.L277	#,
.L273:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp150
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *c_9(D), tmp148
	shrq	$8, %rax	#, tmp148
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp150, _13
	andq	%rdx, %rax	# tmp150, _13
	movq	%rax, %rdx	# _13, tmp161
	movb	%al, 1(%rbx)	# _13,
	shrq	$16, %rdx	#, tmp161
	movb	%ah, 2(%rbx)	# _13,
	movb	%dl, 3(%rbx)	# tmp161,
	movq	%rax, %rdx	# _13, tmp166
	shrq	$24, %rdx	#, tmp166
	movb	%dl, 4(%rbx)	# tmp166,
	movq	%rax, %rdx	# _13, tmp171
	shrq	$32, %rdx	#, tmp171
	movb	%dl, 5(%rbx)	# tmp171,
	movq	%rax, %rdx	# _13, tmp176
	shrq	$40, %rdx	#, tmp176
	movb	%dl, 6(%rbx)	# tmp176,
	movq	%rax, %rdx	# _13, tmp182
	shrq	$48, %rdx	#, tmp182
	movb	%dl, 7(%rbx)	# tmp182,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _13
	je	.L278	#,
# a.out.c:919: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r13, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L277:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# b,
	call	k_free	#
	jmp	.L273	#
	.p2align 4,,10
	.p2align 3
.L278:
	movq	%rbx, %rdi	# c,
	call	k_free	#
# a.out.c:919: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r13, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
.L275:
	.cfi_restore_state
# a.out.c:912:     fprintf(stderr, "INVALID SUBTRACTION\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$20, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC8(%rip), %rdi	#, tmp103
	call	fwrite@PLT	#
# a.out.c:913:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE41:
	.size	kha_extern_96_int_95_sub_impl, .-kha_extern_96_int_95_sub_impl
	.section	.rodata.str1.1
.LC9:
	.string	"INVALID MULT\n"
	.text
	.p2align 4
	.globl	kha_extern_96_int_95_mul_impl
	.type	kha_extern_96_int_95_mul_impl, @function
kha_extern_96_int_95_mul_impl:
.LFB42:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 48
# a.out.c:922:   if (b->tag != c->tag || b->tag != INT) {
	movzbl	(%rdi), %eax	# b_8(D)->D.4393.D.4391.tag, _1
# a.out.c:922:   if (b->tag != c->tag || b->tag != INT) {
	cmpb	%al, (%rsi)	# _1, c_9(D)->D.4393.D.4391.tag
	jne	.L284	#,
	cmpb	$4, %al	#, _1
	jne	.L284	#,
# a.out.c:926:   kha_obj * ret = make_int(b->data.i * c->data.i);
	movq	8(%rdi), %r12	# b_8(D)->data.i, b_8(D)->data.i
	imulq	8(%rsi), %r12	# c_9(D)->data.i, _6
	movq	%rdi, %rbp	# tmp187, b
	movq	%rsi, %rbx	# tmp188, c
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp110
# a.out.c:288:   k->data.i = i;
	movq	%r12, 8(%rax)	# _6, a_16->data.i
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r13	# tmp189, <retval>
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_16]
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *b_8(D), tmp108
	shrq	$8, %rax	#, tmp108
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp110, _15
	andq	%rdx, %rax	# tmp110, _15
	movq	%rax, %rdx	# _15, tmp121
	movb	%al, 1(%rbp)	# _15,
	shrq	$16, %rdx	#, tmp121
	movb	%ah, 2(%rbp)	# _15,
	movb	%dl, 3(%rbp)	# tmp121,
	movq	%rax, %rdx	# _15, tmp126
	shrq	$24, %rdx	#, tmp126
	movb	%dl, 4(%rbp)	# tmp126,
	movq	%rax, %rdx	# _15, tmp131
	shrq	$32, %rdx	#, tmp131
	movb	%dl, 5(%rbp)	# tmp131,
	movq	%rax, %rdx	# _15, tmp136
	shrq	$40, %rdx	#, tmp136
	movb	%dl, 6(%rbp)	# tmp136,
	movq	%rax, %rdx	# _15, tmp142
	shrq	$48, %rdx	#, tmp142
	movb	%dl, 7(%rbp)	# tmp142,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _15
	je	.L286	#,
.L282:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp150
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *c_9(D), tmp148
	shrq	$8, %rax	#, tmp148
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp150, _13
	andq	%rdx, %rax	# tmp150, _13
	movq	%rax, %rdx	# _13, tmp161
	movb	%al, 1(%rbx)	# _13,
	shrq	$16, %rdx	#, tmp161
	movb	%ah, 2(%rbx)	# _13,
	movb	%dl, 3(%rbx)	# tmp161,
	movq	%rax, %rdx	# _13, tmp166
	shrq	$24, %rdx	#, tmp166
	movb	%dl, 4(%rbx)	# tmp166,
	movq	%rax, %rdx	# _13, tmp171
	shrq	$32, %rdx	#, tmp171
	movb	%dl, 5(%rbx)	# tmp171,
	movq	%rax, %rdx	# _13, tmp176
	shrq	$40, %rdx	#, tmp176
	movb	%dl, 6(%rbx)	# tmp176,
	movq	%rax, %rdx	# _13, tmp182
	shrq	$48, %rdx	#, tmp182
	movb	%dl, 7(%rbx)	# tmp182,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _13
	je	.L287	#,
# a.out.c:930: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r13, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L286:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# b,
	call	k_free	#
	jmp	.L282	#
	.p2align 4,,10
	.p2align 3
.L287:
	movq	%rbx, %rdi	# c,
	call	k_free	#
# a.out.c:930: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r13, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
.L284:
	.cfi_restore_state
# a.out.c:923:     fprintf(stderr, "INVALID MULT\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$13, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC9(%rip), %rdi	#, tmp103
	call	fwrite@PLT	#
# a.out.c:924:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE42:
	.size	kha_extern_96_int_95_mul_impl, .-kha_extern_96_int_95_mul_impl
	.section	.rodata.str1.1
.LC10:
	.string	"INVALID DIV\n"
	.text
	.p2align 4
	.globl	kha_extern_96_int_95_div_impl
	.type	kha_extern_96_int_95_div_impl, @function
kha_extern_96_int_95_div_impl:
.LFB43:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 48
# a.out.c:933:   if (b->tag != c->tag || b->tag != INT) {
	movzbl	(%rdi), %eax	# b_8(D)->D.4393.D.4391.tag, _1
# a.out.c:933:   if (b->tag != c->tag || b->tag != INT) {
	cmpb	%al, (%rsi)	# _1, c_9(D)->D.4393.D.4391.tag
	jne	.L293	#,
	cmpb	$4, %al	#, _1
	jne	.L293	#,
# a.out.c:937:   kha_obj * ret = make_int((i64) b->data.i / c->data.i);
	movq	8(%rdi), %rax	# b_8(D)->data.i, b_8(D)->data.i
	movq	%rdi, %rbp	# tmp189, b
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	movq	%rsi, %rbx	# tmp190, c
# a.out.c:937:   kha_obj * ret = make_int((i64) b->data.i / c->data.i);
	cqto
	idivq	8(%rsi)	# c_9(D)->data.i
	movq	%rax, %r12	# b_8(D)->data.i, tmp104
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp112
# a.out.c:288:   k->data.i = i;
	movq	%r12, 8(%rax)	# tmp104, a_16->data.i
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r13	# tmp191, <retval>
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_16]
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *b_8(D), tmp110
	shrq	$8, %rax	#, tmp110
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp112, _15
	andq	%rdx, %rax	# tmp112, _15
	movq	%rax, %rdx	# _15, tmp123
	movb	%al, 1(%rbp)	# _15,
	shrq	$16, %rdx	#, tmp123
	movb	%ah, 2(%rbp)	# _15,
	movb	%dl, 3(%rbp)	# tmp123,
	movq	%rax, %rdx	# _15, tmp128
	shrq	$24, %rdx	#, tmp128
	movb	%dl, 4(%rbp)	# tmp128,
	movq	%rax, %rdx	# _15, tmp133
	shrq	$32, %rdx	#, tmp133
	movb	%dl, 5(%rbp)	# tmp133,
	movq	%rax, %rdx	# _15, tmp138
	shrq	$40, %rdx	#, tmp138
	movb	%dl, 6(%rbp)	# tmp138,
	movq	%rax, %rdx	# _15, tmp144
	shrq	$48, %rdx	#, tmp144
	movb	%dl, 7(%rbp)	# tmp144,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _15
	je	.L295	#,
.L291:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp152
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *c_9(D), tmp150
	shrq	$8, %rax	#, tmp150
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp152, _13
	andq	%rdx, %rax	# tmp152, _13
	movq	%rax, %rdx	# _13, tmp163
	movb	%al, 1(%rbx)	# _13,
	shrq	$16, %rdx	#, tmp163
	movb	%ah, 2(%rbx)	# _13,
	movb	%dl, 3(%rbx)	# tmp163,
	movq	%rax, %rdx	# _13, tmp168
	shrq	$24, %rdx	#, tmp168
	movb	%dl, 4(%rbx)	# tmp168,
	movq	%rax, %rdx	# _13, tmp173
	shrq	$32, %rdx	#, tmp173
	movb	%dl, 5(%rbx)	# tmp173,
	movq	%rax, %rdx	# _13, tmp178
	shrq	$40, %rdx	#, tmp178
	movb	%dl, 6(%rbx)	# tmp178,
	movq	%rax, %rdx	# _13, tmp184
	shrq	$48, %rdx	#, tmp184
	movb	%dl, 7(%rbx)	# tmp184,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _13
	je	.L296	#,
# a.out.c:941: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r13, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L295:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# b,
	call	k_free	#
	jmp	.L291	#
	.p2align 4,,10
	.p2align 3
.L296:
	movq	%rbx, %rdi	# c,
	call	k_free	#
# a.out.c:941: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r13, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
.L293:
	.cfi_restore_state
# a.out.c:934:     fprintf(stderr, "INVALID DIV\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$12, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC10(%rip), %rdi	#, tmp103
	call	fwrite@PLT	#
# a.out.c:935:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE43:
	.size	kha_extern_96_int_95_div_impl, .-kha_extern_96_int_95_div_impl
	.section	.rodata.str1.1
.LC11:
	.string	"INVALID FADDITION\n"
	.text
	.p2align 4
	.globl	kha_extern_96_float_95_add_impl
	.type	kha_extern_96_float_95_add_impl, @function
kha_extern_96_float_95_add_impl:
.LFB44:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 48
# a.out.c:945:   if (b->tag != c->tag || b->tag != FLOAT) {
	movzbl	(%rdi), %eax	# b_9(D)->D.4393.D.4391.tag, _1
# a.out.c:945:   if (b->tag != c->tag || b->tag != FLOAT) {
	cmpb	%al, (%rsi)	# _1, c_10(D)->D.4393.D.4391.tag
	jne	.L302	#,
	cmpb	$5, %al	#, _1
	jne	.L302	#,
# a.out.c:949:   kha_obj * ret = make_int(b->data.f + c->data.f);
	movsd	8(%rdi), %xmm0	# b_9(D)->data.f, b_9(D)->data.f
	addsd	8(%rsi), %xmm0	# c_10(D)->data.f, tmp105
	movq	%rdi, %rbp	# tmp189, b
	movq	%rsi, %rbx	# tmp190, c
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:949:   kha_obj * ret = make_int(b->data.f + c->data.f);
	cvttsd2siq	%xmm0, %r13	# tmp105, _7
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp112
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_17]
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp191, <retval>
# a.out.c:288:   k->data.i = i;
	movq	%r13, 8(%rax)	# _7, a_17->data.i
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *b_9(D), tmp110
	shrq	$8, %rax	#, tmp110
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp112, _16
	andq	%rdx, %rax	# tmp112, _16
	movq	%rax, %rdx	# _16, tmp123
	movb	%al, 1(%rbp)	# _16,
	shrq	$16, %rdx	#, tmp123
	movb	%ah, 2(%rbp)	# _16,
	movb	%dl, 3(%rbp)	# tmp123,
	movq	%rax, %rdx	# _16, tmp128
	shrq	$24, %rdx	#, tmp128
	movb	%dl, 4(%rbp)	# tmp128,
	movq	%rax, %rdx	# _16, tmp133
	shrq	$32, %rdx	#, tmp133
	movb	%dl, 5(%rbp)	# tmp133,
	movq	%rax, %rdx	# _16, tmp138
	shrq	$40, %rdx	#, tmp138
	movb	%dl, 6(%rbp)	# tmp138,
	movq	%rax, %rdx	# _16, tmp144
	shrq	$48, %rdx	#, tmp144
	movb	%dl, 7(%rbp)	# tmp144,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _16
	je	.L304	#,
.L300:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp152
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *c_10(D), tmp150
	shrq	$8, %rax	#, tmp150
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp152, _14
	andq	%rdx, %rax	# tmp152, _14
	movq	%rax, %rdx	# _14, tmp163
	movb	%al, 1(%rbx)	# _14,
	shrq	$16, %rdx	#, tmp163
	movb	%ah, 2(%rbx)	# _14,
	movb	%dl, 3(%rbx)	# tmp163,
	movq	%rax, %rdx	# _14, tmp168
	shrq	$24, %rdx	#, tmp168
	movb	%dl, 4(%rbx)	# tmp168,
	movq	%rax, %rdx	# _14, tmp173
	shrq	$32, %rdx	#, tmp173
	movb	%dl, 5(%rbx)	# tmp173,
	movq	%rax, %rdx	# _14, tmp178
	shrq	$40, %rdx	#, tmp178
	movb	%dl, 6(%rbx)	# tmp178,
	movq	%rax, %rdx	# _14, tmp184
	shrq	$48, %rdx	#, tmp184
	movb	%dl, 7(%rbx)	# tmp184,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _14
	je	.L305	#,
# a.out.c:953: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L304:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# b,
	call	k_free	#
	jmp	.L300	#
	.p2align 4,,10
	.p2align 3
.L305:
	movq	%rbx, %rdi	# c,
	call	k_free	#
# a.out.c:953: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
.L302:
	.cfi_restore_state
# a.out.c:946:     fprintf(stderr, "INVALID FADDITION\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$18, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC11(%rip), %rdi	#, tmp104
	call	fwrite@PLT	#
# a.out.c:947:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE44:
	.size	kha_extern_96_float_95_add_impl, .-kha_extern_96_float_95_add_impl
	.section	.rodata.str1.1
.LC12:
	.string	"INVALID FSUBTRACTION\n"
	.text
	.p2align 4
	.globl	kha_extern_96_float_95_sub_impl
	.type	kha_extern_96_float_95_sub_impl, @function
kha_extern_96_float_95_sub_impl:
.LFB45:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 48
# a.out.c:957:   if (b->tag != c->tag || b->tag != FLOAT) {
	movzbl	(%rdi), %eax	# b_9(D)->D.4393.D.4391.tag, _1
# a.out.c:957:   if (b->tag != c->tag || b->tag != FLOAT) {
	cmpb	%al, (%rsi)	# _1, c_10(D)->D.4393.D.4391.tag
	jne	.L311	#,
	cmpb	$5, %al	#, _1
	jne	.L311	#,
# a.out.c:961:   kha_obj * ret = make_int(b->data.f - c->data.f);
	movsd	8(%rdi), %xmm0	# b_9(D)->data.f, b_9(D)->data.f
	subsd	8(%rsi), %xmm0	# c_10(D)->data.f, tmp105
	movq	%rdi, %rbp	# tmp189, b
	movq	%rsi, %rbx	# tmp190, c
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:961:   kha_obj * ret = make_int(b->data.f - c->data.f);
	cvttsd2siq	%xmm0, %r13	# tmp105, _7
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp112
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_17]
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp191, <retval>
# a.out.c:288:   k->data.i = i;
	movq	%r13, 8(%rax)	# _7, a_17->data.i
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *b_9(D), tmp110
	shrq	$8, %rax	#, tmp110
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp112, _16
	andq	%rdx, %rax	# tmp112, _16
	movq	%rax, %rdx	# _16, tmp123
	movb	%al, 1(%rbp)	# _16,
	shrq	$16, %rdx	#, tmp123
	movb	%ah, 2(%rbp)	# _16,
	movb	%dl, 3(%rbp)	# tmp123,
	movq	%rax, %rdx	# _16, tmp128
	shrq	$24, %rdx	#, tmp128
	movb	%dl, 4(%rbp)	# tmp128,
	movq	%rax, %rdx	# _16, tmp133
	shrq	$32, %rdx	#, tmp133
	movb	%dl, 5(%rbp)	# tmp133,
	movq	%rax, %rdx	# _16, tmp138
	shrq	$40, %rdx	#, tmp138
	movb	%dl, 6(%rbp)	# tmp138,
	movq	%rax, %rdx	# _16, tmp144
	shrq	$48, %rdx	#, tmp144
	movb	%dl, 7(%rbp)	# tmp144,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _16
	je	.L313	#,
.L309:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp152
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *c_10(D), tmp150
	shrq	$8, %rax	#, tmp150
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp152, _14
	andq	%rdx, %rax	# tmp152, _14
	movq	%rax, %rdx	# _14, tmp163
	movb	%al, 1(%rbx)	# _14,
	shrq	$16, %rdx	#, tmp163
	movb	%ah, 2(%rbx)	# _14,
	movb	%dl, 3(%rbx)	# tmp163,
	movq	%rax, %rdx	# _14, tmp168
	shrq	$24, %rdx	#, tmp168
	movb	%dl, 4(%rbx)	# tmp168,
	movq	%rax, %rdx	# _14, tmp173
	shrq	$32, %rdx	#, tmp173
	movb	%dl, 5(%rbx)	# tmp173,
	movq	%rax, %rdx	# _14, tmp178
	shrq	$40, %rdx	#, tmp178
	movb	%dl, 6(%rbx)	# tmp178,
	movq	%rax, %rdx	# _14, tmp184
	shrq	$48, %rdx	#, tmp184
	movb	%dl, 7(%rbx)	# tmp184,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _14
	je	.L314	#,
# a.out.c:964: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L313:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# b,
	call	k_free	#
	jmp	.L309	#
	.p2align 4,,10
	.p2align 3
.L314:
	movq	%rbx, %rdi	# c,
	call	k_free	#
# a.out.c:964: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
.L311:
	.cfi_restore_state
# a.out.c:958:     fprintf(stderr, "INVALID FSUBTRACTION\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$21, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC12(%rip), %rdi	#, tmp104
	call	fwrite@PLT	#
# a.out.c:959:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE45:
	.size	kha_extern_96_float_95_sub_impl, .-kha_extern_96_float_95_sub_impl
	.section	.rodata.str1.1
.LC13:
	.string	"INVALID FMULT\n"
	.text
	.p2align 4
	.globl	kha_extern_96_float_95_mul_impl
	.type	kha_extern_96_float_95_mul_impl, @function
kha_extern_96_float_95_mul_impl:
.LFB46:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 48
# a.out.c:967:   if (b->tag != c->tag || b->tag != FLOAT) {
	movzbl	(%rdi), %eax	# b_9(D)->D.4393.D.4391.tag, _1
# a.out.c:967:   if (b->tag != c->tag || b->tag != FLOAT) {
	cmpb	%al, (%rsi)	# _1, c_10(D)->D.4393.D.4391.tag
	jne	.L320	#,
	cmpb	$5, %al	#, _1
	jne	.L320	#,
# a.out.c:971:   kha_obj * ret = make_int(b->data.f * c->data.f);
	movsd	8(%rdi), %xmm0	# b_9(D)->data.f, b_9(D)->data.f
	mulsd	8(%rsi), %xmm0	# c_10(D)->data.f, tmp105
	movq	%rdi, %rbp	# tmp189, b
	movq	%rsi, %rbx	# tmp190, c
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:971:   kha_obj * ret = make_int(b->data.f * c->data.f);
	cvttsd2siq	%xmm0, %r13	# tmp105, _7
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp112
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_17]
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp191, <retval>
# a.out.c:288:   k->data.i = i;
	movq	%r13, 8(%rax)	# _7, a_17->data.i
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *b_9(D), tmp110
	shrq	$8, %rax	#, tmp110
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp112, _16
	andq	%rdx, %rax	# tmp112, _16
	movq	%rax, %rdx	# _16, tmp123
	movb	%al, 1(%rbp)	# _16,
	shrq	$16, %rdx	#, tmp123
	movb	%ah, 2(%rbp)	# _16,
	movb	%dl, 3(%rbp)	# tmp123,
	movq	%rax, %rdx	# _16, tmp128
	shrq	$24, %rdx	#, tmp128
	movb	%dl, 4(%rbp)	# tmp128,
	movq	%rax, %rdx	# _16, tmp133
	shrq	$32, %rdx	#, tmp133
	movb	%dl, 5(%rbp)	# tmp133,
	movq	%rax, %rdx	# _16, tmp138
	shrq	$40, %rdx	#, tmp138
	movb	%dl, 6(%rbp)	# tmp138,
	movq	%rax, %rdx	# _16, tmp144
	shrq	$48, %rdx	#, tmp144
	movb	%dl, 7(%rbp)	# tmp144,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _16
	je	.L322	#,
.L318:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp152
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *c_10(D), tmp150
	shrq	$8, %rax	#, tmp150
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp152, _14
	andq	%rdx, %rax	# tmp152, _14
	movq	%rax, %rdx	# _14, tmp163
	movb	%al, 1(%rbx)	# _14,
	shrq	$16, %rdx	#, tmp163
	movb	%ah, 2(%rbx)	# _14,
	movb	%dl, 3(%rbx)	# tmp163,
	movq	%rax, %rdx	# _14, tmp168
	shrq	$24, %rdx	#, tmp168
	movb	%dl, 4(%rbx)	# tmp168,
	movq	%rax, %rdx	# _14, tmp173
	shrq	$32, %rdx	#, tmp173
	movb	%dl, 5(%rbx)	# tmp173,
	movq	%rax, %rdx	# _14, tmp178
	shrq	$40, %rdx	#, tmp178
	movb	%dl, 6(%rbx)	# tmp178,
	movq	%rax, %rdx	# _14, tmp184
	shrq	$48, %rdx	#, tmp184
	movb	%dl, 7(%rbx)	# tmp184,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _14
	je	.L323	#,
# a.out.c:975: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L322:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# b,
	call	k_free	#
	jmp	.L318	#
	.p2align 4,,10
	.p2align 3
.L323:
	movq	%rbx, %rdi	# c,
	call	k_free	#
# a.out.c:975: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
.L320:
	.cfi_restore_state
# a.out.c:968:     fprintf(stderr, "INVALID FMULT\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$14, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC13(%rip), %rdi	#, tmp104
	call	fwrite@PLT	#
# a.out.c:969:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE46:
	.size	kha_extern_96_float_95_mul_impl, .-kha_extern_96_float_95_mul_impl
	.section	.rodata.str1.1
.LC14:
	.string	"INVALID FDIV\n"
	.text
	.p2align 4
	.globl	kha_extern_96_float_95_div_impl
	.type	kha_extern_96_float_95_div_impl, @function
kha_extern_96_float_95_div_impl:
.LFB47:
	.cfi_startproc
	pushq	%r13	#
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	pushq	%r12	#
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	pushq	%rbp	#
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	pushq	%rbx	#
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 48
# a.out.c:978:   if (b->tag != c->tag || b->tag != FLOAT) {
	movzbl	(%rdi), %eax	# b_9(D)->D.4393.D.4391.tag, _1
# a.out.c:978:   if (b->tag != c->tag || b->tag != FLOAT) {
	cmpb	%al, (%rsi)	# _1, c_10(D)->D.4393.D.4391.tag
	jne	.L329	#,
	cmpb	$5, %al	#, _1
	jne	.L329	#,
# a.out.c:982:   kha_obj * ret = make_int((f64) b->data.f / c->data.f);
	movsd	8(%rdi), %xmm0	# b_9(D)->data.f, b_9(D)->data.f
	divsd	8(%rsi), %xmm0	# c_10(D)->data.f, tmp105
	movq	%rdi, %rbp	# tmp189, b
	movq	%rsi, %rbx	# tmp190, c
# a.out.c:982:   kha_obj * ret = make_int((f64) b->data.f / c->data.f);
	cvttsd2siq	%xmm0, %r13	# tmp105, _7
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp112
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_17]
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp191, <retval>
# a.out.c:288:   k->data.i = i;
	movq	%r13, 8(%rax)	# _7, a_17->data.i
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *b_9(D), tmp110
	shrq	$8, %rax	#, tmp110
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp112, _16
	andq	%rdx, %rax	# tmp112, _16
	movq	%rax, %rdx	# _16, tmp123
	movb	%al, 1(%rbp)	# _16,
	shrq	$16, %rdx	#, tmp123
	movb	%ah, 2(%rbp)	# _16,
	movb	%dl, 3(%rbp)	# tmp123,
	movq	%rax, %rdx	# _16, tmp128
	shrq	$24, %rdx	#, tmp128
	movb	%dl, 4(%rbp)	# tmp128,
	movq	%rax, %rdx	# _16, tmp133
	shrq	$32, %rdx	#, tmp133
	movb	%dl, 5(%rbp)	# tmp133,
	movq	%rax, %rdx	# _16, tmp138
	shrq	$40, %rdx	#, tmp138
	movb	%dl, 6(%rbp)	# tmp138,
	movq	%rax, %rdx	# _16, tmp144
	shrq	$48, %rdx	#, tmp144
	movb	%dl, 7(%rbp)	# tmp144,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _16
	je	.L331	#,
.L327:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp152
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *c_10(D), tmp150
	shrq	$8, %rax	#, tmp150
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp152, _14
	andq	%rdx, %rax	# tmp152, _14
	movq	%rax, %rdx	# _14, tmp163
	movb	%al, 1(%rbx)	# _14,
	shrq	$16, %rdx	#, tmp163
	movb	%ah, 2(%rbx)	# _14,
	movb	%dl, 3(%rbx)	# tmp163,
	movq	%rax, %rdx	# _14, tmp168
	shrq	$24, %rdx	#, tmp168
	movb	%dl, 4(%rbx)	# tmp168,
	movq	%rax, %rdx	# _14, tmp173
	shrq	$32, %rdx	#, tmp173
	movb	%dl, 5(%rbx)	# tmp173,
	movq	%rax, %rdx	# _14, tmp178
	shrq	$40, %rdx	#, tmp178
	movb	%dl, 6(%rbx)	# tmp178,
	movq	%rax, %rdx	# _14, tmp184
	shrq	$48, %rdx	#, tmp184
	movb	%dl, 7(%rbx)	# tmp184,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _14
	je	.L332	#,
# a.out.c:986: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L331:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# b,
	call	k_free	#
	jmp	.L327	#
	.p2align 4,,10
	.p2align 3
.L332:
	movq	%rbx, %rdi	# c,
	call	k_free	#
# a.out.c:986: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 32
	popq	%rbp	#
	.cfi_def_cfa_offset 24
	popq	%r12	#
	.cfi_def_cfa_offset 16
	popq	%r13	#
	.cfi_def_cfa_offset 8
	ret	
.L329:
	.cfi_restore_state
# a.out.c:979:     fprintf(stderr, "INVALID FDIV\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$13, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC14(%rip), %rdi	#, tmp104
	call	fwrite@PLT	#
# a.out.c:980:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE47:
	.size	kha_extern_96_float_95_div_impl, .-kha_extern_96_float_95_div_impl
	.section	.rodata.str1.1
.LC15:
	.string	"INVALID PRINT INT\n"
.LC16:
	.string	"%ld\n"
	.text
	.p2align 4
	.globl	kha_extern_96_print_95_int_impl
	.type	kha_extern_96_print_95_int_impl, @function
kha_extern_96_print_95_int_impl:
.LFB48:
	.cfi_startproc
	pushq	%rbx	#
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
# a.out.c:989:   if (b->tag != INT) {
	cmpb	$4, (%rdi)	#, b_6(D)->D.4393.D.4391.tag
# a.out.c:988: KHASM_ENTRY(kha_extern_96_print_95_int, 1, kha_obj *b) {
	movq	%rdi, %rbx	# tmp133, b
# a.out.c:989:   if (b->tag != INT) {
	je	.L334	#,
# a.out.c:990:     fprintf(stderr, "INVALID PRINT INT\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$18, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC15(%rip), %rdi	#, tmp90
	call	fwrite@PLT	#
.L334:
# a.out.c:992:   printf("%ld\n", b->data.i);
	movq	8(%rbx), %rsi	# b_6(D)->data.i, b_6(D)->data.i
	leaq	.LC16(%rip), %rdi	#, tmp92
	xorl	%eax, %eax	#
	call	printf@PLT	#
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *b_6(D), tmp95
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp97
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rax	#, tmp95
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp97, _12
	andq	%rdx, %rax	# tmp97, _12
	movq	%rax, %rdx	# _12, tmp108
	movb	%al, 1(%rbx)	# _12,
	shrq	$16, %rdx	#, tmp108
	movb	%ah, 2(%rbx)	# _12,
	movb	%dl, 3(%rbx)	# tmp108,
	movq	%rax, %rdx	# _12, tmp113
	shrq	$24, %rdx	#, tmp113
	movb	%dl, 4(%rbx)	# tmp113,
	movq	%rax, %rdx	# _12, tmp118
	shrq	$32, %rdx	#, tmp118
	movb	%dl, 5(%rbx)	# tmp118,
	movq	%rax, %rdx	# _12, tmp123
	shrq	$40, %rdx	#, tmp123
	movb	%dl, 6(%rbx)	# tmp123,
	movq	%rax, %rdx	# _12, tmp129
	shrq	$48, %rdx	#, tmp129
	movb	%dl, 7(%rbx)	# tmp129,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _12
	je	.L337	#,
# a.out.c:994:   return make_tuple(0, NULL);
	xorl	%esi, %esi	#
	xorl	%edi, %edi	#
	xorl	%eax, %eax	#
# a.out.c:995: }
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 8
# a.out.c:994:   return make_tuple(0, NULL);
	jmp	make_tuple.constprop.0	#
	.p2align 4,,10
	.p2align 3
.L337:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# b,
	call	k_free	#
# a.out.c:994:   return make_tuple(0, NULL);
	xorl	%esi, %esi	#
	xorl	%edi, %edi	#
	xorl	%eax, %eax	#
# a.out.c:995: }
	popq	%rbx	#
	.cfi_def_cfa_offset 8
# a.out.c:994:   return make_tuple(0, NULL);
	jmp	make_tuple.constprop.0	#
	.cfi_endproc
.LFE48:
	.size	kha_extern_96_print_95_int_impl, .-kha_extern_96_print_95_int_impl
	.section	.rodata.str1.1
.LC17:
	.string	"INVALID PRINT STR\n"
	.text
	.p2align 4
	.globl	kha_extern_96_print_95_str_impl
	.type	kha_extern_96_print_95_str_impl, @function
kha_extern_96_print_95_str_impl:
.LFB49:
	.cfi_startproc
	pushq	%rbx	#
	.cfi_def_cfa_offset 16
	.cfi_offset 3, -16
# a.out.c:998:   if (b->tag != STR) {
	cmpb	$6, (%rdi)	#, b_7(D)->D.4393.D.4391.tag
# a.out.c:997: KHASM_ENTRY(kha_extern_96_print_95_str, 1, kha_obj *b) {
	movq	%rdi, %rbx	# tmp134, b
# a.out.c:998:   if (b->tag != STR) {
	je	.L339	#,
# a.out.c:999:     fprintf(stderr, "INVALID PRINT STR\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$18, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC17(%rip), %rdi	#, tmp91
	call	fwrite@PLT	#
.L339:
# a.out.c:1001:   printf("%s\n", b->data.str->data);
	movq	8(%rbx), %rax	# b_7(D)->data.str, b_7(D)->data.str
	movq	(%rax), %rdi	# _3->data, _3->data
	call	puts@PLT	#
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *b_7(D), tmp96
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp98
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rax	#, tmp96
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp98, _13
	andq	%rdx, %rax	# tmp98, _13
	movq	%rax, %rdx	# _13, tmp109
	movb	%al, 1(%rbx)	# _13,
	shrq	$16, %rdx	#, tmp109
	movb	%ah, 2(%rbx)	# _13,
	movb	%dl, 3(%rbx)	# tmp109,
	movq	%rax, %rdx	# _13, tmp114
	shrq	$24, %rdx	#, tmp114
	movb	%dl, 4(%rbx)	# tmp114,
	movq	%rax, %rdx	# _13, tmp119
	shrq	$32, %rdx	#, tmp119
	movb	%dl, 5(%rbx)	# tmp119,
	movq	%rax, %rdx	# _13, tmp124
	shrq	$40, %rdx	#, tmp124
	movb	%dl, 6(%rbx)	# tmp124,
	movq	%rax, %rdx	# _13, tmp130
	shrq	$48, %rdx	#, tmp130
	movb	%dl, 7(%rbx)	# tmp130,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _13
	je	.L342	#,
# a.out.c:1003:   return make_tuple(0, NULL);
	xorl	%esi, %esi	#
	xorl	%edi, %edi	#
	xorl	%eax, %eax	#
# a.out.c:1004: }
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 8
# a.out.c:1003:   return make_tuple(0, NULL);
	jmp	make_tuple.constprop.0	#
	.p2align 4,,10
	.p2align 3
.L342:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# b,
	call	k_free	#
# a.out.c:1003:   return make_tuple(0, NULL);
	xorl	%esi, %esi	#
	xorl	%edi, %edi	#
	xorl	%eax, %eax	#
# a.out.c:1004: }
	popq	%rbx	#
	.cfi_def_cfa_offset 8
# a.out.c:1003:   return make_tuple(0, NULL);
	jmp	make_tuple.constprop.0	#
	.cfi_endproc
.LFE49:
	.size	kha_extern_96_print_95_str_impl, .-kha_extern_96_print_95_str_impl
	.section	.rodata.str1.1
.LC18:
	.string	"CAN'T TUPACC NONTUP\n"
.LC19:
	.string	"CAN'T TUPACC WITH NONINT\n"
	.text
	.p2align 4
	.globl	khasm_tuple_acc_impl
	.type	khasm_tuple_acc_impl, @function
khasm_tuple_acc_impl:
.LFB50:
	.cfi_startproc
	pushq	%rbp	#
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsi, %rbp	# tmp189, t
	pushq	%rbx	#
	.cfi_def_cfa_offset 24
	.cfi_offset 3, -24
	movq	%rdi, %rbx	# tmp188, b
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 32
# a.out.c:1007:   if (t->tag != TUPLE) {
	cmpb	$7, (%rsi)	#, t_14(D)->D.4393.D.4391.tag
	je	.L344	#,
# a.out.c:1008:     fprintf(stderr, "CAN'T TUPACC NONTUP\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$20, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC18(%rip), %rdi	#, tmp100
	call	fwrite@PLT	#
.L344:
# a.out.c:1010:   if (b->tag != INT) {
	cmpb	$4, (%rbx)	#, b_16(D)->D.4393.D.4391.tag
	je	.L345	#,
# a.out.c:1011:     fprintf(stderr, "CAN'T TUPACC WITH NONINT\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$25, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC19(%rip), %rdi	#, tmp102
	call	fwrite@PLT	#
.L345:
# a.out.c:1013:   kha_obj *tmp = t->data.tuple->tups[b->data.i];
	movq	8(%rbp), %rax	# t_14(D)->data.tuple, t_14(D)->data.tuple
# a.out.c:1013:   kha_obj *tmp = t->data.tuple->tups[b->data.i];
	movq	8(%rbx), %rdx	# b_16(D)->data.i, b_16(D)->data.i
# a.out.c:1013:   kha_obj *tmp = t->data.tuple->tups[b->data.i];
	movq	8(%rax), %rax	# _5->tups, _5->tups
	movq	(%rax,%rdx,8), %rbp	# *_10, <retval>
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *b_16(D), tmp108
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp110
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rax	#, tmp108
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp110, _22
	andq	%rdx, %rax	# tmp110, _22
	movq	%rax, %rdx	# _22, tmp121
	movb	%al, 1(%rbx)	# _22,
	shrq	$16, %rdx	#, tmp121
	movb	%ah, 2(%rbx)	# _22,
	movb	%dl, 3(%rbx)	# tmp121,
	movq	%rax, %rdx	# _22, tmp126
	shrq	$24, %rdx	#, tmp126
	movb	%dl, 4(%rbx)	# tmp126,
	movq	%rax, %rdx	# _22, tmp131
	shrq	$32, %rdx	#, tmp131
	movb	%dl, 5(%rbx)	# tmp131,
	movq	%rax, %rdx	# _22, tmp136
	shrq	$40, %rdx	#, tmp136
	movb	%dl, 6(%rbx)	# tmp136,
	movq	%rax, %rdx	# _22, tmp142
	shrq	$48, %rdx	#, tmp142
	movb	%dl, 7(%rbx)	# tmp142,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _22
	je	.L349	#,
.L346:
# a.out.c:196:   if (!a) {
	testq	%rbp, %rbp	# <retval>
	je	.L350	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %rdx	#, tmp152
# a.out.c:200:   a->gc += 1;
	movq	0(%rbp), %rax	# *tmp_18, tmp148
	shrq	$8, %rax	#, tmp148
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp150
	andq	%rdx, %rax	# tmp152, tmp151
	movq	%rax, %rdx	# tmp151, tmp162
	movb	%al, 1(%rbp)	# tmp151,
	shrq	$16, %rdx	#, tmp162
	movb	%ah, 2(%rbp)	# tmp151,
	movb	%dl, 3(%rbp)	# tmp162,
	movq	%rax, %rdx	# tmp151, tmp167
	shrq	$24, %rdx	#, tmp167
	movb	%dl, 4(%rbp)	# tmp167,
	movq	%rax, %rdx	# tmp151, tmp172
	shrq	$32, %rdx	#, tmp172
	movb	%dl, 5(%rbp)	# tmp172,
	movq	%rax, %rdx	# tmp151, tmp177
	shrq	$48, %rax	#, tmp183
	shrq	$40, %rdx	#, tmp177
	movb	%al, 7(%rbp)	# tmp183,
# a.out.c:1016: }
	movq	%rbp, %rax	# <retval>,
# a.out.c:200:   a->gc += 1;
	movb	%dl, 6(%rbp)	# tmp177,
# a.out.c:1016: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 24
	popq	%rbx	#
	.cfi_def_cfa_offset 16
	popq	%rbp	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L349:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# b,
	call	k_free	#
	jmp	.L346	#
.L350:
	call	ref.part.0	#
	.cfi_endproc
.LFE50:
	.size	khasm_tuple_acc_impl, .-khasm_tuple_acc_impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__61__impl
	.type	khasm_46_Stdlib_46__61__impl, @function
khasm_46_Stdlib_46__61__impl:
.LFB51:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_s_95_eq@GOTPCREL(%rip), %rdx	#, tmp85
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_2]
# a.out.c:274:   k->data.ptr = p;
	movq	%rdx, 8(%rax)	# tmp85, a_2->data.ptr
# a.out.c:1049: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE51:
	.size	khasm_46_Stdlib_46__61__impl, .-khasm_46_Stdlib_46__61__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__43__impl
	.type	khasm_46_Stdlib_46__43__impl, @function
khasm_46_Stdlib_46__43__impl:
.LFB52:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_int_95_add@GOTPCREL(%rip), %rdx	#, tmp85
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_2]
# a.out.c:274:   k->data.ptr = p;
	movq	%rdx, 8(%rax)	# tmp85, a_2->data.ptr
# a.out.c:1057: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE52:
	.size	khasm_46_Stdlib_46__43__impl, .-khasm_46_Stdlib_46__43__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__45__impl
	.type	khasm_46_Stdlib_46__45__impl, @function
khasm_46_Stdlib_46__45__impl:
.LFB53:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_int_95_sub@GOTPCREL(%rip), %rdx	#, tmp85
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_2]
# a.out.c:274:   k->data.ptr = p;
	movq	%rdx, 8(%rax)	# tmp85, a_2->data.ptr
# a.out.c:1065: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE53:
	.size	khasm_46_Stdlib_46__45__impl, .-khasm_46_Stdlib_46__45__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__47__impl
	.type	khasm_46_Stdlib_46__47__impl, @function
khasm_46_Stdlib_46__47__impl:
.LFB54:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_int_95_div@GOTPCREL(%rip), %rdx	#, tmp85
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_2]
# a.out.c:274:   k->data.ptr = p;
	movq	%rdx, 8(%rax)	# tmp85, a_2->data.ptr
# a.out.c:1073: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE54:
	.size	khasm_46_Stdlib_46__47__impl, .-khasm_46_Stdlib_46__47__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__42__impl
	.type	khasm_46_Stdlib_46__42__impl, @function
khasm_46_Stdlib_46__42__impl:
.LFB55:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_int_95_mul@GOTPCREL(%rip), %rdx	#, tmp85
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_2]
# a.out.c:274:   k->data.ptr = p;
	movq	%rdx, 8(%rax)	# tmp85, a_2->data.ptr
# a.out.c:1081: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE55:
	.size	khasm_46_Stdlib_46__42__impl, .-khasm_46_Stdlib_46__42__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__43__46__impl
	.type	khasm_46_Stdlib_46__43__46__impl, @function
khasm_46_Stdlib_46__43__46__impl:
.LFB56:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_float_95_add@GOTPCREL(%rip), %rdx	#, tmp85
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_2]
# a.out.c:274:   k->data.ptr = p;
	movq	%rdx, 8(%rax)	# tmp85, a_2->data.ptr
# a.out.c:1089: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE56:
	.size	khasm_46_Stdlib_46__43__46__impl, .-khasm_46_Stdlib_46__43__46__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__45__46__impl
	.type	khasm_46_Stdlib_46__45__46__impl, @function
khasm_46_Stdlib_46__45__46__impl:
.LFB57:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_float_95_sub@GOTPCREL(%rip), %rdx	#, tmp85
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_2]
# a.out.c:274:   k->data.ptr = p;
	movq	%rdx, 8(%rax)	# tmp85, a_2->data.ptr
# a.out.c:1097: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE57:
	.size	khasm_46_Stdlib_46__45__46__impl, .-khasm_46_Stdlib_46__45__46__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__42__46__impl
	.type	khasm_46_Stdlib_46__42__46__impl, @function
khasm_46_Stdlib_46__42__46__impl:
.LFB58:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_float_95_mul@GOTPCREL(%rip), %rdx	#, tmp85
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_2]
# a.out.c:274:   k->data.ptr = p;
	movq	%rdx, 8(%rax)	# tmp85, a_2->data.ptr
# a.out.c:1105: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE58:
	.size	khasm_46_Stdlib_46__42__46__impl, .-khasm_46_Stdlib_46__42__46__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__47__46__impl
	.type	khasm_46_Stdlib_46__47__46__impl, @function
khasm_46_Stdlib_46__47__46__impl:
.LFB59:
	.cfi_startproc
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_float_95_div@GOTPCREL(%rip), %rdx	#, tmp85
# a.out.c:189:   a->tag = t;
	movq	$259, (%rax)	#, MEM[(union  *)a_2]
# a.out.c:274:   k->data.ptr = p;
	movq	%rdx, 8(%rax)	# tmp85, a_2->data.ptr
# a.out.c:1113: }
	addq	$8, %rsp	#,
	.cfi_def_cfa_offset 8
	ret	
	.cfi_endproc
.LFE59:
	.size	khasm_46_Stdlib_46__47__46__impl, .-khasm_46_Stdlib_46__47__46__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46_pipe_impl
	.type	khasm_46_Stdlib_46_pipe_impl, @function
khasm_46_Stdlib_46_pipe_impl:
.LFB60:
	.cfi_startproc
	pushq	%r15	#
	.cfi_def_cfa_offset 16
	.cfi_offset 15, -16
	pushq	%r14	#
	.cfi_def_cfa_offset 24
	.cfi_offset 14, -24
	pushq	%r13	#
	.cfi_def_cfa_offset 32
	.cfi_offset 13, -32
	pushq	%r12	#
	.cfi_def_cfa_offset 40
	.cfi_offset 12, -40
	pushq	%rbp	#
	.cfi_def_cfa_offset 48
	.cfi_offset 6, -48
	pushq	%rbx	#
	.cfi_def_cfa_offset 56
	.cfi_offset 3, -56
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 64
# a.out.c:196:   if (!a) {
	testq	%rdi, %rdi	# khasm_35
	je	.L378	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rdi), %r12	# *khasm_35_2(D), _11
	movq	%rdi, %rbx	# tmp367, khasm_35
	movq	%rsi, %rbp	# tmp368, khasm_36
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r13	#, tmp120
# a.out.c:200:   a->gc += 1;
	shrq	$8, %r12	#, _11
# a.out.c:200:   a->gc += 1;
	leaq	1(%r12), %rax	#, tmp118
	andq	%r13, %rax	# tmp120, tmp119
	movq	%rax, %rdx	# tmp119, tmp130
	movb	%al, 1(%rdi)	# tmp119,
	shrq	$16, %rdx	#, tmp130
	movb	%ah, 2(%rdi)	# tmp119,
	movb	%dl, 3(%rdi)	# tmp130,
	movq	%rax, %rdx	# tmp119, tmp135
	shrq	$24, %rdx	#, tmp135
	movb	%dl, 4(%rdi)	# tmp135,
	movq	%rax, %rdx	# tmp119, tmp140
	shrq	$32, %rdx	#, tmp140
	movb	%dl, 5(%rdi)	# tmp140,
	movq	%rax, %rdx	# tmp119, tmp145
	shrq	$48, %rax	#, tmp151
	shrq	$40, %rdx	#, tmp145
	movb	%al, 7(%rdi)	# tmp151,
	movb	%dl, 6(%rdi)	# tmp145,
# a.out.c:393:   if (a->tag == PAP) {
	movzbl	(%rsi), %eax	# khasm_36_3(D)->D.4393.D.4391.tag, _20
# a.out.c:393:   if (a->tag == PAP) {
	cmpb	$1, %al	#, _20
	je	.L379	#,
# a.out.c:406:   } else if (a->tag == PTR) {
	cmpb	$3, %al	#, _20
	jne	.L373	#,
# a.out.c:407:     kha_obj **args = malloc(sizeof(kha_obj *));
	movl	$8, %edi	#,
	call	malloc@PLT	#
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:407:     kha_obj **args = malloc(sizeof(kha_obj *));
	movq	%rax, %r14	# tmp372, tmp203
# a.out.c:200:   a->gc += 1;
	leaq	2(%r12), %rax	#, tmp204
	andq	%r13, %rax	# tmp120, tmp205
	movq	%rax, %rdx	# tmp205, tmp216
	movb	%al, 1(%rbx)	# tmp205,
	shrq	$16, %rdx	#, tmp216
	movb	%ah, 2(%rbx)	# tmp205,
	movb	%dl, 3(%rbx)	# tmp216,
	movq	%rax, %rdx	# tmp205, tmp221
	shrq	$24, %rdx	#, tmp221
	movb	%dl, 4(%rbx)	# tmp221,
	movq	%rax, %rdx	# tmp205, tmp226
	shrq	$32, %rdx	#, tmp226
	movb	%dl, 5(%rbx)	# tmp226,
	movq	%rax, %rdx	# tmp205, tmp231
	shrq	$48, %rax	#, tmp237
	shrq	$40, %rdx	#, tmp231
	movb	%al, 7(%rbx)	# tmp237,
	movb	%dl, 6(%rbx)	# tmp231,
# a.out.c:409:     kha_obj *k = make_pap(1, a->data.ptr, args);
	movq	8(%rbp), %r15	# khasm_36_3(D)->data.ptr, _40
# a.out.c:408:     args[0] = ref(b);
	movq	%rbx, (%r14)	# khasm_35, *args_37
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movl	$24, %edi	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp373, a
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$257, (%r12)	#, MEM[(union  *)a_48]
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movq	%rax, 8(%r12)	# tmp242, a_48->data.pap
# a.out.c:312:   k->data.pap->argnum = argnum;
	movq	$1, 16(%rax)	#, MEM[(struct kha_obj_pap *)_49].argnum
# a.out.c:313:   k->data.pap->args = args;
	movq	%r14, 8(%rax)	# tmp203, MEM[(struct kha_obj_pap *)_49].args
# a.out.c:314:   k->data.pap->func = p;
	movq	%r15, (%rax)	# _40, MEM[(struct kha_obj_pap *)_49].func
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *khasm_36_3(D), tmp245
	shrq	$8, %rax	#, tmp245
# a.out.c:208:   a->gc -= 1;
	addq	%r13, %rax	# tmp120, _43
	andq	%r13, %rax	# tmp120, _43
	movq	%rax, %rdx	# _43, tmp258
	movb	%al, 1(%rbp)	# _43,
	shrq	$16, %rdx	#, tmp258
	movb	%ah, 2(%rbp)	# _43,
	movb	%dl, 3(%rbp)	# tmp258,
	movq	%rax, %rdx	# _43, tmp263
	shrq	$24, %rdx	#, tmp263
	movb	%dl, 4(%rbp)	# tmp263,
	movq	%rax, %rdx	# _43, tmp268
	shrq	$32, %rdx	#, tmp268
	movb	%dl, 5(%rbp)	# tmp268,
	movq	%rax, %rdx	# _43, tmp273
	shrq	$40, %rdx	#, tmp273
	movb	%dl, 6(%rbp)	# tmp273,
	movq	%rax, %rdx	# _43, tmp279
	shrq	$48, %rdx	#, tmp279
	movb	%dl, 7(%rbp)	# tmp279,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _43
	je	.L380	#,
.L374:
# a.out.c:412:     return call(k);
	movq	%r12, %rdi	# a,
	call	call	#
	movq	%rax, %r12	# tmp375, <retval>
.L372:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp290
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *khasm_36_3(D), tmp288
	shrq	$8, %rax	#, tmp288
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp290, _10
	andq	%rdx, %rax	# tmp290, _10
	movq	%rax, %rdx	# _10, tmp301
	movb	%al, 1(%rbp)	# _10,
	shrq	$16, %rdx	#, tmp301
	movb	%ah, 2(%rbp)	# _10,
	movb	%dl, 3(%rbp)	# tmp301,
	movq	%rax, %rdx	# _10, tmp306
	shrq	$24, %rdx	#, tmp306
	movb	%dl, 4(%rbp)	# tmp306,
	movq	%rax, %rdx	# _10, tmp311
	shrq	$32, %rdx	#, tmp311
	movb	%dl, 5(%rbp)	# tmp311,
	movq	%rax, %rdx	# _10, tmp316
	shrq	$40, %rdx	#, tmp316
	movb	%dl, 6(%rbp)	# tmp316,
	movq	%rax, %rdx	# _10, tmp322
	shrq	$48, %rdx	#, tmp322
	movb	%dl, 7(%rbp)	# tmp322,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _10
	je	.L381	#,
.L375:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp330
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *khasm_35_2(D), tmp328
	shrq	$8, %rax	#, tmp328
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp330, _8
	andq	%rdx, %rax	# tmp330, _8
	movq	%rax, %rdx	# _8, tmp341
	movb	%al, 1(%rbx)	# _8,
	shrq	$16, %rdx	#, tmp341
	movb	%ah, 2(%rbx)	# _8,
	movb	%dl, 3(%rbx)	# tmp341,
	movq	%rax, %rdx	# _8, tmp346
	shrq	$24, %rdx	#, tmp346
	movb	%dl, 4(%rbx)	# tmp346,
	movq	%rax, %rdx	# _8, tmp351
	shrq	$32, %rdx	#, tmp351
	movb	%dl, 5(%rbx)	# tmp351,
	movq	%rax, %rdx	# _8, tmp356
	shrq	$40, %rdx	#, tmp356
	movb	%dl, 6(%rbx)	# tmp356,
	movq	%rax, %rdx	# _8, tmp362
	shrq	$48, %rdx	#, tmp362
	movb	%dl, 7(%rbx)	# tmp362,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _8
	je	.L382	#,
.L369:
# a.out.c:1129: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L382:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# khasm_35,
	call	k_free	#
# a.out.c:1127:  return khasm_121;
	jmp	.L369	#
	.p2align 4,,10
	.p2align 3
.L381:
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# khasm_36,
	call	k_free	#
	jmp	.L375	#
	.p2align 4,,10
	.p2align 3
.L380:
	movq	%rbp, %rdi	# khasm_36,
	call	k_free	#
	jmp	.L374	#
	.p2align 4,,10
	.p2align 3
.L379:
# a.out.c:397:     a = copy_pap(a);
	movq	%rsi, %rdi	# khasm_36,
	call	copy_pap	#
# a.out.c:399:     a->data.pap->argnum++;
	movq	8(%rax), %r14	# a_21->data.pap, _22
# a.out.c:397:     a = copy_pap(a);
	movq	%rax, %r12	# tmp369, a
# a.out.c:399:     a->data.pap->argnum++;
	movq	16(%r14), %rax	# _22->argnum, tmp383
# a.out.c:401:         realloc(a->data.pap->args,
	movq	8(%r14), %rdi	# _22->args, _22->args
# a.out.c:399:     a->data.pap->argnum++;
	leaq	1(%rax), %rsi	#, _24
	movq	%rsi, 16(%r14)	# _24, _22->argnum
# a.out.c:401:         realloc(a->data.pap->args,
	salq	$3, %rsi	#, tmp156
	call	realloc@PLT	#
# a.out.c:400:     a->data.pap->args =
	movq	%rax, 8(%r14)	# tmp370, _22->args
# a.out.c:403:     a->data.pap->args[a->data.pap->argnum - 1] = ref(b);
	movq	8(%r12), %rax	# a_21->data.pap, _28
# a.out.c:403:     a->data.pap->args[a->data.pap->argnum - 1] = ref(b);
	movq	8(%rax), %rdi	# _28->args, _28->args
	movq	16(%rax), %rcx	# _28->argnum, _28->argnum
# a.out.c:200:   a->gc += 1;
	movq	(%rbx), %rax	# *khasm_35_2(D), tmp164
	shrq	$8, %rax	#, tmp164
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp166
	andq	%r13, %rax	# tmp120, tmp167
	movq	%rax, %rsi	# tmp167, tmp178
	movb	%al, 1(%rbx)	# tmp167,
	shrq	$16, %rsi	#, tmp178
	movb	%ah, 2(%rbx)	# tmp167,
	movb	%sil, 3(%rbx)	# tmp178,
	movq	%rax, %rsi	# tmp167, tmp183
	shrq	$24, %rsi	#, tmp183
	movb	%sil, 4(%rbx)	# tmp183,
	movq	%rax, %rsi	# tmp167, tmp188
	shrq	$32, %rsi	#, tmp188
	movb	%sil, 5(%rbx)	# tmp188,
	movq	%rax, %rsi	# tmp167, tmp193
	shrq	$48, %rax	#, tmp199
	shrq	$40, %rsi	#, tmp193
	movb	%al, 7(%rbx)	# tmp199,
	movb	%sil, 6(%rbx)	# tmp193,
# a.out.c:403:     a->data.pap->args[a->data.pap->argnum - 1] = ref(b);
	movq	%rbx, -8(%rdi,%rcx,8)	# khasm_35, *_33
# a.out.c:405:     return call(a);
	movq	%r12, %rdi	# a,
	call	call	#
	movq	%rax, %r12	# tmp371, <retval>
	jmp	.L372	#
.L378:
	call	ref.part.0	#
.L373:
# a.out.c:414:     fprintf(stderr, "ERROR: Can't call non-ptr %d", a->tag);
	movq	stderr(%rip), %rdi	# stderr,
	movzbl	%al, %edx	# _20, _20
	xorl	%eax, %eax	#
	leaq	.LC5(%rip), %rsi	#, tmp285
	call	fprintf@PLT	#
# a.out.c:415:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE60:
	.size	khasm_46_Stdlib_46_pipe_impl, .-khasm_46_Stdlib_46_pipe_impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__124__62__impl
	.type	khasm_46_Stdlib_46__124__62__impl, @function
khasm_46_Stdlib_46__124__62__impl:
.LFB61:
	.cfi_startproc
# a.out.c:1137: }
	movq	khasm_46_Stdlib_46_pipe@GOTPCREL(%rip), %rax	#,
	ret	
	.cfi_endproc
.LFE61:
	.size	khasm_46_Stdlib_46__124__62__impl, .-khasm_46_Stdlib_46__124__62__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46_apply_impl
	.type	khasm_46_Stdlib_46_apply_impl, @function
khasm_46_Stdlib_46_apply_impl:
.LFB62:
	.cfi_startproc
	pushq	%r15	#
	.cfi_def_cfa_offset 16
	.cfi_offset 15, -16
	pushq	%r14	#
	.cfi_def_cfa_offset 24
	.cfi_offset 14, -24
	pushq	%r13	#
	.cfi_def_cfa_offset 32
	.cfi_offset 13, -32
	pushq	%r12	#
	.cfi_def_cfa_offset 40
	.cfi_offset 12, -40
	pushq	%rbp	#
	.cfi_def_cfa_offset 48
	.cfi_offset 6, -48
	pushq	%rbx	#
	.cfi_def_cfa_offset 56
	.cfi_offset 3, -56
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 64
# a.out.c:196:   if (!a) {
	testq	%rsi, %rsi	# khasm_40
	je	.L393	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rsi), %r12	# *khasm_40_2(D), _11
	movq	%rdi, %rbp	# tmp367, khasm_39
	movq	%rsi, %rbx	# tmp368, khasm_40
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r13	#, tmp120
# a.out.c:200:   a->gc += 1;
	shrq	$8, %r12	#, _11
# a.out.c:200:   a->gc += 1;
	leaq	1(%r12), %rax	#, tmp118
	andq	%r13, %rax	# tmp120, tmp119
	movq	%rax, %rdx	# tmp119, tmp130
	movb	%al, 1(%rsi)	# tmp119,
	shrq	$16, %rdx	#, tmp130
	movb	%ah, 2(%rsi)	# tmp119,
	movb	%dl, 3(%rsi)	# tmp130,
	movq	%rax, %rdx	# tmp119, tmp135
	shrq	$24, %rdx	#, tmp135
	movb	%dl, 4(%rsi)	# tmp135,
	movq	%rax, %rdx	# tmp119, tmp140
	shrq	$32, %rdx	#, tmp140
	movb	%dl, 5(%rsi)	# tmp140,
	movq	%rax, %rdx	# tmp119, tmp145
	shrq	$48, %rax	#, tmp151
	shrq	$40, %rdx	#, tmp145
	movb	%al, 7(%rsi)	# tmp151,
	movb	%dl, 6(%rsi)	# tmp145,
# a.out.c:393:   if (a->tag == PAP) {
	movzbl	(%rdi), %eax	# khasm_39_3(D)->D.4393.D.4391.tag, _20
# a.out.c:393:   if (a->tag == PAP) {
	cmpb	$1, %al	#, _20
	je	.L394	#,
# a.out.c:406:   } else if (a->tag == PTR) {
	cmpb	$3, %al	#, _20
	jne	.L388	#,
# a.out.c:407:     kha_obj **args = malloc(sizeof(kha_obj *));
	movl	$8, %edi	#,
	call	malloc@PLT	#
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:407:     kha_obj **args = malloc(sizeof(kha_obj *));
	movq	%rax, %r14	# tmp372, tmp203
# a.out.c:200:   a->gc += 1;
	leaq	2(%r12), %rax	#, tmp204
	andq	%r13, %rax	# tmp120, tmp205
	movq	%rax, %rdx	# tmp205, tmp216
	movb	%al, 1(%rbx)	# tmp205,
	shrq	$16, %rdx	#, tmp216
	movb	%ah, 2(%rbx)	# tmp205,
	movb	%dl, 3(%rbx)	# tmp216,
	movq	%rax, %rdx	# tmp205, tmp221
	shrq	$24, %rdx	#, tmp221
	movb	%dl, 4(%rbx)	# tmp221,
	movq	%rax, %rdx	# tmp205, tmp226
	shrq	$32, %rdx	#, tmp226
	movb	%dl, 5(%rbx)	# tmp226,
	movq	%rax, %rdx	# tmp205, tmp231
	shrq	$48, %rax	#, tmp237
	shrq	$40, %rdx	#, tmp231
	movb	%al, 7(%rbx)	# tmp237,
	movb	%dl, 6(%rbx)	# tmp231,
# a.out.c:409:     kha_obj *k = make_pap(1, a->data.ptr, args);
	movq	8(%rbp), %r15	# khasm_39_3(D)->data.ptr, _40
# a.out.c:408:     args[0] = ref(b);
	movq	%rbx, (%r14)	# khasm_40, *args_37
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movl	$24, %edi	#,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r12	# tmp373, a
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$257, (%r12)	#, MEM[(union  *)a_48]
# a.out.c:311:   k->data.pap = malloc(sizeof(struct kha_obj_pap));
	movq	%rax, 8(%r12)	# tmp242, a_48->data.pap
# a.out.c:312:   k->data.pap->argnum = argnum;
	movq	$1, 16(%rax)	#, MEM[(struct kha_obj_pap *)_49].argnum
# a.out.c:313:   k->data.pap->args = args;
	movq	%r14, 8(%rax)	# tmp203, MEM[(struct kha_obj_pap *)_49].args
# a.out.c:314:   k->data.pap->func = p;
	movq	%r15, (%rax)	# _40, MEM[(struct kha_obj_pap *)_49].func
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *khasm_39_3(D), tmp245
	shrq	$8, %rax	#, tmp245
# a.out.c:208:   a->gc -= 1;
	addq	%r13, %rax	# tmp120, _43
	andq	%r13, %rax	# tmp120, _43
	movq	%rax, %rdx	# _43, tmp258
	movb	%al, 1(%rbp)	# _43,
	shrq	$16, %rdx	#, tmp258
	movb	%ah, 2(%rbp)	# _43,
	movb	%dl, 3(%rbp)	# tmp258,
	movq	%rax, %rdx	# _43, tmp263
	shrq	$24, %rdx	#, tmp263
	movb	%dl, 4(%rbp)	# tmp263,
	movq	%rax, %rdx	# _43, tmp268
	shrq	$32, %rdx	#, tmp268
	movb	%dl, 5(%rbp)	# tmp268,
	movq	%rax, %rdx	# _43, tmp273
	shrq	$40, %rdx	#, tmp273
	movb	%dl, 6(%rbp)	# tmp273,
	movq	%rax, %rdx	# _43, tmp279
	shrq	$48, %rdx	#, tmp279
	movb	%dl, 7(%rbp)	# tmp279,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _43
	je	.L395	#,
.L389:
# a.out.c:412:     return call(k);
	movq	%r12, %rdi	# a,
	call	call	#
	movq	%rax, %r12	# tmp375, <retval>
.L387:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp290
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *khasm_39_3(D), tmp288
	shrq	$8, %rax	#, tmp288
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp290, _10
	andq	%rdx, %rax	# tmp290, _10
	movq	%rax, %rdx	# _10, tmp301
	movb	%al, 1(%rbp)	# _10,
	shrq	$16, %rdx	#, tmp301
	movb	%ah, 2(%rbp)	# _10,
	movb	%dl, 3(%rbp)	# tmp301,
	movq	%rax, %rdx	# _10, tmp306
	shrq	$24, %rdx	#, tmp306
	movb	%dl, 4(%rbp)	# tmp306,
	movq	%rax, %rdx	# _10, tmp311
	shrq	$32, %rdx	#, tmp311
	movb	%dl, 5(%rbp)	# tmp311,
	movq	%rax, %rdx	# _10, tmp316
	shrq	$40, %rdx	#, tmp316
	movb	%dl, 6(%rbp)	# tmp316,
	movq	%rax, %rdx	# _10, tmp322
	shrq	$48, %rdx	#, tmp322
	movb	%dl, 7(%rbp)	# tmp322,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _10
	je	.L396	#,
.L390:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp330
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *khasm_40_2(D), tmp328
	shrq	$8, %rax	#, tmp328
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp330, _8
	andq	%rdx, %rax	# tmp330, _8
	movq	%rax, %rdx	# _8, tmp341
	movb	%al, 1(%rbx)	# _8,
	shrq	$16, %rdx	#, tmp341
	movb	%ah, 2(%rbx)	# _8,
	movb	%dl, 3(%rbx)	# tmp341,
	movq	%rax, %rdx	# _8, tmp346
	shrq	$24, %rdx	#, tmp346
	movb	%dl, 4(%rbx)	# tmp346,
	movq	%rax, %rdx	# _8, tmp351
	shrq	$32, %rdx	#, tmp351
	movb	%dl, 5(%rbx)	# tmp351,
	movq	%rax, %rdx	# _8, tmp356
	shrq	$40, %rdx	#, tmp356
	movb	%dl, 6(%rbx)	# tmp356,
	movq	%rax, %rdx	# _8, tmp362
	shrq	$48, %rdx	#, tmp362
	movb	%dl, 7(%rbx)	# tmp362,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _8
	je	.L397	#,
.L384:
# a.out.c:1153: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
	movq	%r12, %rax	# <retval>,
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L397:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# khasm_40,
	call	k_free	#
# a.out.c:1151:  return khasm_125;
	jmp	.L384	#
	.p2align 4,,10
	.p2align 3
.L396:
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# khasm_39,
	call	k_free	#
	jmp	.L390	#
	.p2align 4,,10
	.p2align 3
.L395:
	movq	%rbp, %rdi	# khasm_39,
	call	k_free	#
	jmp	.L389	#
	.p2align 4,,10
	.p2align 3
.L394:
# a.out.c:397:     a = copy_pap(a);
	call	copy_pap	#
# a.out.c:399:     a->data.pap->argnum++;
	movq	8(%rax), %r14	# a_21->data.pap, _22
# a.out.c:397:     a = copy_pap(a);
	movq	%rax, %r12	# tmp369, a
# a.out.c:399:     a->data.pap->argnum++;
	movq	16(%r14), %rax	# _22->argnum, tmp383
# a.out.c:401:         realloc(a->data.pap->args,
	movq	8(%r14), %rdi	# _22->args, _22->args
# a.out.c:399:     a->data.pap->argnum++;
	leaq	1(%rax), %rsi	#, _24
	movq	%rsi, 16(%r14)	# _24, _22->argnum
# a.out.c:401:         realloc(a->data.pap->args,
	salq	$3, %rsi	#, tmp156
	call	realloc@PLT	#
# a.out.c:400:     a->data.pap->args =
	movq	%rax, 8(%r14)	# tmp370, _22->args
# a.out.c:403:     a->data.pap->args[a->data.pap->argnum - 1] = ref(b);
	movq	8(%r12), %rax	# a_21->data.pap, _28
# a.out.c:403:     a->data.pap->args[a->data.pap->argnum - 1] = ref(b);
	movq	8(%rax), %rdi	# _28->args, _28->args
	movq	16(%rax), %rcx	# _28->argnum, _28->argnum
# a.out.c:200:   a->gc += 1;
	movq	(%rbx), %rax	# *khasm_40_2(D), tmp164
	shrq	$8, %rax	#, tmp164
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp166
	andq	%r13, %rax	# tmp120, tmp167
	movq	%rax, %rsi	# tmp167, tmp178
	movb	%al, 1(%rbx)	# tmp167,
	shrq	$16, %rsi	#, tmp178
	movb	%ah, 2(%rbx)	# tmp167,
	movb	%sil, 3(%rbx)	# tmp178,
	movq	%rax, %rsi	# tmp167, tmp183
	shrq	$24, %rsi	#, tmp183
	movb	%sil, 4(%rbx)	# tmp183,
	movq	%rax, %rsi	# tmp167, tmp188
	shrq	$32, %rsi	#, tmp188
	movb	%sil, 5(%rbx)	# tmp188,
	movq	%rax, %rsi	# tmp167, tmp193
	shrq	$48, %rax	#, tmp199
	shrq	$40, %rsi	#, tmp193
	movb	%al, 7(%rbx)	# tmp199,
	movb	%sil, 6(%rbx)	# tmp193,
# a.out.c:403:     a->data.pap->args[a->data.pap->argnum - 1] = ref(b);
	movq	%rbx, -8(%rdi,%rcx,8)	# khasm_40, *_33
# a.out.c:405:     return call(a);
	movq	%r12, %rdi	# a,
	call	call	#
	movq	%rax, %r12	# tmp371, <retval>
	jmp	.L387	#
.L393:
	call	ref.part.0	#
.L388:
# a.out.c:414:     fprintf(stderr, "ERROR: Can't call non-ptr %d", a->tag);
	movq	stderr(%rip), %rdi	# stderr,
	movzbl	%al, %edx	# _20, _20
	xorl	%eax, %eax	#
	leaq	.LC5(%rip), %rsi	#, tmp285
	call	fprintf@PLT	#
# a.out.c:415:     exit(1);
	movl	$1, %edi	#,
	call	exit@PLT	#
	.cfi_endproc
.LFE62:
	.size	khasm_46_Stdlib_46_apply_impl, .-khasm_46_Stdlib_46_apply_impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__60__124__impl
	.type	khasm_46_Stdlib_46__60__124__impl, @function
khasm_46_Stdlib_46__60__124__impl:
.LFB63:
	.cfi_startproc
# a.out.c:1161: }
	movq	khasm_46_Stdlib_46_apply@GOTPCREL(%rip), %rax	#,
	ret	
	.cfi_endproc
.LFE63:
	.size	khasm_46_Stdlib_46__60__124__impl, .-khasm_46_Stdlib_46__60__124__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46_compose_impl
	.type	khasm_46_Stdlib_46_compose_impl, @function
khasm_46_Stdlib_46_compose_impl:
.LFB64:
	.cfi_startproc
	pushq	%r14	#
	.cfi_def_cfa_offset 16
	.cfi_offset 14, -16
	pushq	%r13	#
	.cfi_def_cfa_offset 24
	.cfi_offset 13, -24
	pushq	%r12	#
	.cfi_def_cfa_offset 32
	.cfi_offset 12, -32
	pushq	%rbp	#
	.cfi_def_cfa_offset 40
	.cfi_offset 6, -40
	pushq	%rbx	#
	.cfi_def_cfa_offset 48
	.cfi_offset 3, -48
# a.out.c:196:   if (!a) {
	testq	%rdx, %rdx	# khasm_45
	je	.L405	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rdx), %rax	# *khasm_45_2(D), tmp101
	movq	%rdx, %rbx	# tmp344, khasm_45
	movq	%rsi, %r13	# tmp343, khasm_44
	movq	%rdi, %r12	# tmp342, khasm_43
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r14	#, tmp105
# a.out.c:1167: khasm_64 = add_arg(khasm_44, khasm_45);
	movq	%rbx, %rsi	# khasm_45,
	movq	%r13, %rdi	# khasm_44,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp101
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp103
	andq	%r14, %rax	# tmp105, tmp104
	movb	%al, 1(%rdx)	# tmp104,
	movb	%ah, 2(%rdx)	# tmp104,
	movq	%rax, %rdx	# tmp104, tmp115
	shrq	$16, %rdx	#, tmp115
	movb	%dl, 3(%rbx)	# tmp115,
	movq	%rax, %rdx	# tmp104, tmp120
	shrq	$24, %rdx	#, tmp120
	movb	%dl, 4(%rbx)	# tmp120,
	movq	%rax, %rdx	# tmp104, tmp125
	shrq	$32, %rdx	#, tmp125
	movb	%dl, 5(%rbx)	# tmp125,
	movq	%rax, %rdx	# tmp104, tmp130
	shrq	$48, %rax	#, tmp136
	shrq	$40, %rdx	#, tmp130
	movb	%al, 7(%rbx)	# tmp136,
	movb	%dl, 6(%rbx)	# tmp130,
# a.out.c:1167: khasm_64 = add_arg(khasm_44, khasm_45);
	call	add_arg	#
	movq	%rax, %rbp	# tmp345, khasm_64
# a.out.c:205:   if (!a) {
	testq	%r13, %r13	# khasm_44
	je	.L402	#,
# a.out.c:208:   a->gc -= 1;
	movq	0(%r13), %rax	# *khasm_44_4(D), tmp142
	shrq	$8, %rax	#, tmp142
# a.out.c:208:   a->gc -= 1;
	addq	%r14, %rax	# tmp105, _20
	andq	%r14, %rax	# tmp105, _20
	movq	%rax, %rdx	# _20, tmp155
	movzbl	%ah, %ecx	# _20, tmp355
	movb	%al, 1(%r13)	# _20,
	shrq	$16, %rdx	#, tmp155
	movb	%cl, 2(%r13)	# tmp355,
	movb	%dl, 3(%r13)	# tmp155,
	movq	%rax, %rdx	# _20, tmp160
	shrq	$24, %rdx	#, tmp160
	movb	%dl, 4(%r13)	# tmp160,
	movq	%rax, %rdx	# _20, tmp165
	shrq	$32, %rdx	#, tmp165
	movb	%dl, 5(%r13)	# tmp165,
	movq	%rax, %rdx	# _20, tmp170
	shrq	$40, %rdx	#, tmp170
	movb	%dl, 6(%r13)	# tmp170,
	movq	%rax, %rdx	# _20, tmp176
	shrq	$48, %rdx	#, tmp176
	movb	%dl, 7(%r13)	# tmp176,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _20
	je	.L414	#,
.L402:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp184
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *khasm_45_2(D), tmp182
	shrq	$8, %rax	#, tmp182
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp184, _18
	andq	%rdx, %rax	# tmp184, _18
	movq	%rax, %rdx	# _18, tmp195
	movb	%al, 1(%rbx)	# _18,
	shrq	$16, %rdx	#, tmp195
	movb	%ah, 2(%rbx)	# _18,
	movb	%dl, 3(%rbx)	# tmp195,
	movq	%rax, %rdx	# _18, tmp200
	shrq	$24, %rdx	#, tmp200
	movb	%dl, 4(%rbx)	# tmp200,
	movq	%rax, %rdx	# _18, tmp205
	shrq	$32, %rdx	#, tmp205
	movb	%dl, 5(%rbx)	# tmp205,
	movq	%rax, %rdx	# _18, tmp210
	shrq	$40, %rdx	#, tmp210
	movb	%dl, 6(%rbx)	# tmp210,
	movq	%rax, %rdx	# _18, tmp216
	shrq	$48, %rdx	#, tmp216
	movb	%dl, 7(%rbx)	# tmp216,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _18
	je	.L415	#,
.L404:
# a.out.c:196:   if (!a) {
	testq	%rbp, %rbp	# khasm_64
	je	.L405	#,
# a.out.c:200:   a->gc += 1;
	movq	0(%rbp), %rax	# *khasm_64_6, tmp222
# a.out.c:1175: khasm_65 = add_arg(khasm_43, khasm_64);
	movq	%rbp, %rsi	# khasm_64,
	movq	%r12, %rdi	# khasm_43,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r13	#, tmp226
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp222
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp224
	andq	%r13, %rax	# tmp226, tmp225
	movq	%rax, %rdx	# tmp225, tmp236
	movb	%al, 1(%rbp)	# tmp225,
	shrq	$16, %rdx	#, tmp236
	movb	%ah, 2(%rbp)	# tmp225,
	movb	%dl, 3(%rbp)	# tmp236,
	movq	%rax, %rdx	# tmp225, tmp241
	shrq	$24, %rdx	#, tmp241
	movb	%dl, 4(%rbp)	# tmp241,
	movq	%rax, %rdx	# tmp225, tmp246
	shrq	$32, %rdx	#, tmp246
	movb	%dl, 5(%rbp)	# tmp246,
	movq	%rax, %rdx	# tmp225, tmp251
	shrq	$48, %rax	#, tmp257
	shrq	$40, %rdx	#, tmp251
	movb	%al, 7(%rbp)	# tmp257,
	movb	%dl, 6(%rbp)	# tmp251,
# a.out.c:1175: khasm_65 = add_arg(khasm_43, khasm_64);
	call	add_arg	#
	movq	%rax, %rbx	# tmp346, <retval>
# a.out.c:205:   if (!a) {
	testq	%r12, %r12	# khasm_43
	je	.L407	#,
# a.out.c:208:   a->gc -= 1;
	movq	(%r12), %rax	# *khasm_43_8(D), tmp263
	shrq	$8, %rax	#, tmp263
# a.out.c:208:   a->gc -= 1;
	addq	%r13, %rax	# tmp226, _14
	andq	%r13, %rax	# tmp226, _14
	movq	%rax, %rdx	# _14, tmp276
	movzbl	%ah, %ecx	# _14, tmp375
	movb	%al, 1(%r12)	# _14,
	shrq	$16, %rdx	#, tmp276
	movb	%cl, 2(%r12)	# tmp375,
	movb	%dl, 3(%r12)	# tmp276,
	movq	%rax, %rdx	# _14, tmp281
	shrq	$24, %rdx	#, tmp281
	movb	%dl, 4(%r12)	# tmp281,
	movq	%rax, %rdx	# _14, tmp286
	shrq	$32, %rdx	#, tmp286
	movb	%dl, 5(%r12)	# tmp286,
	movq	%rax, %rdx	# _14, tmp291
	shrq	$40, %rdx	#, tmp291
	movb	%dl, 6(%r12)	# tmp291,
	movq	%rax, %rdx	# _14, tmp297
	shrq	$48, %rdx	#, tmp297
	movb	%dl, 7(%r12)	# tmp297,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _14
	je	.L416	#,
.L407:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp305
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *khasm_64_6, tmp303
	shrq	$8, %rax	#, tmp303
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp305, _12
	andq	%rdx, %rax	# tmp305, _12
	movq	%rax, %rdx	# _12, tmp316
	movb	%al, 1(%rbp)	# _12,
	shrq	$16, %rdx	#, tmp316
	movb	%ah, 2(%rbp)	# _12,
	movb	%dl, 3(%rbp)	# tmp316,
	movq	%rax, %rdx	# _12, tmp321
	shrq	$24, %rdx	#, tmp321
	movb	%dl, 4(%rbp)	# tmp321,
	movq	%rax, %rdx	# _12, tmp326
	shrq	$32, %rdx	#, tmp326
	movb	%dl, 5(%rbp)	# tmp326,
	movq	%rax, %rdx	# _12, tmp331
	shrq	$40, %rdx	#, tmp331
	movb	%dl, 6(%rbp)	# tmp331,
	movq	%rax, %rdx	# _12, tmp337
	shrq	$48, %rdx	#, tmp337
	movb	%dl, 7(%rbp)	# tmp337,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _12
	je	.L417	#,
# a.out.c:1185: }
	movq	%rbx, %rax	# <retval>,
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	popq	%rbp	#
	.cfi_def_cfa_offset 32
	popq	%r12	#
	.cfi_def_cfa_offset 24
	popq	%r13	#
	.cfi_def_cfa_offset 16
	popq	%r14	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L415:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# khasm_45,
	call	k_free	#
	jmp	.L404	#
	.p2align 4,,10
	.p2align 3
.L417:
	movq	%rbp, %rdi	# khasm_64,
	call	k_free	#
# a.out.c:1185: }
	movq	%rbx, %rax	# <retval>,
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	popq	%rbp	#
	.cfi_def_cfa_offset 32
	popq	%r12	#
	.cfi_def_cfa_offset 24
	popq	%r13	#
	.cfi_def_cfa_offset 16
	popq	%r14	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L414:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%r13, %rdi	# khasm_44,
	call	k_free	#
	jmp	.L402	#
	.p2align 4,,10
	.p2align 3
.L416:
	movq	%r12, %rdi	# khasm_43,
	call	k_free	#
	jmp	.L407	#
.L405:
	call	ref.part.0	#
	.cfi_endproc
.LFE64:
	.size	khasm_46_Stdlib_46_compose_impl, .-khasm_46_Stdlib_46_compose_impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__62__62__impl
	.type	khasm_46_Stdlib_46__62__62__impl, @function
khasm_46_Stdlib_46__62__62__impl:
.LFB65:
	.cfi_startproc
# a.out.c:1193: }
	movq	khasm_46_Stdlib_46_compose@GOTPCREL(%rip), %rax	#,
	ret	
	.cfi_endproc
.LFE65:
	.size	khasm_46_Stdlib_46__62__62__impl, .-khasm_46_Stdlib_46__62__62__impl
	.p2align 4
	.globl	khasm_46_Stdlib_46_rcompose_impl
	.type	khasm_46_Stdlib_46_rcompose_impl, @function
khasm_46_Stdlib_46_rcompose_impl:
.LFB66:
	.cfi_startproc
	pushq	%r14	#
	.cfi_def_cfa_offset 16
	.cfi_offset 14, -16
	pushq	%r13	#
	.cfi_def_cfa_offset 24
	.cfi_offset 13, -24
	pushq	%r12	#
	.cfi_def_cfa_offset 32
	.cfi_offset 12, -32
	pushq	%rbp	#
	.cfi_def_cfa_offset 40
	.cfi_offset 6, -40
	pushq	%rbx	#
	.cfi_def_cfa_offset 48
	.cfi_offset 3, -48
# a.out.c:196:   if (!a) {
	testq	%rdx, %rdx	# khasm_50
	je	.L425	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rdx), %rax	# *khasm_50_2(D), tmp101
	movq	%rdx, %rbx	# tmp344, khasm_50
	movq	%rsi, %r12	# tmp343, khasm_49
	movq	%rdi, %r13	# tmp342, khasm_48
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r14	#, tmp105
# a.out.c:1199: khasm_69 = add_arg(khasm_48, khasm_50);
	movq	%rbx, %rsi	# khasm_50,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp101
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp103
	andq	%r14, %rax	# tmp105, tmp104
	movb	%al, 1(%rdx)	# tmp104,
	movb	%ah, 2(%rdx)	# tmp104,
	movq	%rax, %rdx	# tmp104, tmp115
	shrq	$16, %rdx	#, tmp115
	movb	%dl, 3(%rbx)	# tmp115,
	movq	%rax, %rdx	# tmp104, tmp120
	shrq	$24, %rdx	#, tmp120
	movb	%dl, 4(%rbx)	# tmp120,
	movq	%rax, %rdx	# tmp104, tmp125
	shrq	$32, %rdx	#, tmp125
	movb	%dl, 5(%rbx)	# tmp125,
	movq	%rax, %rdx	# tmp104, tmp130
	shrq	$48, %rax	#, tmp136
	shrq	$40, %rdx	#, tmp130
	movb	%al, 7(%rbx)	# tmp136,
	movb	%dl, 6(%rbx)	# tmp130,
# a.out.c:1199: khasm_69 = add_arg(khasm_48, khasm_50);
	call	add_arg	#
	movq	%rax, %rbp	# tmp345, khasm_69
# a.out.c:205:   if (!a) {
	testq	%r13, %r13	# khasm_48
	je	.L422	#,
# a.out.c:208:   a->gc -= 1;
	movq	0(%r13), %rax	# *khasm_48_4(D), tmp142
	shrq	$8, %rax	#, tmp142
# a.out.c:208:   a->gc -= 1;
	addq	%r14, %rax	# tmp105, _20
	andq	%r14, %rax	# tmp105, _20
	movq	%rax, %rdx	# _20, tmp155
	movzbl	%ah, %ecx	# _20, tmp355
	movb	%al, 1(%r13)	# _20,
	shrq	$16, %rdx	#, tmp155
	movb	%cl, 2(%r13)	# tmp355,
	movb	%dl, 3(%r13)	# tmp155,
	movq	%rax, %rdx	# _20, tmp160
	shrq	$24, %rdx	#, tmp160
	movb	%dl, 4(%r13)	# tmp160,
	movq	%rax, %rdx	# _20, tmp165
	shrq	$32, %rdx	#, tmp165
	movb	%dl, 5(%r13)	# tmp165,
	movq	%rax, %rdx	# _20, tmp170
	shrq	$40, %rdx	#, tmp170
	movb	%dl, 6(%r13)	# tmp170,
	movq	%rax, %rdx	# _20, tmp176
	shrq	$48, %rdx	#, tmp176
	movb	%dl, 7(%r13)	# tmp176,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _20
	je	.L434	#,
.L422:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp184
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *khasm_50_2(D), tmp182
	shrq	$8, %rax	#, tmp182
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp184, _18
	andq	%rdx, %rax	# tmp184, _18
	movq	%rax, %rdx	# _18, tmp195
	movb	%al, 1(%rbx)	# _18,
	shrq	$16, %rdx	#, tmp195
	movb	%ah, 2(%rbx)	# _18,
	movb	%dl, 3(%rbx)	# tmp195,
	movq	%rax, %rdx	# _18, tmp200
	shrq	$24, %rdx	#, tmp200
	movb	%dl, 4(%rbx)	# tmp200,
	movq	%rax, %rdx	# _18, tmp205
	shrq	$32, %rdx	#, tmp205
	movb	%dl, 5(%rbx)	# tmp205,
	movq	%rax, %rdx	# _18, tmp210
	shrq	$40, %rdx	#, tmp210
	movb	%dl, 6(%rbx)	# tmp210,
	movq	%rax, %rdx	# _18, tmp216
	shrq	$48, %rdx	#, tmp216
	movb	%dl, 7(%rbx)	# tmp216,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _18
	je	.L435	#,
.L424:
# a.out.c:196:   if (!a) {
	testq	%rbp, %rbp	# khasm_69
	je	.L425	#,
# a.out.c:200:   a->gc += 1;
	movq	0(%rbp), %rax	# *khasm_69_6, tmp222
# a.out.c:1207: khasm_70 = add_arg(khasm_49, khasm_69);
	movq	%rbp, %rsi	# khasm_69,
	movq	%r12, %rdi	# khasm_49,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r13	#, tmp226
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp222
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp224
	andq	%r13, %rax	# tmp226, tmp225
	movq	%rax, %rdx	# tmp225, tmp236
	movb	%al, 1(%rbp)	# tmp225,
	shrq	$16, %rdx	#, tmp236
	movb	%ah, 2(%rbp)	# tmp225,
	movb	%dl, 3(%rbp)	# tmp236,
	movq	%rax, %rdx	# tmp225, tmp241
	shrq	$24, %rdx	#, tmp241
	movb	%dl, 4(%rbp)	# tmp241,
	movq	%rax, %rdx	# tmp225, tmp246
	shrq	$32, %rdx	#, tmp246
	movb	%dl, 5(%rbp)	# tmp246,
	movq	%rax, %rdx	# tmp225, tmp251
	shrq	$48, %rax	#, tmp257
	shrq	$40, %rdx	#, tmp251
	movb	%al, 7(%rbp)	# tmp257,
	movb	%dl, 6(%rbp)	# tmp251,
# a.out.c:1207: khasm_70 = add_arg(khasm_49, khasm_69);
	call	add_arg	#
	movq	%rax, %rbx	# tmp346, <retval>
# a.out.c:205:   if (!a) {
	testq	%r12, %r12	# khasm_49
	je	.L427	#,
# a.out.c:208:   a->gc -= 1;
	movq	(%r12), %rax	# *khasm_49_8(D), tmp263
	shrq	$8, %rax	#, tmp263
# a.out.c:208:   a->gc -= 1;
	addq	%r13, %rax	# tmp226, _14
	andq	%r13, %rax	# tmp226, _14
	movq	%rax, %rdx	# _14, tmp276
	movzbl	%ah, %ecx	# _14, tmp375
	movb	%al, 1(%r12)	# _14,
	shrq	$16, %rdx	#, tmp276
	movb	%cl, 2(%r12)	# tmp375,
	movb	%dl, 3(%r12)	# tmp276,
	movq	%rax, %rdx	# _14, tmp281
	shrq	$24, %rdx	#, tmp281
	movb	%dl, 4(%r12)	# tmp281,
	movq	%rax, %rdx	# _14, tmp286
	shrq	$32, %rdx	#, tmp286
	movb	%dl, 5(%r12)	# tmp286,
	movq	%rax, %rdx	# _14, tmp291
	shrq	$40, %rdx	#, tmp291
	movb	%dl, 6(%r12)	# tmp291,
	movq	%rax, %rdx	# _14, tmp297
	shrq	$48, %rdx	#, tmp297
	movb	%dl, 7(%r12)	# tmp297,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _14
	je	.L436	#,
.L427:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp305
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *khasm_69_6, tmp303
	shrq	$8, %rax	#, tmp303
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp305, _12
	andq	%rdx, %rax	# tmp305, _12
	movq	%rax, %rdx	# _12, tmp316
	movb	%al, 1(%rbp)	# _12,
	shrq	$16, %rdx	#, tmp316
	movb	%ah, 2(%rbp)	# _12,
	movb	%dl, 3(%rbp)	# tmp316,
	movq	%rax, %rdx	# _12, tmp321
	shrq	$24, %rdx	#, tmp321
	movb	%dl, 4(%rbp)	# tmp321,
	movq	%rax, %rdx	# _12, tmp326
	shrq	$32, %rdx	#, tmp326
	movb	%dl, 5(%rbp)	# tmp326,
	movq	%rax, %rdx	# _12, tmp331
	shrq	$40, %rdx	#, tmp331
	movb	%dl, 6(%rbp)	# tmp331,
	movq	%rax, %rdx	# _12, tmp337
	shrq	$48, %rdx	#, tmp337
	movb	%dl, 7(%rbp)	# tmp337,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _12
	je	.L437	#,
# a.out.c:1217: }
	movq	%rbx, %rax	# <retval>,
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	popq	%rbp	#
	.cfi_def_cfa_offset 32
	popq	%r12	#
	.cfi_def_cfa_offset 24
	popq	%r13	#
	.cfi_def_cfa_offset 16
	popq	%r14	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L435:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# khasm_50,
	call	k_free	#
	jmp	.L424	#
	.p2align 4,,10
	.p2align 3
.L437:
	movq	%rbp, %rdi	# khasm_69,
	call	k_free	#
# a.out.c:1217: }
	movq	%rbx, %rax	# <retval>,
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 40
	popq	%rbp	#
	.cfi_def_cfa_offset 32
	popq	%r12	#
	.cfi_def_cfa_offset 24
	popq	%r13	#
	.cfi_def_cfa_offset 16
	popq	%r14	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L434:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%r13, %rdi	# khasm_48,
	call	k_free	#
	jmp	.L422	#
	.p2align 4,,10
	.p2align 3
.L436:
	movq	%r12, %rdi	# khasm_49,
	call	k_free	#
	jmp	.L427	#
.L425:
	call	ref.part.0	#
	.cfi_endproc
.LFE66:
	.size	khasm_46_Stdlib_46_rcompose_impl, .-khasm_46_Stdlib_46_rcompose_impl
	.p2align 4
	.globl	khasm_46_Stdlib_46__60__60__impl
	.type	khasm_46_Stdlib_46__60__60__impl, @function
khasm_46_Stdlib_46__60__60__impl:
.LFB67:
	.cfi_startproc
# a.out.c:1225: }
	movq	khasm_46_Stdlib_46_rcompose@GOTPCREL(%rip), %rax	#,
	ret	
	.cfi_endproc
.LFE67:
	.size	khasm_46_Stdlib_46__60__60__impl, .-khasm_46_Stdlib_46__60__60__impl
	.p2align 4
	.globl	khasm_46_Fib_46_fib_impl
	.type	khasm_46_Fib_46_fib_impl, @function
khasm_46_Fib_46_fib_impl:
.LFB68:
	.cfi_startproc
	pushq	%r15	#
	.cfi_def_cfa_offset 16
	.cfi_offset 15, -16
	pushq	%r14	#
	.cfi_def_cfa_offset 24
	.cfi_offset 14, -24
	pushq	%r13	#
	.cfi_def_cfa_offset 32
	.cfi_offset 13, -32
	pushq	%r12	#
	.cfi_def_cfa_offset 40
	.cfi_offset 12, -40
	pushq	%rbp	#
	.cfi_def_cfa_offset 48
	.cfi_offset 6, -48
	movq	%rdi, %rbp	# tmp922, khasm_53
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:1227: KHASM_ENTRY(khasm_46_Fib_46_fib,1, kha_obj * khasm_53){
	pushq	%rbx	#
	.cfi_def_cfa_offset 56
	.cfi_offset 3, -56
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 64
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$260, (%rax)	#, MEM[(union  *)a_27]
# a.out.c:288:   k->data.i = i;
	movq	$0, 8(%rax)	#, a_27->data.i
# a.out.c:196:   if (!a) {
	testq	%rbp, %rbp	# khasm_53
	je	.L446	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r13	#, tmp141
	movq	%rax, %rbx	# tmp923, tmp134
# a.out.c:1235: khasm_74 = khasm_46_Stdlib_46_s_95_eq(khasm_53, khasm_73);
	movq	%rbp, %rdi	# khasm_53,
# a.out.c:200:   a->gc += 1;
	movq	0(%rbp), %rax	# *khasm_53_4(D), tmp137
# a.out.c:1235: khasm_74 = khasm_46_Stdlib_46_s_95_eq(khasm_53, khasm_73);
	movq	%rbx, %rsi	# tmp134,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp137
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp139
	andq	%r13, %rax	# tmp141, tmp140
	movq	%rax, %rdx	# tmp140, tmp151
	movb	%al, 1(%rbp)	# tmp140,
	shrq	$16, %rdx	#, tmp151
	movb	%ah, 2(%rbp)	# tmp140,
	movb	%dl, 3(%rbp)	# tmp151,
	movq	%rax, %rdx	# tmp140, tmp156
	shrq	$24, %rdx	#, tmp156
	movb	%dl, 4(%rbp)	# tmp156,
	movq	%rax, %rdx	# tmp140, tmp161
	shrq	$32, %rdx	#, tmp161
	movb	%dl, 5(%rbp)	# tmp161,
	movq	%rax, %rdx	# tmp140, tmp166
	shrq	$48, %rax	#, tmp172
	shrq	$40, %rdx	#, tmp166
	movb	%al, 7(%rbp)	# tmp172,
	movb	%dl, 6(%rbp)	# tmp166,
	movb	$2, 1(%rbx)	#,
	movb	$0, 2(%rbx)	#,
	movb	$0, 3(%rbx)	#,
	movb	$0, 4(%rbx)	#,
	movb	$0, 5(%rbx)	#,
	movb	$0, 6(%rbx)	#,
	movb	$0, 7(%rbx)	#,
# a.out.c:1235: khasm_74 = khasm_46_Stdlib_46_s_95_eq(khasm_53, khasm_73);
	call	kha_extern_96_s_95_eq@PLT	#
	movq	%rax, %r12	# tmp924, khasm_74
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *a_27, tmp193
	shrq	$8, %rax	#, tmp193
# a.out.c:208:   a->gc -= 1;
	addq	%r13, %rax	# tmp141, _24
	andq	%r13, %rax	# tmp141, _24
	movq	%rax, %rdx	# _24, tmp206
	movb	%al, 1(%rbx)	# _24,
	shrq	$16, %rdx	#, tmp206
	movb	%ah, 2(%rbx)	# _24,
	movb	%dl, 3(%rbx)	# tmp206,
	movq	%rax, %rdx	# _24, tmp211
	shrq	$24, %rdx	#, tmp211
	movb	%dl, 4(%rbx)	# tmp211,
	movq	%rax, %rdx	# _24, tmp216
	shrq	$32, %rdx	#, tmp216
	movb	%dl, 5(%rbx)	# tmp216,
	movq	%rax, %rdx	# _24, tmp221
	shrq	$40, %rdx	#, tmp221
	movb	%dl, 6(%rbx)	# tmp221,
	movq	%rax, %rdx	# _24, tmp227
	shrq	$48, %rdx	#, tmp227
	movb	%dl, 7(%rbx)	# tmp227,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _24
	je	.L468	#,
# a.out.c:1239: if(khasm_74->data.i){
	cmpq	$0, 8(%r12)	#, khasm_74_6->data.i
	je	.L469	#,
.L442:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp885
# a.out.c:208:   a->gc -= 1;
	movq	(%r12), %rax	# *khasm_74_6, tmp883
	shrq	$8, %rax	#, tmp883
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp885, _64
	andq	%rdx, %rax	# tmp885, _64
	movq	%rax, %rdx	# _64, tmp896
	movzbl	%ah, %ecx	# _64, tmp1054
	movb	%al, 1(%r12)	# _64,
	shrq	$16, %rdx	#, tmp896
	movb	%cl, 2(%r12)	# tmp1054,
	movb	%dl, 3(%r12)	# tmp896,
	movq	%rax, %rdx	# _64, tmp901
	shrq	$24, %rdx	#, tmp901
	movb	%dl, 4(%r12)	# tmp901,
	movq	%rax, %rdx	# _64, tmp906
	shrq	$32, %rdx	#, tmp906
	movb	%dl, 5(%r12)	# tmp906,
	movq	%rax, %rdx	# _64, tmp911
	shrq	$40, %rdx	#, tmp911
	movb	%dl, 6(%r12)	# tmp911,
	movq	%rax, %rdx	# _64, tmp917
	shrq	$48, %rdx	#, tmp917
	movb	%dl, 7(%r12)	# tmp917,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _64
	je	.L470	#,
.L454:
# a.out.c:1315: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 56
	movq	%rbp, %rax	# khasm_53,
	popq	%rbx	#
	.cfi_def_cfa_offset 48
	popq	%rbp	#
	.cfi_def_cfa_offset 40
	popq	%r12	#
	.cfi_def_cfa_offset 32
	popq	%r13	#
	.cfi_def_cfa_offset 24
	popq	%r14	#
	.cfi_def_cfa_offset 16
	popq	%r15	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L468:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# tmp134,
	call	k_free	#
# a.out.c:1239: if(khasm_74->data.i){
	cmpq	$0, 8(%r12)	#, khasm_74_6->data.i
	jne	.L442	#,
.L469:
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r14	#, tmp238
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:1249: khasm_79 = khasm_46_Stdlib_46_s_95_eq(khasm_53, khasm_78);
	movq	%rbp, %rdi	# khasm_53,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %rbx	# tmp925, tmp231
# a.out.c:200:   a->gc += 1;
	movq	0(%rbp), %rax	# *khasm_53_4(D), tmp234
# a.out.c:1249: khasm_79 = khasm_46_Stdlib_46_s_95_eq(khasm_53, khasm_78);
	movq	%rbx, %rsi	# tmp231,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp234
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp236
	andq	%r14, %rax	# tmp238, tmp237
	movq	%rax, %rdx	# tmp237, tmp248
	movb	%al, 1(%rbp)	# tmp237,
	shrq	$16, %rdx	#, tmp248
	movb	%ah, 2(%rbp)	# tmp237,
	movb	%dl, 3(%rbp)	# tmp248,
	movq	%rax, %rdx	# tmp237, tmp253
	shrq	$24, %rdx	#, tmp253
	movb	%dl, 4(%rbp)	# tmp253,
	movq	%rax, %rdx	# tmp237, tmp258
	shrq	$32, %rdx	#, tmp258
	movb	%dl, 5(%rbp)	# tmp258,
	movq	%rax, %rdx	# tmp237, tmp263
	shrq	$48, %rax	#, tmp269
	shrq	$40, %rdx	#, tmp263
	movb	%al, 7(%rbp)	# tmp269,
	movb	%dl, 6(%rbp)	# tmp263,
# a.out.c:189:   a->tag = t;
	movq	$516, (%rbx)	#, MEM[(union  *)a_32]
# a.out.c:288:   k->data.i = i;
	movq	$1, 8(%rbx)	#, a_32->data.i
# a.out.c:1249: khasm_79 = khasm_46_Stdlib_46_s_95_eq(khasm_53, khasm_78);
	call	kha_extern_96_s_95_eq@PLT	#
	movq	%rax, %r13	# tmp926, khasm_79
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *a_32, tmp275
	shrq	$8, %rax	#, tmp275
# a.out.c:208:   a->gc -= 1;
	addq	%r14, %rax	# tmp238, _29
	andq	%r14, %rax	# tmp238, _29
	movq	%rax, %rdx	# _29, tmp288
	movb	%al, 1(%rbx)	# _29,
	shrq	$16, %rdx	#, tmp288
	movb	%ah, 2(%rbx)	# _29,
	movb	%dl, 3(%rbx)	# tmp288,
	movq	%rax, %rdx	# _29, tmp293
	shrq	$24, %rdx	#, tmp293
	movb	%dl, 4(%rbx)	# tmp293,
	movq	%rax, %rdx	# _29, tmp298
	shrq	$32, %rdx	#, tmp298
	movb	%dl, 5(%rbx)	# tmp298,
	movq	%rax, %rdx	# _29, tmp303
	shrq	$40, %rdx	#, tmp303
	movb	%dl, 6(%rbx)	# tmp303,
	movq	%rax, %rdx	# _29, tmp309
	shrq	$48, %rdx	#, tmp309
	movb	%dl, 7(%rbx)	# tmp309,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _29
	je	.L471	#,
.L443:
# a.out.c:1253: if(khasm_79->data.i){
	cmpq	$0, 8(%r13)	#, khasm_79_8->data.i
	je	.L472	#,
.L444:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp845
# a.out.c:208:   a->gc -= 1;
	movq	0(%r13), %rax	# *khasm_79_8, tmp843
	shrq	$8, %rax	#, tmp843
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp845, _62
	andq	%rdx, %rax	# tmp845, _62
	movq	%rax, %rdx	# _62, tmp856
	movzbl	%ah, %ecx	# _62, tmp1047
	movb	%al, 1(%r13)	# _62,
	shrq	$16, %rdx	#, tmp856
	movb	%cl, 2(%r13)	# tmp1047,
	movb	%dl, 3(%r13)	# tmp856,
	movq	%rax, %rdx	# _62, tmp861
	shrq	$24, %rdx	#, tmp861
	movb	%dl, 4(%r13)	# tmp861,
	movq	%rax, %rdx	# _62, tmp866
	shrq	$32, %rdx	#, tmp866
	movb	%dl, 5(%r13)	# tmp866,
	movq	%rax, %rdx	# _62, tmp871
	shrq	$40, %rdx	#, tmp871
	movb	%dl, 6(%r13)	# tmp871,
	movq	%rax, %rdx	# _62, tmp877
	shrq	$48, %rdx	#, tmp877
	movb	%dl, 7(%r13)	# tmp877,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _62
	jne	.L442	#,
# a.out.c:210:     k_free(a);
	movq	%r13, %rdi	# khasm_79,
	call	k_free	#
	jmp	.L442	#
	.p2align 4,,10
	.p2align 3
.L470:
	movq	%r12, %rdi	# khasm_74,
	call	k_free	#
	jmp	.L454	#
	.p2align 4,,10
	.p2align 3
.L472:
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r15	#, tmp320
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:1263: khasm_86 = khasm_46_Stdlib_46_isub(khasm_53, khasm_85);
	movq	%rbp, %rdi	# khasm_53,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %r14	# tmp927, tmp313
# a.out.c:200:   a->gc += 1;
	movq	0(%rbp), %rax	# *khasm_53_4(D), tmp316
# a.out.c:1263: khasm_86 = khasm_46_Stdlib_46_isub(khasm_53, khasm_85);
	movq	%r14, %rsi	# tmp313,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp316
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp318
	andq	%r15, %rax	# tmp320, tmp319
	movq	%rax, %rdx	# tmp319, tmp330
	movb	%al, 1(%rbp)	# tmp319,
	shrq	$16, %rdx	#, tmp330
	movb	%ah, 2(%rbp)	# tmp319,
	movb	%dl, 3(%rbp)	# tmp330,
	movq	%rax, %rdx	# tmp319, tmp335
	shrq	$24, %rdx	#, tmp335
	movb	%dl, 4(%rbp)	# tmp335,
	movq	%rax, %rdx	# tmp319, tmp340
	shrq	$32, %rdx	#, tmp340
	movb	%dl, 5(%rbp)	# tmp340,
	movq	%rax, %rdx	# tmp319, tmp345
	shrq	$48, %rax	#, tmp351
	shrq	$40, %rdx	#, tmp345
	movb	%al, 7(%rbp)	# tmp351,
	movb	%dl, 6(%rbp)	# tmp345,
# a.out.c:189:   a->tag = t;
	movq	$516, (%r14)	#, MEM[(union  *)a_60]
# a.out.c:288:   k->data.i = i;
	movq	$1, 8(%r14)	#, a_60->data.i
# a.out.c:1263: khasm_86 = khasm_46_Stdlib_46_isub(khasm_53, khasm_85);
	call	kha_extern_96_int_95_sub@PLT	#
	movq	%rax, %rbx	# tmp928, khasm_86
# a.out.c:208:   a->gc -= 1;
	movq	(%r14), %rax	# *a_60, tmp357
	shrq	$8, %rax	#, tmp357
# a.out.c:208:   a->gc -= 1;
	addq	%r15, %rax	# tmp320, _57
	andq	%r15, %rax	# tmp320, _57
	movq	%rax, %rdx	# _57, tmp370
	movzbl	%ah, %ecx	# _57, tmp968
	movb	%al, 1(%r14)	# _57,
	shrq	$16, %rdx	#, tmp370
	movb	%cl, 2(%r14)	# tmp968,
	movb	%dl, 3(%r14)	# tmp370,
	movq	%rax, %rdx	# _57, tmp375
	shrq	$24, %rdx	#, tmp375
	movb	%dl, 4(%r14)	# tmp375,
	movq	%rax, %rdx	# _57, tmp380
	shrq	$32, %rdx	#, tmp380
	movb	%dl, 5(%r14)	# tmp380,
	movq	%rax, %rdx	# _57, tmp385
	shrq	$40, %rdx	#, tmp385
	movb	%dl, 6(%r14)	# tmp385,
	movq	%rax, %rdx	# _57, tmp391
	shrq	$48, %rdx	#, tmp391
	movb	%dl, 7(%r14)	# tmp391,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _57
	je	.L473	#,
.L445:
# a.out.c:196:   if (!a) {
	testq	%rbx, %rbx	# khasm_86
	je	.L446	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r15	#, tmp401
# a.out.c:200:   a->gc += 1;
	movq	(%rbx), %rax	# *khasm_86_10, tmp397
# a.out.c:1269: khasm_87 = khasm_46_Fib_46_fib(khasm_86);
	movq	%rbx, %rdi	# khasm_86,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp397
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp399
	andq	%r15, %rax	# tmp401, tmp400
	movq	%rax, %rdx	# tmp400, tmp411
	movb	%al, 1(%rbx)	# tmp400,
	shrq	$16, %rdx	#, tmp411
	movb	%ah, 2(%rbx)	# tmp400,
	movb	%dl, 3(%rbx)	# tmp411,
	movq	%rax, %rdx	# tmp400, tmp416
	shrq	$24, %rdx	#, tmp416
	movb	%dl, 4(%rbx)	# tmp416,
	movq	%rax, %rdx	# tmp400, tmp421
	shrq	$32, %rdx	#, tmp421
	movb	%dl, 5(%rbx)	# tmp421,
	movq	%rax, %rdx	# tmp400, tmp426
	shrq	$48, %rax	#, tmp432
	shrq	$40, %rdx	#, tmp426
	movb	%al, 7(%rbx)	# tmp432,
	movb	%dl, 6(%rbx)	# tmp426,
# a.out.c:1269: khasm_87 = khasm_46_Fib_46_fib(khasm_86);
	call	khasm_46_Fib_46_fib@PLT	#
	movq	%rax, %r14	# tmp929, khasm_87
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *khasm_86_10, tmp438
	shrq	$8, %rax	#, tmp438
# a.out.c:208:   a->gc -= 1;
	addq	%r15, %rax	# tmp401, _53
	andq	%r15, %rax	# tmp401, _53
	movq	%rax, %rdx	# _53, tmp451
	movb	%al, 1(%rbx)	# _53,
	shrq	$16, %rdx	#, tmp451
	movb	%ah, 2(%rbx)	# _53,
	movb	%dl, 3(%rbx)	# tmp451,
	movq	%rax, %rdx	# _53, tmp456
	shrq	$24, %rdx	#, tmp456
	movb	%dl, 4(%rbx)	# tmp456,
	movq	%rax, %rdx	# _53, tmp461
	shrq	$32, %rdx	#, tmp461
	movb	%dl, 5(%rbx)	# tmp461,
	movq	%rax, %rdx	# _53, tmp466
	shrq	$40, %rdx	#, tmp466
	movb	%dl, 6(%rbx)	# tmp466,
	movq	%rax, %rdx	# _53, tmp472
	shrq	$48, %rdx	#, tmp472
	movb	%dl, 7(%rbx)	# tmp472,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _53
	je	.L474	#,
.L447:
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
	call	malloc@PLT	#
# a.out.c:1279: khasm_92 = khasm_46_Stdlib_46_isub(khasm_53, khasm_91);
	movq	%rbp, %rdi	# khasm_53,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %rdx	#, tmp483
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %rbx	# tmp930, a
# a.out.c:200:   a->gc += 1;
	movq	0(%rbp), %rax	# *khasm_53_4(D), tmp479
# a.out.c:1279: khasm_92 = khasm_46_Stdlib_46_isub(khasm_53, khasm_91);
	movq	%rbx, %rsi	# a,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp479
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp481
	andq	%rdx, %rax	# tmp483, tmp482
	movq	%rax, %rcx	# tmp482, tmp493
	movb	%al, 1(%rbp)	# tmp482,
	shrq	$16, %rcx	#, tmp493
	movb	%ah, 2(%rbp)	# tmp482,
	movb	%cl, 3(%rbp)	# tmp493,
	movq	%rax, %rcx	# tmp482, tmp498
	shrq	$24, %rcx	#, tmp498
	movb	%cl, 4(%rbp)	# tmp498,
	movq	%rax, %rcx	# tmp482, tmp503
	shrq	$32, %rcx	#, tmp503
	movb	%cl, 5(%rbp)	# tmp503,
	movq	%rax, %rcx	# tmp482, tmp508
	shrq	$48, %rax	#, tmp514
	shrq	$40, %rcx	#, tmp508
	movb	%al, 7(%rbp)	# tmp514,
	movb	%cl, 6(%rbp)	# tmp508,
# a.out.c:189:   a->tag = t;
	movq	$516, (%rbx)	#, MEM[(union  *)a_51]
# a.out.c:288:   k->data.i = i;
	movq	$2, 8(%rbx)	#, a_51->data.i
# a.out.c:1279: khasm_92 = khasm_46_Stdlib_46_isub(khasm_53, khasm_91);
	call	kha_extern_96_int_95_sub@PLT	#
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp483
# a.out.c:1279: khasm_92 = khasm_46_Stdlib_46_isub(khasm_53, khasm_91);
	movq	%rax, %r15	# tmp931, khasm_92
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *khasm_53_4(D), tmp520
	shrq	$8, %rax	#, tmp520
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp483, _48
	andq	%rdx, %rax	# tmp483, _48
	movq	%rax, %rdx	# _48, tmp533
	movb	%al, 1(%rbp)	# _48,
	shrq	$16, %rdx	#, tmp533
	movb	%ah, 2(%rbp)	# _48,
	movb	%dl, 3(%rbp)	# tmp533,
	movq	%rax, %rdx	# _48, tmp538
	shrq	$24, %rdx	#, tmp538
	movb	%dl, 4(%rbp)	# tmp538,
	movq	%rax, %rdx	# _48, tmp543
	shrq	$32, %rdx	#, tmp543
	movb	%dl, 5(%rbp)	# tmp543,
	movq	%rax, %rdx	# _48, tmp548
	shrq	$40, %rdx	#, tmp548
	movb	%dl, 6(%rbp)	# tmp548,
	movq	%rax, %rdx	# _48, tmp554
	shrq	$48, %rdx	#, tmp554
	movb	%dl, 7(%rbp)	# tmp554,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _48
	je	.L475	#,
.L448:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp562
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *a_51, tmp560
	shrq	$8, %rax	#, tmp560
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp562, _46
	andq	%rdx, %rax	# tmp562, _46
	movq	%rax, %rdx	# _46, tmp573
	movb	%al, 1(%rbx)	# _46,
	shrq	$16, %rdx	#, tmp573
	movb	%ah, 2(%rbx)	# _46,
	movb	%dl, 3(%rbx)	# tmp573,
	movq	%rax, %rdx	# _46, tmp578
	shrq	$24, %rdx	#, tmp578
	movb	%dl, 4(%rbx)	# tmp578,
	movq	%rax, %rdx	# _46, tmp583
	shrq	$32, %rdx	#, tmp583
	movb	%dl, 5(%rbx)	# tmp583,
	movq	%rax, %rdx	# _46, tmp588
	shrq	$40, %rdx	#, tmp588
	movb	%dl, 6(%rbx)	# tmp588,
	movq	%rax, %rdx	# _46, tmp594
	shrq	$48, %rdx	#, tmp594
	movb	%dl, 7(%rbx)	# tmp594,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _46
	je	.L476	#,
.L449:
# a.out.c:196:   if (!a) {
	testq	%r15, %r15	# khasm_92
	je	.L446	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %rbp	#, tmp604
# a.out.c:200:   a->gc += 1;
	movq	(%r15), %rax	# *khasm_92_15, tmp600
# a.out.c:1287: khasm_93 = khasm_46_Fib_46_fib(khasm_92);
	movq	%r15, %rdi	# khasm_92,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp600
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp602
	andq	%rbp, %rax	# tmp604, tmp603
	movq	%rax, %rdx	# tmp603, tmp614
	movzbl	%ah, %ecx	# tmp603, tmp1008
	movb	%al, 1(%r15)	# tmp603,
	shrq	$16, %rdx	#, tmp614
	movb	%cl, 2(%r15)	# tmp1008,
	movb	%dl, 3(%r15)	# tmp614,
	movq	%rax, %rdx	# tmp603, tmp619
	shrq	$24, %rdx	#, tmp619
	movb	%dl, 4(%r15)	# tmp619,
	movq	%rax, %rdx	# tmp603, tmp624
	shrq	$32, %rdx	#, tmp624
	movb	%dl, 5(%r15)	# tmp624,
	movq	%rax, %rdx	# tmp603, tmp629
	shrq	$48, %rax	#, tmp635
	shrq	$40, %rdx	#, tmp629
	movb	%al, 7(%r15)	# tmp635,
	movb	%dl, 6(%r15)	# tmp629,
# a.out.c:1287: khasm_93 = khasm_46_Fib_46_fib(khasm_92);
	call	khasm_46_Fib_46_fib@PLT	#
	movq	%rax, %rbx	# tmp932, khasm_93
# a.out.c:208:   a->gc -= 1;
	movq	(%r15), %rax	# *khasm_92_15, tmp641
	shrq	$8, %rax	#, tmp641
# a.out.c:208:   a->gc -= 1;
	addq	%rbp, %rax	# tmp604, _42
	andq	%rbp, %rax	# tmp604, _42
	movq	%rax, %rdx	# _42, tmp654
	movzbl	%ah, %ecx	# _42, tmp1014
	movb	%al, 1(%r15)	# _42,
	shrq	$16, %rdx	#, tmp654
	movb	%cl, 2(%r15)	# tmp1014,
	movb	%dl, 3(%r15)	# tmp654,
	movq	%rax, %rdx	# _42, tmp659
	shrq	$24, %rdx	#, tmp659
	movb	%dl, 4(%r15)	# tmp659,
	movq	%rax, %rdx	# _42, tmp664
	shrq	$32, %rdx	#, tmp664
	movb	%dl, 5(%r15)	# tmp664,
	movq	%rax, %rdx	# _42, tmp669
	shrq	$40, %rdx	#, tmp669
	movb	%dl, 6(%r15)	# tmp669,
	movq	%rax, %rdx	# _42, tmp675
	shrq	$48, %rdx	#, tmp675
	movb	%dl, 7(%r15)	# tmp675,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _42
	je	.L477	#,
.L450:
# a.out.c:196:   if (!a) {
	testq	%r14, %r14	# khasm_87
	je	.L446	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r15	#, tmp685
# a.out.c:200:   a->gc += 1;
	movq	(%r14), %rax	# *khasm_87_12, tmp681
	shrq	$8, %rax	#, tmp681
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp683
	andq	%r15, %rax	# tmp685, tmp684
	movq	%rax, %rdx	# tmp684, tmp695
	movzbl	%ah, %ecx	# tmp684, tmp1021
	movb	%al, 1(%r14)	# tmp684,
	shrq	$16, %rdx	#, tmp695
	movb	%cl, 2(%r14)	# tmp1021,
	movb	%dl, 3(%r14)	# tmp695,
	movq	%rax, %rdx	# tmp684, tmp700
	shrq	$24, %rdx	#, tmp700
	movb	%dl, 4(%r14)	# tmp700,
	movq	%rax, %rdx	# tmp684, tmp705
	shrq	$32, %rdx	#, tmp705
	movb	%dl, 5(%r14)	# tmp705,
	movq	%rax, %rdx	# tmp684, tmp710
	shrq	$48, %rax	#, tmp716
	shrq	$40, %rdx	#, tmp710
	movb	%al, 7(%r14)	# tmp716,
	movb	%dl, 6(%r14)	# tmp710,
# a.out.c:196:   if (!a) {
	testq	%rbx, %rbx	# khasm_93
	je	.L446	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rbx), %rax	# *khasm_93_17, tmp722
# a.out.c:1295: khasm_94 = khasm_46_Stdlib_46_iadd(khasm_87, khasm_93);
	movq	%rbx, %rsi	# khasm_93,
	movq	%r14, %rdi	# khasm_87,
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp722
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp724
	andq	%r15, %rax	# tmp685, tmp725
	movq	%rax, %rdx	# tmp725, tmp736
	movb	%al, 1(%rbx)	# tmp725,
	shrq	$16, %rdx	#, tmp736
	movb	%ah, 2(%rbx)	# tmp725,
	movb	%dl, 3(%rbx)	# tmp736,
	movq	%rax, %rdx	# tmp725, tmp741
	shrq	$24, %rdx	#, tmp741
	movb	%dl, 4(%rbx)	# tmp741,
	movq	%rax, %rdx	# tmp725, tmp746
	shrq	$32, %rdx	#, tmp746
	movb	%dl, 5(%rbx)	# tmp746,
	movq	%rax, %rdx	# tmp725, tmp751
	shrq	$48, %rax	#, tmp757
	shrq	$40, %rdx	#, tmp751
	movb	%al, 7(%rbx)	# tmp757,
	movb	%dl, 6(%rbx)	# tmp751,
# a.out.c:1295: khasm_94 = khasm_46_Stdlib_46_iadd(khasm_87, khasm_93);
	call	kha_extern_96_int_95_add@PLT	#
	movq	%rax, %rbp	# tmp933, khasm_53
# a.out.c:208:   a->gc -= 1;
	movq	(%r14), %rax	# *khasm_87_12, tmp763
	shrq	$8, %rax	#, tmp763
# a.out.c:208:   a->gc -= 1;
	addq	%r15, %rax	# tmp685, _36
	andq	%r15, %rax	# tmp685, _36
	movq	%rax, %rdx	# _36, tmp776
	movzbl	%ah, %ecx	# _36, tmp1033
	movb	%al, 1(%r14)	# _36,
	shrq	$16, %rdx	#, tmp776
	movb	%cl, 2(%r14)	# tmp1033,
	movb	%dl, 3(%r14)	# tmp776,
	movq	%rax, %rdx	# _36, tmp781
	shrq	$24, %rdx	#, tmp781
	movb	%dl, 4(%r14)	# tmp781,
	movq	%rax, %rdx	# _36, tmp786
	shrq	$32, %rdx	#, tmp786
	movb	%dl, 5(%r14)	# tmp786,
	movq	%rax, %rdx	# _36, tmp791
	shrq	$40, %rdx	#, tmp791
	movb	%dl, 6(%r14)	# tmp791,
	movq	%rax, %rdx	# _36, tmp797
	shrq	$48, %rdx	#, tmp797
	movb	%dl, 7(%r14)	# tmp797,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _36
	je	.L478	#,
.L451:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp805
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *khasm_93_17, tmp803
	shrq	$8, %rax	#, tmp803
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp805, _34
	andq	%rdx, %rax	# tmp805, _34
	movq	%rax, %rdx	# _34, tmp816
	movb	%al, 1(%rbx)	# _34,
	shrq	$16, %rdx	#, tmp816
	movb	%ah, 2(%rbx)	# _34,
	movb	%dl, 3(%rbx)	# tmp816,
	movq	%rax, %rdx	# _34, tmp821
	shrq	$24, %rdx	#, tmp821
	movb	%dl, 4(%rbx)	# tmp821,
	movq	%rax, %rdx	# _34, tmp826
	shrq	$32, %rdx	#, tmp826
	movb	%dl, 5(%rbx)	# tmp826,
	movq	%rax, %rdx	# _34, tmp831
	shrq	$40, %rdx	#, tmp831
	movb	%dl, 6(%rbx)	# tmp831,
	movq	%rax, %rdx	# _34, tmp837
	shrq	$48, %rdx	#, tmp837
	movb	%dl, 7(%rbx)	# tmp837,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _34
	jne	.L444	#,
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# khasm_93,
	call	k_free	#
	jmp	.L444	#
	.p2align 4,,10
	.p2align 3
.L471:
	movq	%rbx, %rdi	# tmp231,
	call	k_free	#
	jmp	.L443	#
	.p2align 4,,10
	.p2align 3
.L478:
	movq	%r14, %rdi	# khasm_87,
	call	k_free	#
	jmp	.L451	#
	.p2align 4,,10
	.p2align 3
.L477:
	movq	%r15, %rdi	# khasm_92,
	call	k_free	#
	jmp	.L450	#
	.p2align 4,,10
	.p2align 3
.L476:
	movq	%rbx, %rdi	# a,
	call	k_free	#
	jmp	.L449	#
	.p2align 4,,10
	.p2align 3
.L475:
	movq	%rbp, %rdi	# khasm_53,
	call	k_free	#
	jmp	.L448	#
	.p2align 4,,10
	.p2align 3
.L474:
	movq	%rbx, %rdi	# khasm_86,
	call	k_free	#
	jmp	.L447	#
	.p2align 4,,10
	.p2align 3
.L473:
	movq	%r14, %rdi	# tmp313,
	call	k_free	#
	jmp	.L445	#
.L446:
	call	ref.part.0	#
	.cfi_endproc
.LFE68:
	.size	khasm_46_Fib_46_fib_impl, .-khasm_46_Fib_46_fib_impl
	.p2align 4
	.globl	main_____Khasm_impl
	.type	main_____Khasm_impl, @function
main_____Khasm_impl:
.LFB69:
	.cfi_startproc
	pushq	%r12	#
	.cfi_def_cfa_offset 16
	.cfi_offset 12, -16
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:1317: KHASM_ENTRY(main_____Khasm,1, kha_obj * khasm_54){
	pushq	%rbp	#
	.cfi_def_cfa_offset 24
	.cfi_offset 6, -24
	pushq	%rbx	#
	.cfi_def_cfa_offset 32
	.cfi_offset 3, -32
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:189:   a->tag = t;
	movq	$516, (%rax)	#, MEM[(union  *)a_13]
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %rbp	# tmp219, tmp93
# a.out.c:1323: khasm_101 = khasm_46_Fib_46_fib(khasm_100);
	movq	%rax, %rdi	# tmp93,
# a.out.c:288:   k->data.i = i;
	movq	$35, 8(%rax)	#, a_13->data.i
# a.out.c:1323: khasm_101 = khasm_46_Fib_46_fib(khasm_100);
	call	khasm_46_Fib_46_fib@PLT	#
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rdx	# *a_13, tmp96
# a.out.c:1323: khasm_101 = khasm_46_Fib_46_fib(khasm_100);
	movq	%rax, %rbx	# tmp220, khasm_101
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rax	#, tmp98
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rdx	#, tmp96
# a.out.c:208:   a->gc -= 1;
	addq	%rax, %rdx	# tmp98, _12
	andq	%rax, %rdx	# tmp98, _12
	movq	%rdx, %rax	# _12, tmp109
	movb	%dl, 1(%rbp)	# _12,
	shrq	$16, %rax	#, tmp109
	movb	%dh, 2(%rbp)	# _12,
	movb	%al, 3(%rbp)	# tmp109,
	movq	%rdx, %rax	# _12, tmp114
	shrq	$24, %rax	#, tmp114
	movb	%al, 4(%rbp)	# tmp114,
	movq	%rdx, %rax	# _12, tmp119
	shrq	$32, %rax	#, tmp119
	movb	%al, 5(%rbp)	# tmp119,
	movq	%rdx, %rax	# _12, tmp124
	shrq	$40, %rax	#, tmp124
	movb	%al, 6(%rbp)	# tmp124,
	movq	%rdx, %rax	# _12, tmp130
	shrq	$48, %rax	#, tmp130
	movb	%al, 7(%rbp)	# tmp130,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rdx, %rdx	# _12
	je	.L484	#,
.L480:
# a.out.c:196:   if (!a) {
	testq	%rbx, %rbx	# khasm_101
	je	.L485	#,
# a.out.c:200:   a->gc += 1;
	movq	(%rbx), %rax	# *khasm_101_3, tmp136
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movl	$16, %edi	#,
# a.out.c:200:   a->gc += 1;
	movabsq	$72057594037927935, %r12	#, tmp140
# a.out.c:200:   a->gc += 1;
	shrq	$8, %rax	#, tmp136
# a.out.c:200:   a->gc += 1;
	addq	$1, %rax	#, tmp138
	andq	%r12, %rax	# tmp140, tmp139
	movq	%rax, %rdx	# tmp139, tmp150
	movb	%al, 1(%rbx)	# tmp139,
	shrq	$16, %rdx	#, tmp150
	movb	%ah, 2(%rbx)	# tmp139,
	movb	%dl, 3(%rbx)	# tmp150,
	movq	%rax, %rdx	# tmp139, tmp155
	shrq	$24, %rdx	#, tmp155
	movb	%dl, 4(%rbx)	# tmp155,
	movq	%rax, %rdx	# tmp139, tmp160
	shrq	$32, %rdx	#, tmp160
	movb	%dl, 5(%rbx)	# tmp160,
	movq	%rax, %rdx	# tmp139, tmp165
	shrq	$48, %rax	#, tmp171
	shrq	$40, %rdx	#, tmp165
	movb	%al, 7(%rbx)	# tmp171,
	movb	%dl, 6(%rbx)	# tmp165,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	call	malloc@PLT	#
# a.out.c:1329: khasm_102 = khasm_46_Stdlib_46_apply(ref(make_raw_ptr(&khasm_46_Stdlib_46_print_95_int)), khasm_101);
	movq	%rbx, %rsi	# khasm_101,
# a.out.c:188:   kha_obj * a = malloc(sizeof(kha_obj));
	movq	%rax, %rdi	# tmp221, tmp175
# a.out.c:274:   k->data.ptr = p;
	movq	kha_extern_96_print_95_int@GOTPCREL(%rip), %rax	#, tmp177
# a.out.c:189:   a->tag = t;
	movq	$515, (%rdi)	#, MEM[(union  *)a_8]
# a.out.c:274:   k->data.ptr = p;
	movq	%rax, 8(%rdi)	# tmp177, a_8->data.ptr
# a.out.c:1329: khasm_102 = khasm_46_Stdlib_46_apply(ref(make_raw_ptr(&khasm_46_Stdlib_46_print_95_int)), khasm_101);
	call	khasm_46_Stdlib_46_apply@PLT	#
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rdx	# *khasm_101_3, tmp180
# a.out.c:1329: khasm_102 = khasm_46_Stdlib_46_apply(ref(make_raw_ptr(&khasm_46_Stdlib_46_print_95_int)), khasm_101);
	movq	%rax, %rbp	# tmp222, <retval>
# a.out.c:208:   a->gc -= 1;
	shrq	$8, %rdx	#, tmp180
# a.out.c:208:   a->gc -= 1;
	addq	%r12, %rdx	# tmp140, _7
	andq	%r12, %rdx	# tmp140, _7
	movq	%rdx, %rax	# _7, tmp193
	movb	%dl, 1(%rbx)	# _7,
	shrq	$16, %rax	#, tmp193
	movb	%dh, 2(%rbx)	# _7,
	movb	%al, 3(%rbx)	# tmp193,
	movq	%rdx, %rax	# _7, tmp198
	shrq	$24, %rax	#, tmp198
	movb	%al, 4(%rbx)	# tmp198,
	movq	%rdx, %rax	# _7, tmp203
	shrq	$32, %rax	#, tmp203
	movb	%al, 5(%rbx)	# tmp203,
	movq	%rdx, %rax	# _7, tmp208
	shrq	$40, %rax	#, tmp208
	movb	%al, 6(%rbx)	# tmp208,
	movq	%rdx, %rax	# _7, tmp214
	shrq	$48, %rax	#, tmp214
	movb	%al, 7(%rbx)	# tmp214,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rdx, %rdx	# _7
	je	.L486	#,
# a.out.c:1337: }
	movq	%rbp, %rax	# <retval>,
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 24
	popq	%rbp	#
	.cfi_def_cfa_offset 16
	popq	%r12	#
	.cfi_def_cfa_offset 8
	ret	
	.p2align 4,,10
	.p2align 3
.L484:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbp, %rdi	# tmp93,
	call	k_free	#
	jmp	.L480	#
	.p2align 4,,10
	.p2align 3
.L486:
	movq	%rbx, %rdi	# khasm_101,
	call	k_free	#
# a.out.c:1337: }
	movq	%rbp, %rax	# <retval>,
	popq	%rbx	#
	.cfi_remember_state
	.cfi_def_cfa_offset 24
	popq	%rbp	#
	.cfi_def_cfa_offset 16
	popq	%r12	#
	.cfi_def_cfa_offset 8
	ret	
.L485:
	.cfi_restore_state
	call	ref.part.0	#
	.cfi_endproc
.LFE69:
	.size	main_____Khasm_impl, .-main_____Khasm_impl
	.section	.rodata.str1.8
	.align 8
.LC20:
	.string	"RETURN VALUE NOT TUPLE - TYPE SYSTEM INVALID\n"
	.section	.text.startup,"ax",@progbits
	.p2align 4
	.globl	main
	.type	main, @function
main:
.LFB70:
	.cfi_startproc
	pushq	%rbp	#
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
# a.out.c:1339:   kha_obj * empty = make_tuple(0);
	xorl	%edi, %edi	#
	xorl	%eax, %eax	#
# a.out.c:1338: int main(void) {
	pushq	%rbx	#
	.cfi_def_cfa_offset 24
	.cfi_offset 3, -24
	subq	$8, %rsp	#,
	.cfi_def_cfa_offset 32
# a.out.c:1339:   kha_obj * empty = make_tuple(0);
	call	make_tuple.constprop.0	#
# a.out.c:1340:   kha_obj * ret = main_____Khasm(empty);
	movq	%rax, %rdi	# empty,
# a.out.c:1339:   kha_obj * empty = make_tuple(0);
	movq	%rax, %rbp	# tmp174, empty
# a.out.c:1340:   kha_obj * ret = main_____Khasm(empty);
	call	main_____Khasm@PLT	#
# a.out.c:1341:   if (ret->tag != TUPLE) {
	cmpb	$7, (%rax)	#, ret_7->D.4393.D.4391.tag
# a.out.c:1340:   kha_obj * ret = main_____Khasm(empty);
	movq	%rax, %rbx	# tmp175, ret
# a.out.c:1341:   if (ret->tag != TUPLE) {
	je	.L488	#,
# a.out.c:1342:   fprintf(stderr, "RETURN VALUE NOT TUPLE - TYPE SYSTEM INVALID\n");
	movq	stderr(%rip), %rcx	# stderr,
	movl	$45, %edx	#,
	movl	$1, %esi	#,
	leaq	.LC20(%rip), %rdi	#, tmp92
	call	fwrite@PLT	#
.L488:
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp97
# a.out.c:208:   a->gc -= 1;
	movq	(%rbx), %rax	# *ret_7, tmp95
	shrq	$8, %rax	#, tmp95
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp97, _13
	andq	%rdx, %rax	# tmp97, _13
	movq	%rax, %rdx	# _13, tmp108
	movb	%al, 1(%rbx)	# _13,
	shrq	$16, %rdx	#, tmp108
	movb	%ah, 2(%rbx)	# _13,
	movb	%dl, 3(%rbx)	# tmp108,
	movq	%rax, %rdx	# _13, tmp113
	shrq	$24, %rdx	#, tmp113
	movb	%dl, 4(%rbx)	# tmp113,
	movq	%rax, %rdx	# _13, tmp118
	shrq	$32, %rdx	#, tmp118
	movb	%dl, 5(%rbx)	# tmp118,
	movq	%rax, %rdx	# _13, tmp123
	shrq	$40, %rdx	#, tmp123
	movb	%dl, 6(%rbx)	# tmp123,
	movq	%rax, %rdx	# _13, tmp129
	shrq	$48, %rdx	#, tmp129
	movb	%dl, 7(%rbx)	# tmp129,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _13
	je	.L494	#,
.L489:
# a.out.c:205:   if (!a) {
	testq	%rbp, %rbp	# empty
	je	.L491	#,
# a.out.c:208:   a->gc -= 1;
	movabsq	$72057594037927935, %rdx	#, tmp137
# a.out.c:208:   a->gc -= 1;
	movq	0(%rbp), %rax	# *empty_5, tmp135
	shrq	$8, %rax	#, tmp135
# a.out.c:208:   a->gc -= 1;
	addq	%rdx, %rax	# tmp137, _11
	andq	%rdx, %rax	# tmp137, _11
	movq	%rax, %rdx	# _11, tmp148
	movb	%al, 1(%rbp)	# _11,
	shrq	$16, %rdx	#, tmp148
	movb	%ah, 2(%rbp)	# _11,
	movb	%dl, 3(%rbp)	# tmp148,
	movq	%rax, %rdx	# _11, tmp153
	shrq	$24, %rdx	#, tmp153
	movb	%dl, 4(%rbp)	# tmp153,
	movq	%rax, %rdx	# _11, tmp158
	shrq	$32, %rdx	#, tmp158
	movb	%dl, 5(%rbp)	# tmp158,
	movq	%rax, %rdx	# _11, tmp163
	shrq	$40, %rdx	#, tmp163
	movb	%dl, 6(%rbp)	# tmp163,
	movq	%rax, %rdx	# _11, tmp169
	shrq	$48, %rdx	#, tmp169
	movb	%dl, 7(%rbp)	# tmp169,
# a.out.c:209:   if (a->gc <= 0) {
	testq	%rax, %rax	# _11
	je	.L495	#,
.L491:
# a.out.c:1347: }
	addq	$8, %rsp	#,
	.cfi_remember_state
	.cfi_def_cfa_offset 24
	xorl	%eax, %eax	#
	popq	%rbx	#
	.cfi_def_cfa_offset 16
	popq	%rbp	#
	.cfi_def_cfa_offset 8
	ret	
.L494:
	.cfi_restore_state
# a.out.c:210:     k_free(a);
	movq	%rbx, %rdi	# ret,
	call	k_free	#
	jmp	.L489	#
.L495:
	movq	%rbp, %rdi	# empty,
	call	k_free	#
	jmp	.L491	#
	.cfi_endproc
.LFE70:
	.size	main, .-main
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
